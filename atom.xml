<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Michael翔</title>
  
  <subtitle>因上努力，果上随缘！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://michael728.github.io/"/>
  <updated>2019-06-14T17:01:38.157Z</updated>
  <id>https://michael728.github.io/</id>
  
  <author>
    <name>Michael翔</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker Compose 方式下的容器网络基础知识点</title>
    <link href="https://michael728.github.io/2019/06/15/docker-compose-networks/"/>
    <id>https://michael728.github.io/2019/06/15/docker-compose-networks/</id>
    <published>2019-06-14T16:17:12.000Z</published>
    <updated>2019-06-14T17:01:38.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本周使用 <a href>Docker Compose 方式搭建了 sonarqube 的服务</a>，并进行了总结。遇到的问题：</p><p>我在本地的机器上，一开始用 Compose 的方式创建了一个 MySQL 的容器了。然后在再利用另一份 <code>docker-compose.yml</code> 文件创建 sonarqube 容器时，尝试配置 MySQL 替代 sonarqube 默认采用的 H2 数据库。但是 sonarqube 却怎么也无法连接上 MySQL。</p><p>为了解决这个网络不通的问题，需要了解一下容器间网络通信的基础。</p><p><img src="https://ws1.sinaimg.cn/mw690/6d9475f6ly1g415cdupwjj20fa0faq3q.jpg" alt></p><a id="more"></a><h2 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h2><p>关于 Compose 的网络，官网有专门的一节进行介绍。查看<a href="https://docs.docker.com/compose/networking/" target="_blank" rel="noopener">Networking in Compose</a></p><blockquote><p>By default Compose sets up a single network for your app. Each container for a service joins the default network and is both reachable by other containers on that network, and discoverable by them at a hostname identical to the container name.</p></blockquote><p>Compose 默认给你的 app 设置一个网络。 service 中的每个容器默认都加入这个网络，容器之间彼此是互通的。并且，可以利用容器名字识别到。</p><div class="note warning no-icon">            <p>Note: 你 app 的网络默认情况下是和你的 <code>project name</code> 有关的。这个 <code>project name</code> 其实就是你 docker-compose.yml 文件存放的那个目录的名字。比如，目录名叫 <code>db</code>，那么默认情况下会创建一个叫 <code>db_default</code> 的网络。你可以使用 <code>--project-name</code> 或 <code>COMPSE_PROJECT_NAME</code> 环境变量。</p>          </div><p>举个栗子,<code>docker-compose.yml</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: "3"</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">      - "8000:8000"</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line">    ports:</span><br><span class="line">      - "8001:5432"</span><br></pre></td></tr></table></figure><p>假设，上面这个文件放在 <code>myapp</code> 文件夹下。那么，当你 <code>docker-compose up -d</code> 之后：</p><ul><li>一个叫 <code>myapp_default</code> 网络被创建；</li><li>一个使用 web 配置的容器会被创建，它以 <code>web</code> 的名字加入了 <code>myapp_default</code> 这个网络；</li><li>一个使用 db 配置的容器会被创建，它以 <code>db</code> 的名字加入了 <code>myapp_default</code> 网络；</li></ul><blockquote><p>Each container can now look up the hostname web or db and get back the appropriate container’s IP address</p></blockquote><p>现在，每个容器都可以查找主机名 <code>web</code> 或 <code>db</code>，并获取相应容器的 IP 地址。例如，<code>web</code> 应用的代码可以使用 URL <code>postgres://db:5432</code> 连接数据库并使用它。</p><p>重要的是要注意 <code>HOST_PORT</code> 和 <code>CONTAINER_PORT</code> 之间的区别。前者是指的是宿主机的端口，后者指的是容器中的端口。容器网络中的服务间使用的是 <code>CONTAINER_PORT</code> 通信。<code>HOST_PORT</code> 定义了是为了容器网络外被调用的。所以，前面才使用的是 <code>postgres://db:5432</code> 而不是 <code>postgres://db:8001</code>。因为他们属于同一个容器网络中。</p><p>在官网的 <a href="https://docs.docker.com/compose/compose-file/compose-file-v2/#networks" target="_blank" rel="noopener">Compose file version 2 reference</a> 一段中，也有相关网络介绍。</p><div class="note success no-icon">            <p>Networks to join, referencing entries under the top-level networks key.</p>          </div><p>这句话需要注意到，<code>services</code> 下级的服务中 <code>networks</code> 指定的网络不是指要创建的网络，而是这个服务要加入的网络。</p><p>所以说，这时候如果你指定了一个没有的网络，就会报错啦，类似这种：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Service "mongodb" uses an undefined network "mogo_net"</span><br></pre></td></tr></table></figure><p>需要定义才能加入。经过试验，我在 Compose 文件中，使用 top-level 的 <code>networks</code> 定义一下网络，运行时，会自动创建网络：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">version: "2"</span><br><span class="line">services:</span><br><span class="line">    mongodb:</span><br><span class="line">        image: mongo:4</span><br><span class="line">        container_name: devops-mongo # 容器名</span><br><span class="line">        ports:</span><br><span class="line">            - "27017:27017"</span><br><span class="line">        volumes:</span><br><span class="line">            - "/data/docker_local/mongo/configdb:/data/configdb"</span><br><span class="line">            - "/data/docker_local/mongo/data/db:/data/db"</span><br><span class="line">        command: --auth # 开启授权验证</span><br><span class="line">        networks:</span><br><span class="line">            - mongo_net</span><br><span class="line">networks:</span><br><span class="line">  mongo_net:</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/mw690/6d9475f6ly1g413yjfb2fj21e206o75z.jpg" alt></p><p>发现这时候没有报错了，但是它自动创建的网络好像也不叫 <code>mong_net</code> 而是根据规则，创建的 <code>db_mongo_net</code> 的网络。虽然不报错，但是我觉得有点别扭，查看了一下，可以利用 <code>name</code> 的标签定义一下网络。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">version: "2.1"</span><br><span class="line">services:</span><br><span class="line">    mongodb:</span><br><span class="line">        image: mongo:4</span><br><span class="line">        container_name: devops-mongo # 容器名</span><br><span class="line">        ports:</span><br><span class="line">            - "27017:27017"</span><br><span class="line">        volumes:</span><br><span class="line">            - "/data/docker_local/mongo/configdb:/data/configdb"</span><br><span class="line">            - "/data/docker_local/mongo/data/db:/data/db"</span><br><span class="line">        command: --auth # 开启授权验证</span><br><span class="line">        networks:</span><br><span class="line">            - mongo_net</span><br><span class="line">networks:</span><br><span class="line">  mongo_net:</span><br><span class="line">    name: mongo_net</span><br></pre></td></tr></table></figure><p>这时候启动时，日志显示就比较符合预期了：</p><p><img src="https://ws1.sinaimg.cn/mw690/6d9475f6ly1g41480356uj21do06etag.jpg" alt></p><p>「好奇心宝宝」附身，如果我 name 指定想要的值，上一层，有必要一致吗？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">version: "2.1"</span><br><span class="line">services:</span><br><span class="line">    mongodb:</span><br><span class="line">        image: mongo:4</span><br><span class="line">        container_name: devops-mongo # 容器名</span><br><span class="line">        ports:</span><br><span class="line">            - "27017:27017"</span><br><span class="line">        volumes:</span><br><span class="line">            - "/data/docker_local/mongo/configdb:/data/configdb"</span><br><span class="line">            - "/data/docker_local/mongo/data/db:/data/db"</span><br><span class="line">        command: --auth # 开启授权验证</span><br><span class="line">        networks:</span><br><span class="line">            - mongo_net</span><br><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    name: mongo_net</span><br></pre></td></tr></table></figure><p>上面的这种改法会报错：<code>ERROR: Service &quot;mongodb&quot; uses an undefined network &quot;mongo_net&quot;</code>。所以，顶层的 <code>networks</code> 下一层及的网络名称，要和服务中要加入的名称保持一致才行。这样一试，貌似对上面创建的 <code>db_mongo_net</code> 的网络而不报错的现象理解了。省略了 <code>name</code>, 那么 <code>name</code> 就按照默认规则创建网络了，其实就是类似于：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">version: "2.1"</span><br><span class="line">services:</span><br><span class="line">    mongodb:</span><br><span class="line">        image: mongo:4</span><br><span class="line">        container_name: devops-mongo # 容器名</span><br><span class="line">        ports:</span><br><span class="line">            - "27017:27017"</span><br><span class="line">        volumes:</span><br><span class="line">            - "/data/docker_local/mongo/configdb:/data/configdb"</span><br><span class="line">            - "/data/docker_local/mongo/data/db:/data/db"</span><br><span class="line">        command: --auth # 开启授权验证</span><br><span class="line">        networks:</span><br><span class="line">            - mongo_net</span><br><span class="line">networks:</span><br><span class="line">  mongo_net:</span><br><span class="line">    name: db_mongo_net</span><br></pre></td></tr></table></figure><div class="note warning no-icon">            <p>注意点：name 这个标签，这样的用法需要在 Compose 2.1 版本及以上才能使用</p>          </div><p>通过上面的对比，对 networks 有了初步了解了。那么，Compose 文件中式还不是一定要创建网络才行呢？可不可以利用已有的网络呢？后面的 external 会有介绍。</p><p>PS：通过 <code>docker network ls/rm/create ..</code> 等命令，可以查看或操作容器的网络。</p><h3 id="links"><a href="#links" class="headerlink" title="links"></a>links</h3><blockquote><p>Links allow you to define extra aliases by which a service is reachable from another service. They are not required to enable services to communicate - by default, any service can reach any other service at that service’s name. In the following example, db is reachable from web at the hostnames db and database:</p></blockquote><p>通过链接，您可以给某个 service 定义别名，通过该别名可以从其他服务访问服务。默认情况下，任何服务都可以通过该服务的名称访问任何其他服务。下面的例子中，<code>db</code> 是一个服务名，在 <code>web</code> 服务中，给 <code>db</code> 定义了一个别名 <code>database</code>。那么，在 <code>web</code> 服务中，既可以通过 <code>db</code> 又可以通过 <code>databse</code> 查找到主机名了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">version: "3"</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    links:</span><br><span class="line">      - "db:database"</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure><h3 id="Specify-custom-networks"><a href="#Specify-custom-networks" class="headerlink" title="Specify custom networks"></a>Specify custom networks</h3><blockquote><p>Instead of just using the default app network, you can specify your own networks with the top-level networks key. This lets you create more complex topologies and specify custom network drivers and options. You can also use it to connect services to externally-created networks which aren’t managed by Compose.</p></blockquote><p>为了不使用默认的网络，你可以使用 compsose 文件的 top-level 关键字 <code>networks</code> 自定义网络。这让你可以创建更复杂的拓扑并指定自定义网络驱动程序和选项。 你还可以使用它将服务连接到不由 Compose 管理的外部创建的网络。</p><blockquote><p>Here’s an example Compose file defining two custom networks. The proxy service is isolated from the db service, because they do not share a network in common - only app can talk to both.</p></blockquote><p>这里有一个例子，自定义了两个网络。 <code>proxy</code> 服务和 <code>db</code> 服务是隔离的。因为它俩不共享一个网络，只有 <code>app</code> 服务能够和他俩都能通信。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">version: "3"</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  proxy:</span><br><span class="line">    build: ./proxy</span><br><span class="line">    networks:</span><br><span class="line">      - frontend</span><br><span class="line">  app:</span><br><span class="line">    build: ./app</span><br><span class="line">    networks:</span><br><span class="line">      - frontend</span><br><span class="line">      - backend</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  frontend:</span><br><span class="line">    # Use a custom driver</span><br><span class="line">    driver: custom-driver-1</span><br><span class="line">  backend:</span><br><span class="line">    # Use a custom driver which takes special options</span><br><span class="line">    driver: custom-driver-2</span><br><span class="line">    driver_opts:</span><br><span class="line">      foo: "1"</span><br><span class="line">      bar: "2"</span><br></pre></td></tr></table></figure><h2 id="external"><a href="#external" class="headerlink" title="external"></a>external</h2><p><code>external: true</code> 加上这行表示我这个服务用的网络是用外部的网络，不用自动创建。否则，会按照规则默认创建网络的，例如 <code>db_default</code>、<code>sonarqube_default</code> 这些网络就是默认创建的。如果这个时候没有对应的外部网络，会弹出如下的提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Creating network "db_default" with the default driver</span><br><span class="line">ERROR: Network mysql_net declared as external, but could not be found. Please create the network manually using `docker network create mysql_net` and try again.</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/mw690/6d9475f6ly1g415nm7o6jj21ki0ykn7l.jpg" alt></p><p>注意点：对于 compose 3.3 及更低版本，外部不能与其他网络配置键（driver，driver_opts，ipam，internal）一起使用。版本 3.4 及更高版本不再存在此限制。</p><p>external 标签<a href="https://docs.docker.com/compose/compose-file/#external-1" target="_blank" rel="noopener">官网有详细介绍</a>。</p><h3 id="Use-a-pre-existing-network"><a href="#Use-a-pre-existing-network" class="headerlink" title="Use a pre-existing network"></a>Use a pre-existing network</h3><p>如果你想要你的容器加入到一个已存在的网络中，使用 <code>external</code> 选项:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">version: "3.7"</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  proxy:</span><br><span class="line">    build: ./proxy</span><br><span class="line">    networks:</span><br><span class="line">      - outside</span><br><span class="line">      - default</span><br><span class="line">  app:</span><br><span class="line">    build: ./app</span><br><span class="line">    networks:</span><br><span class="line">      - default</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  outside:</span><br><span class="line">    external: true</span><br></pre></td></tr></table></figure><p>这时候不会去创建一个 <code>[projectname]_outside</code> 的网络， Compose 会去查找一个已存在的叫做 <code>outside</code> 的网络，并且将它和 <code>proxy</code> 服务相连。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://hub.docker.com/_/sonarqube/" target="_blank" rel="noopener">官宣-dockerhub-sonarqube</a></li><li><a href="https://docs.docker.com/compose/compose-file/compose-file-v2/#networks" target="_blank" rel="noopener">compose-file-v2/#network</a></li><li><a href="https://docs.docker.com/compose/networking/" target="_blank" rel="noopener">compose/networking</a> 专门讲解了 compose networking</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本周使用 &lt;a href&gt;Docker Compose 方式搭建了 sonarqube 的服务&lt;/a&gt;，并进行了总结。遇到的问题：&lt;/p&gt;
&lt;p&gt;我在本地的机器上，一开始用 Compose 的方式创建了一个 MySQL 的容器了。然后在再利用另一份 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件创建 sonarqube 容器时，尝试配置 MySQL 替代 sonarqube 默认采用的 H2 数据库。但是 sonarqube 却怎么也无法连接上 MySQL。&lt;/p&gt;
&lt;p&gt;为了解决这个网络不通的问题，需要了解一下容器间网络通信的基础。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/mw690/6d9475f6ly1g415cdupwjj20fa0faq3q.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="容器" scheme="https://michael728.github.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="Docker" scheme="https://michael728.github.io/tags/Docker/"/>
    
      <category term="network" scheme="https://michael728.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>使用 Docker Compose 方式搭建 SonarQube 服务</title>
    <link href="https://michael728.github.io/2019/06/13/docker-compose-install-sonarqube/"/>
    <id>https://michael728.github.io/2019/06/13/docker-compose-install-sonarqube/</id>
    <published>2019-06-13T14:37:10.000Z</published>
    <updated>2019-06-14T17:01:50.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 CICD 流水线中，代码质量其实是很关键的一环。<a href="https://www.sonarqube.org/" target="_blank" rel="noopener">SonarQube</a> 是一个「持续代码质量」检测的服务。在 DevOps 持续集成中对把控代码质量很有帮助。它可以</p><a id="more"></a><h2 id="命令行启动"><a href="#命令行启动" class="headerlink" title="命令行启动"></a>命令行启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name sonarqube -p 9000:9000 -p 9092:9092 sonarqube:7.7-community</span><br><span class="line">docker cp sonarqube:/opt/sonarqube/conf /data/sonar</span><br><span class="line">docker cp sonarqube:/opt/sonarqube/extensions /data/sonar</span><br><span class="line">wget -P /data/sonar/extensions/plugins https://github.com/SonarQubeCommunity/sonar-l10n-zh/releases/download/sonar-l10n-zh-plugin-1.27/sonar-l10n-zh-plugin-1.27.jar</span><br><span class="line">docker stop sonarqube</span><br><span class="line">docker rm sonarqube</span><br></pre></td></tr></table></figure><h2 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h2><p>我使用的是 MySQL 数据库，为了实现权限分离，创建了单独的 sonar 数据库和对应的账号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>docker exec -it devops-mysql</span><br><span class="line"><span class="meta">#</span>mysql -u root -p</span><br><span class="line"><span class="meta">mysql&gt;</span> CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br><span class="line"><span class="meta">mysql&gt;</span> CREATE USER 'sonar' IDENTIFIED BY 'sonar';</span><br><span class="line"><span class="meta">mysql&gt;</span> GRANT ALL ON sonar.* TO 'sonar'@'%' IDENTIFIED BY 'sonar';</span><br><span class="line"><span class="meta">mysql&gt;</span> GRANT ALL ON sonar.* TO 'sonar'@'localhost' IDENTIFIED BY 'sonar';</span><br><span class="line"><span class="meta">mysql&gt;</span> FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p>数据库我也是用 docker 创建的，可以参考之前的文章<a href="https://michael728.github.io/2019/06/02/docker-create-develop-environment/">使用容器 Docker 创建开发环境</a>。</p><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name sonarqube \</span><br><span class="line">    -p 9000:9000 \</span><br><span class="line">    -e sonar.jdbc.username=root \</span><br><span class="line">    -e sonar.jdbc.password=123456 \</span><br><span class="line">    -e sonar.jdbc.url="jdbc:mysql://192.168.3.43:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance&amp;useSSL=false" \</span><br><span class="line">    -v /data/sonar/extensions:/opt/sonarqube/extensions \</span><br><span class="line">    sonarqube:7.7-community</span><br></pre></td></tr></table></figure><blockquote><p>Use of the environment variables SONARQUBE_JDBC_USERNAME, SONARQUBE_JDBC_PASSWORD and SONARQUBE_JDBC_URL is deprecated, and will stop working in future releases.</p></blockquote><p>网上一些教程还是采用的旧的环境变量，官网已经说快要废弃了。</p><h2 id="Compose-方式启动"><a href="#Compose-方式启动" class="headerlink" title="Compose 方式启动"></a>Compose 方式启动</h2><p>如果你 MySQL 和 sonarqube 服务是在一个 docker-compose.yml 文件中的话，那么它们默认会处于同一个容器网络中，sonarqube 是可以连接上的。</p><p>如果是在同一台机器上，MySQL 容器已经创建好了，和 sonarqube 不是同一个 docker-compose.yml 方式创建的，那么，这时候就需要配置，才能让两个容器实现网络互通。</p><p>sonarqube 的 docker-compose.yml：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">version: "2.4"</span><br><span class="line">services:</span><br><span class="line">    sonar:</span><br><span class="line">        image: sonarqube:7.7-community</span><br><span class="line">        container_name: devops-sonar</span><br><span class="line">        ports:</span><br><span class="line">            - "9000:9000"</span><br><span class="line">            - "9002:9002"</span><br><span class="line">        volumes:</span><br><span class="line">            - "/data/sonar/conf:/opt/sonarqube/conf"</span><br><span class="line">            - "/data/sonar/extensions:/opt/sonarqube/extensions"</span><br><span class="line">            - "/data/sonar/logs:/opt/sonarqube/logs"</span><br><span class="line">            - "/data/sonar/data:/opt/sonarqube/data"</span><br><span class="line">        environment:</span><br><span class="line">          sonar.jdbc.username: sonar #root管理员用户密码</span><br><span class="line">          sonar.jdbc.password: sonar   #创建test用户</span><br><span class="line">          sonar.jdbc.url: "jdbc:mysql://devops-mysql:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance&amp;useSSL=false"</span><br><span class="line">        restart: always</span><br><span class="line">        networks:</span><br><span class="line">         - db_net</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  db_net:</span><br><span class="line">    external: true</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/mw690/6d9475f6ly1g4165ysbgkj21gc0y27fl.jpg" alt></p><p>可以发现，这时候 sonarqube 网络和 MySQL 网络是通的，而且，使用 <code>service name</code> 或者 <code>container name</code> 都可以查询到主机。因此，<code>sonar.jdbc.url</code> 可以配置成：</p><ul><li><code>jdbc:mysql://mysql:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance&amp;useSSL=false</code></li><li><code>jdbc:mysql://devops-mysql:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance&amp;useSSL=false</code></li></ul><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>本文的 <code>docker-compose</code> 文件，归档在：<a href="https://github.com/Michael728/awesome-docker-service-for-me" target="_blank" rel="noopener">awesome-docker-service-for-me</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 CICD 流水线中，代码质量其实是很关键的一环。&lt;a href=&quot;https://www.sonarqube.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SonarQube&lt;/a&gt; 是一个「持续代码质量」检测的服务。在 DevOps 持续集成中对把控代码质量很有帮助。它可以&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://michael728.github.io/categories/DevOps/"/>
    
    
      <category term="DevOps" scheme="https://michael728.github.io/tags/DevOps/"/>
    
      <category term="Docker" scheme="https://michael728.github.io/tags/Docker/"/>
    
      <category term="CICD" scheme="https://michael728.github.io/tags/CICD/"/>
    
      <category term="代码质量" scheme="https://michael728.github.io/tags/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>CentOS Nginx 安装及配置</title>
    <link href="https://michael728.github.io/2019/06/08/cicd-centos-install-nginx/"/>
    <id>https://michael728.github.io/2019/06/08/cicd-centos-install-nginx/</id>
    <published>2019-06-08T02:30:05.000Z</published>
    <updated>2019-06-08T02:59:13.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><a href="http://huang-jerryc.com/2016/10/14/%E4%BA%86%E8%A7%A3%20Nginx%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" target="_blank" rel="noopener">了解 Nginx 的基本概念</a></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install nginx # Ubuntu</span><br><span class="line">yum install nginx -y # CentOS</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t # 检查配置文件正确性 test configuration and exit</span><br></pre></td></tr></table></figure><h2 id="主要文件位置"><a href="#主要文件位置" class="headerlink" title="主要文件位置"></a>主要文件位置</h2><ul><li><code>which nginx # or whereis nginx</code>：查看主程序文件</li><li><code>/etc/init.d/</code>：下创建了启动脚本nginx（需手动配置），支持<code>service nginx start</code>命令</li><li><code>/var/log/nginx</code>：日志文件夹，<code>/var/log/nginx/error.log</code>：错误日志文件，<code>/var/log/nginx/access.log</code>：访问日志文件</li><li><code>/etc/nginx/nginx.conf</code>：Nginx全局站点配置文件，日志文件可以在<code>/etc/nginx/nginx.conf</code>中配置，默认读取的配置文件</li><li><code>/etc/nginx/conf.d</code>：自定义Nginx站点配置文件存放目录</li><li><code>/etc/nginx/conf.d/default.conf</code>：网站默认站点配置</li><li><code>/usr/share/nginx/html</code>：网站文件默认存放目录</li><li><code>sites-available</code>：则是管理大量站点时服务器的一种通用配置。</li><li><code>sites-enabled</code>：则是一种单独配置，需要使用<code>enabled</code>时，需要使用<code>ln</code>命令软连接到相应网站。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s ~/path/to/your/mysite/mysite_nginx.conf /etc/nginx/sites-enabled/</span><br></pre></td></tr></table></figure><p><code>/etc/nginx/nginx.conf</code>中有如下语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include /etc/nginx/conf.d/*.conf;</span><br><span class="line">include /etc/nginx/sites-enabled/*;</span><br></pre></td></tr></table></figure></p><p>可见，配置文件放在<code>sites-avaliable</code>文件夹中，需要创建软连接在<code>sites-enabled</code>中，才会生效。</p><p><code>server_name</code>的作用其实是当该机器上同时部署了其他域名服务时起作用的。</p><blockquote><p>如果nginx中只配置一个server域的话，则nginx是不会去进行server_name的匹配的。因为只有一个server域，也就是这有一个虚拟主机，那么肯定是发送到该nginx的所有请求均是要转发到这一个域的，即便做一次匹配也是没有用的。还不如干脆直接就省了。如果一个http域的server域有多个，nginx才会根据$hostname去匹配server_name进而把请求转发到匹配的server域中。此时的匹配会按照匹配的优先级进行，一旦匹配成功进不会再进行匹配</p></blockquote><p>参考：</p><ul><li><a href="https://www.oschina.net/question/922543_91357" target="_blank" rel="noopener">nginx server_name怎么可有可无</a></li></ul><p><code>location</code>接受两个参数，一个字符串或者正则，和一段代码。字符串用于匹配某个特定目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    autoindex on;</span><br><span class="line">    autoindex_exact_size off; # 默认是开，以b为单位，关闭后，会显示MB GB</span><br></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>nginx 默认的账号权限太低，没有部分文件的访问权限，导致访问时出现 <code>403 Forbidden</code>。</p><p>配置文件 <code>/etc/nginx/nginx.conf</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user  nginx;</span><br></pre></td></tr></table></figure></p><p>应该修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user root;</span><br></pre></td></tr></table></figure></p><h2 id="Nginx运行"><a href="#Nginx运行" class="headerlink" title="Nginx运行"></a>Nginx运行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/nginx -h # 查看帮助</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/nginx -c /etc/nginx/nginx.conf # 默认也会读取该配置文件，所以，可以不加-c参数</span><br><span class="line">nginx # 运行/usr/sbin目录下的nginx的命令</span><br><span class="line">nginx -s reload # 运行这句话的前提是，nginx正在运行，重载，如果之前运行了stop，那么会提示出错  &quot;/run/nginx.pid&quot; failed</span><br><span class="line">service nginx start</span><br><span class="line">service nginx status</span><br></pre></td></tr></table></figure><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="Q1：nginx-error-open-“-usr-local-var-run-nginx-pid”-failed-2-No-such-file-or-directory"><a href="#Q1：nginx-error-open-“-usr-local-var-run-nginx-pid”-failed-2-No-such-file-or-directory" class="headerlink" title="Q1：nginx: [error] open() “/usr/local/var/run/nginx.pid” failed (2: No such file or directory)"></a>Q1：nginx: [error] open() “/usr/local/var/run/nginx.pid” failed (2: No such file or directory)</h3><ul><li><a href="https://www.jianshu.com/p/4f8b57632e2b" target="_blank" rel="noopener">nginx 重启报错:nginx</a></li></ul><h3 id="Q2：中文乱码"><a href="#Q2：中文乱码" class="headerlink" title="Q2：中文乱码"></a>Q2：中文乱码</h3><p>Nginx的server的配置内容，增加一行：<code>charset utf-8;</code></p><ul><li><a href="https://blog.csdn.net/qq_35448976/article/details/79256873" target="_blank" rel="noopener">Nginx 显示中文乱码解决</a></li></ul><h3 id="Q3：权限问题导致Nginx-403-Forbidden错误的解决方法"><a href="#Q3：权限问题导致Nginx-403-Forbidden错误的解决方法" class="headerlink" title="Q3：权限问题导致Nginx 403 Forbidden错误的解决方法"></a>Q3：权限问题导致Nginx 403 Forbidden错误的解决方法</h3><ul><li><a href="https://www.jb51.net/article/54190.htm" target="_blank" rel="noopener">权限问题导致Nginx 403 Forbidden错误的解决方法</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://fraserxu.me/2013/06/22/Nginx-for-developers/" target="_blank" rel="noopener">写给Web开发人员看的Nginx介绍</a></li><li><a href="http://blog.qiji.tech/archives/2425" target="_blank" rel="noopener">nginx配置初探</a></li><li><a href="https://codeday.me/collect/20181015/307342.html" target="_blank" rel="noopener">nginx配置文件参数详解（完整版）</a></li><li><a href="https://segmentfault.com/a/1190000012606305" target="_blank" rel="noopener">Nginx浏览目录配置及美化</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://huang-jerryc.com/2016/10/14/%E4%BA%86%E8%A7%A3%20Nginx%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;了解 Nginx 的基本概念&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;apt-get install nginx # Ubuntu&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum install nginx -y # CentOS&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://michael728.github.io/categories/DevOps/"/>
    
    
      <category term="Nginx" scheme="https://michael728.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 基础知识学习</title>
    <link href="https://michael728.github.io/2019/06/08/cicd-nginx-basic/"/>
    <id>https://michael728.github.io/2019/06/08/cicd-nginx-basic/</id>
    <published>2019-06-08T02:21:35.000Z</published>
    <updated>2019-06-08T02:59:39.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><h3 id="基础资料"><a href="#基础资料" class="headerlink" title="基础资料"></a>基础资料</h3><ul><li><a href="https://juejin.im/post/5c85a64d6fb9a04a0e2e038c" target="_blank" rel="noopener">掘金-前端开发者必备的Nginx知识</a> 介绍的比较综合，正向代理反向代理的区别、负载均衡等知识，都有介绍</li><li><a href="https://www.cnblogs.com/jingmoxukong/p/5945200.html#!comments" target="_blank" rel="noopener">静默虚空-Nginx 简易教程</a> 博客园上的一篇推荐文章</li><li><a href="https://www.jianshu.com/p/8bf73d1a758c" target="_blank" rel="noopener">简书-全面了解Nginx到底能做什么</a></li><li><a href="https://blog.csdn.net/zhangskd/article/details/50194069" target="_blank" rel="noopener">Nginx的负载均衡 - 加权轮询 (Weighted Round Robin) 上篇</a>，这个介绍了<code>upstream</code>资源池的调度算法之一，在其<a href="https://blog.csdn.net/column/details/sknginx.html" target="_blank" rel="noopener">专栏</a>还有其他介绍。</li><li><a href="https://colobu.com/2016/12/04/smooth-weighted-round-robin-algorithm/" target="_blank" rel="noopener">平滑的基于权重的轮询算法</a> ：本文也是介绍资源池调度算法的</li><li><a href="https://www.cnblogs.com/52fhy/p/5054516.html#commentform" target="_blank" rel="noopener">理解nginx的配置</a>：介绍的比较全面的一篇文章</li><li><a href="https://zhuanlan.zhihu.com/p/35858793" target="_blank" rel="noopener">Nginx实战（五） 反向代理</a></li><li><a href="https://www.digitalocean.com/community/tutorials/understanding-nginx-http-proxying-load-balancing-buffering-and-caching" target="_blank" rel="noopener">Understanding Nginx HTTP Proxying, Load Balancing, Buffering, and Caching</a></li><li><a href="https://www.thegeekstuff.com/2017/05/nginx-location-examples/" target="_blank" rel="noopener">13 Nginx Location Directive Examples including Regular Expression Modifiers</a> 关于<code>location</code>的作用介绍，很全面</li><li><a href="https://zhuanlan.zhihu.com/p/34415506" target="_blank" rel="noopener">Nginx的Upstream来做负载 部署两台WEB</a> ：这个文章虽然比较少，但是里边明确了<code>upstream</code>名称和<code>proxy_pass</code>配置的对应关系。</li><li><a href="https://segmentfault.com/a/1190000008061457" target="_blank" rel="noopener">proxy_pass的小说明</a>：关于proxy_pass的一些FAQ</li></ul><h3 id="Nginx-性能优化"><a href="#Nginx-性能优化" class="headerlink" title="Nginx 性能优化"></a>Nginx 性能优化</h3><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzA4Nzg5Nzc5OA==&amp;mid=2651674303&amp;idx=1&amp;sn=b34cbf009aac5f901ce81a65df06359f&amp;chksm=8bcb9516bcbc1c006ff36cd7a8a83d40c7b24143d0c76fc15f61bbb2c210355615125aa95d94&amp;mpshare=1&amp;scene=1&amp;srcid=1031DJIgeaaQj5fafJbAc3mg#rd" target="_blank" rel="noopener">百万并发下 Nginx 的优化之道</a></li><li><a href="https://openresty.org/download/agentzh-nginx-tutorials-zhcn.html" target="_blank" rel="noopener">agentzh 的 Nginx 教程</a></li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop       快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。</span><br><span class="line">nginx -s quit       平稳关闭Nginx，保存相关信息，有安排的结束web服务。</span><br><span class="line">nginx -s reload     因改变了Nginx相关配置，需要重新加载配置而重载。</span><br><span class="line">nginx -s reopen     重新打开日志文件。</span><br><span class="line">nginx -c filename   为 Nginx 指定一个配置文件，来代替缺省的。</span><br><span class="line">nginx -t            不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。</span><br><span class="line">nginx -v            显示 nginx 的版本。</span><br><span class="line">nginx -V            显示 nginx 的版本，编译器版本和配置参数。</span><br></pre></td></tr></table></figure><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><blockquote><p>将server节点下的location节点中的proxy_pass配置为：http:// + upstream名称</p></blockquote><p>app.conf：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">upstream micahel-machine-manager &#123;</span><br><span class="line">    server 100.253.128.222:40012;</span><br><span class="line">    server 100.253.128.223:40012;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upstream michael-machine-server &#123;</span><br><span class="line">    server 100.253.128.55:40020;</span><br><span class="line">    server 100.120.128.56:40020;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name michael-api.hw.com;</span><br><span class="line"></span><br><span class="line">    client_max_body_size 20M;</span><br><span class="line">    client_body_buffer_size 10M;</span><br><span class="line">    proxy_redirect     off;</span><br><span class="line">    proxy_set_header   Host             $host;</span><br><span class="line">    proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">    proxy_next_upstream error timeout invalid_header http_502 http_503 http_504;</span><br><span class="line">    proxy_ignore_client_abort on;</span><br><span class="line">    proxy_read_timeout  180;</span><br><span class="line">    proxy_buffering on;</span><br><span class="line">    proxy_buffer_size 8k;</span><br><span class="line"></span><br><span class="line">    proxy_buffers 8 8M;</span><br><span class="line"></span><br><span class="line">    gzip                on;</span><br><span class="line">    gzip_min_length     1000;</span><br><span class="line">    gzip_types          text/plain text/css application/json text/xml application/xml application/xml+rss text/javascript;</span><br><span class="line"></span><br><span class="line">    location /MachineManager/ &#123;</span><br><span class="line">        proxy_pass http://michael-machine-manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /MachineServer/ &#123;</span><br><span class="line">        proxy_pass http://michael-machine-server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    access_log /var/log/nginx/cid.hw.com-access.log main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如何配置 Nginx 呢？可以利用这个神器：</p><ul><li><a href="https://nginxconfig.io/" target="_blank" rel="noopener">NginxConfig</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;资料&quot;&gt;&lt;a href=&quot;#资料&quot; class=&quot;headerlink&quot; title=&quot;资料&quot;&gt;&lt;/a&gt;资料&lt;/h2&gt;&lt;h3 id=&quot;基础资料&quot;&gt;&lt;a href=&quot;#基础资料&quot; class=&quot;headerlink&quot; title=&quot;基础资料&quot;&gt;&lt;/a&gt;基础资料&lt;/h
      
    
    </summary>
    
      <category term="DevOps" scheme="https://michael728.github.io/categories/DevOps/"/>
    
    
      <category term="Nginx" scheme="https://michael728.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>使用 docker-compose 安装搭建 RabbitMQ 集群</title>
    <link href="https://michael728.github.io/2019/06/07/docker-rabbitmq-env/"/>
    <id>https://michael728.github.io/2019/06/07/docker-rabbitmq-env/</id>
    <published>2019-06-07T12:49:11.000Z</published>
    <updated>2019-06-09T14:57:04.983Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/6d9475f6ly1g3t3f9mb01j20hs0but9z.jpg" alt></p><p>本文介绍如何利用 Docker 方式创建 rabbitmq 集群。</p><a id="more"></a><h2 id="rabbitmq-介绍"><a href="#rabbitmq-介绍" class="headerlink" title="rabbitmq 介绍"></a>rabbitmq 介绍</h2><p>在利用 Docker 创建 rabbitmq 容器之前，先了解 rabbitmq 的基础知识。</p><h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><p>RabbitMQ 的 Cluster 集群模式一般分为两种，「普通模式」和「镜像模式」。</p><ol><li><p>普通模式：默认的集群模式，以两个节点（rabbit01、rabbit02）为例来进行说明。对于 Queue 来说，消息实体只存在于其中一个节点 rabbit01（或者 rabbit02），rabbit01 和 rabbit02 两个节点仅有相同的元数据，即队列的结构。当消息进入 rabbit01 节点的 Queue 后，consumer 从 rabbit02 节点消费时，RabbitMQ 会临时在 rabbit01、rabbit02 间进行消息传输，把 A 中的消息实体取出并经过 B 发送给 consumer。所以 consumer 应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理 Queue。否则无论 consumer 连 rabbit01 或 rabbit02，出口总在 rabbit01，会产生瓶颈。当 rabbit01 节点故障后，rabbit02 节点无法取到 rabbit01 节点中还未消费的消息实体。如果做了消息持久化，那么得等 rabbit01 节点恢复，然后才可被消费；如果没有持久化的话，就会产生消息丢失的现象。</p></li><li><p>镜像模式：将需要消费的队列变为镜像队列，存在于多个节点，这样就可以实现 RabbitMQ 的 HA 高可用性。作用就是消息实体会主动在镜像节点之间实现同步，而不是像普通模式那样，在 consumer 消费数据时临时读取。缺点就是，集群内部的同步通讯会占用大量的网络带宽。</p></li></ol><h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><ul><li>RAM node：内存节点将所有的队列、交换机、绑定、用户、权限和 vhost 的元数据定义存储在内存中，好处是可以使得像交换机和队列声明等操作更加的快速</li><li>Disk node：将元数据存储在磁盘中，单节点系统只允许磁盘类型的节点，防止重启 RabbitMQ 的时候，丢失系统的配置信息</li></ul><div class="note warning no-icon">            <p>RabbitMQ 要求在集群中至少有一个磁盘节点，所有其他节点可以是内存节点，当节点加入或者离开集群时，必须要将该变更通知到至少一个磁盘节点。如果集群中唯一的一个磁盘节点崩溃的话，集群仍然可以保持运行，但是无法进行其他操作（增删改查），直到节点恢复。<br>解决方案：设置两个磁盘节点，至少有一个是可用的，可以保存元数据的更改。</p>          </div><h3 id="安装知识点"><a href="#安装知识点" class="headerlink" title="安装知识点"></a>安装知识点</h3><ul><li>建立集群时，节点中的 Erlang Cookie 值要一致，默认情况下，文件在 <code>/var/lib/rabbitmq/.erlang.cookie</code>。</li><li>erlang 是通过主机名来连接服务，必须保证各个主机名之间可以 ping 通。可以通过编辑 <code>/etc/hosts</code> 来手工添加主机名和 IP 对应关系。如果主机名 ping 不通，rabbitmq 服务启动会失败。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> rabbitmqctl stop_app # 停止rabbitmq服务</span><br><span class="line"><span class="meta">$</span> rabbitmqctl join_cluster rabbit@node1 # node2和node1构成集群, node2必须能通过node1的主机名ping通</span><br><span class="line"><span class="meta">$</span> rabbitmqctl start_app # 开启rabbitmq服务</span><br></pre></td></tr></table></figure><ul><li><code>–ram</code> 指的是作为内存节点,要是想做为磁盘节点的话,就不用加 <code>–ram</code> 这个参数了。在 RabbitMQ 集群里，必须至少有一个磁盘节点存在</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> rabbitmqctl join_cluster --ram rabbit@node1</span><br></pre></td></tr></table></figure><ul><li>更改节点属性</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> rabbitmqctl stop_app  # 停止rabbitmq服务</span><br><span class="line"><span class="meta">$</span> rabbitmqctl change_cluster_node_type ram # 更改节点为内存节点</span><br><span class="line">Turning rabbit@node2 into a ram node</span><br><span class="line"><span class="meta">$</span> rabbitmqctl change_cluster_node_type disc # 更改节点为磁盘节点</span><br><span class="line">Turning rabbit@node2 into a disc node</span><br><span class="line"><span class="meta">$</span> rabbitmqctl start_app # 开启rabbitmq服务</span><br></pre></td></tr></table></figure><ul><li>查看集群的状态</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure><ul><li>开启 web 管理工具</li></ul><p>cluster 搭建起来后若在 web 管理工具中 rabbitmq_management 的 Overview 的 Nodes 部分看到 <code>Node statistics not available</code> 的信息，说明在该节点上web管理插件还未启用。 直接在显示提示信息的节点上运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><p>基于 <a href="https://github.com/bitnami/bitnami-docker-rabbitmq" target="_blank" rel="noopener">bitnami/bitnami-docker-rabbitmq</a> 镜像，在一台机器上可以创建一个 rabbitmq cluster：</p><p>docker-compose.yml 内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">version: '2'</span><br><span class="line">services:</span><br><span class="line">  stats:</span><br><span class="line">    image: bitnami/rabbitmq:3.7</span><br><span class="line">    environment:</span><br><span class="line">      - RABBITMQ_NODE_TYPE=stats</span><br><span class="line">      - RABBITMQ_NODE_NAME=rabbit@stats</span><br><span class="line">      - RABBITMQ_ERL_COOKIE=s3cr3tc00ki3</span><br><span class="line">    ports:</span><br><span class="line">      - '15672:15672'</span><br><span class="line">    volumes:</span><br><span class="line">      - 'rabbitmqstats_data:/bitnami'</span><br><span class="line">  queue-disc1:</span><br><span class="line">    image: bitnami/rabbitmq:3.7</span><br><span class="line">    environment:</span><br><span class="line">      - RABBITMQ_NODE_TYPE=queue-disc</span><br><span class="line">      - RABBITMQ_NODE_NAME=rabbit@queue-disc1</span><br><span class="line">      - RABBITMQ_CLUSTER_NODE_NAME=rabbit@stats</span><br><span class="line">      - RABBITMQ_ERL_COOKIE=s3cr3tc00ki3</span><br><span class="line">    volumes:</span><br><span class="line">      - 'rabbitmqdisc1_data:/bitnami'</span><br><span class="line">  queue-ram1:</span><br><span class="line">    image: bitnami/rabbitmq:3.7</span><br><span class="line">    environment:</span><br><span class="line">      - RABBITMQ_NODE_TYPE=queue-ram</span><br><span class="line">      - RABBITMQ_NODE_NAME=rabbit@queue-ram1</span><br><span class="line">      - RABBITMQ_CLUSTER_NODE_NAME=rabbit@stats</span><br><span class="line">      - RABBITMQ_ERL_COOKIE=s3cr3tc00ki3</span><br><span class="line">    volumes:</span><br><span class="line">      - 'rabbitmqram1_data:/bitnami'</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  rabbitmqstats_data:</span><br><span class="line">    driver: local</span><br><span class="line">  rabbitmqdisc1_data:</span><br><span class="line">    driver: local</span><br><span class="line">  rabbitmqram1_data:</span><br><span class="line">    driver: local</span><br></pre></td></tr></table></figure><p>docker-compose 语法格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose [-f &lt;arg&gt;...] [options] [COMMAND] [ARGS...]`</span><br></pre></td></tr></table></figure><p>运行 <code>docker-compose up -d</code> 运行，如果 docker-compose.yml 命名为其他名字，可以通过 <code>-f</code> 参数指定文件。该镜像默认账号密码是 ：<code>user/bitnami</code></p><p>如上方式，会在主机上创建若干 volume，下面是一些关于 volume 的操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">删除不使用的本地 volumes</span><br><span class="line">docker volume prune</span><br><span class="line">docker volume ls</span><br><span class="line">docker volume rm &lt;volume name&gt;</span><br></pre></td></tr></table></figure><p>如上创建好之后，是属于「普通模式」的集群。如果要设置为「镜像模式」，可以参考 <a href="https://blog.csdn.net/winy_lm/article/details/81128181" target="_blank" rel="noopener">Rabbitmq镜像集群部署</a>，比较简单，在管理界面配置：</p><p><img src="http://img.mknight.cn/medivh/1553134452790.png" alt></p><ul><li>Virtual host： 可选参数，针对指定vhost下的queue进行设置</li><li>Name: policy的名称</li><li>Pattern: queue的匹配模式(正则表达式)</li><li>Definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode<ul><li>ha-mode:指明镜像队列的模式，有效值为 all/exactly/nodes<ul><li>all：表示在集群中所有的节点上进行镜像</li><li>exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定</li><li>nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定</li></ul></li><li>ha-params：ha-mode模式需要用到的参数</li><li>ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual</li></ul></li><li>priority：可选参数，policy的优先级</li></ul><h2 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h2><h3 id="创建容器节点"><a href="#创建容器节点" class="headerlink" title="创建容器节点"></a>创建容器节点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --hostname rabbit1 --name myrabbit1 -p 15672:15672 -p 5672:5672 -e RABBITMQ_ERLANG_COOKIE='rabbitcookie' rabbitmq:3.6.15-management</span><br><span class="line">docker run -d --hostname rabbit2 --name myrabbit2 -p 5673:5672 --link myrabbit1:rabbit1 -e RABBITMQ_ERLANG_COOKIE='rabbitcookie' rabbitmq:3.6.15-management</span><br><span class="line">docker run -d --hostname rabbit3 --name myrabbit3 -p 5674:5672 --link myrabbit1:rabbit1 --link myrabbit2:rabbit2 -e RABBITMQ_ERLANG_COOKIE='rabbitcookie' rabbitmq:3.6.15-management</span><br></pre></td></tr></table></figure><ul><li>多个容器之间使用 <code>--link</code> 连接，此属性不能少；<code>--link &lt;docker-name or docker-id&gt;:alias</code>,<code>alias</code> 是源容器在 link 下的别名</li><li>Erlang Cookie值必须相同，也就是 <code>RABBITMQ_ERLANG_COOKIE</code> 参数的值必须相同；</li></ul><p>要想知道 Erlang Cookie 位置，首先要取得 RabbitMQ 启动日志里面的 <code>home dir</code> 路径，作为根路径。使用：<code>docker logs 容器名称</code> 查看。</p><h3 id="加入-RabbitMQ-节点到集群"><a href="#加入-RabbitMQ-节点到集群" class="headerlink" title="加入 RabbitMQ 节点到集群"></a>加入 RabbitMQ 节点到集群</h3><p>设置节点1：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it myrabbit1 bash</span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>设置节点2，加入到集群：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it myrabbit2 bash</span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster --ram rabbit@rabbit1</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><ul><li>参数 <code>--ram</code> 表示设置为内存节点，忽略次参数默认为磁盘节点。</li></ul><p>设置节点3，加入到集群：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it myrabbit3 bash</span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster --ram rabbit@rabbit1</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>设置好之后，使用 <code>http://物理机ip:15672</code> 进行访问了，默认账号密码是 <code>guest/guest</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>MQ 安装：</p><ul><li><a href="https://segmentfault.com/a/1190000010702020" target="_blank" rel="noopener">CentOs7.3 搭建 RabbitMQ 3.6 Cluster 集群服务与使用</a></li><li><a href="https://www.cnblogs.com/vipstone/p/9362388.html" target="_blank" rel="noopener">王磊的博客-RabbitMQ系列（五）使用Docker部署RabbitMQ集群</a></li><li><a href="https://blog.csdn.net/fqydhk/article/details/80624547" target="_blank" rel="noopener">docker-compose配置rabbitmq集群服务器</a></li><li><a href="https://www.rabbitmq.com/clustering.html#peer-discovery-how-does-it-work" target="_blank" rel="noopener">官宣-Clustering Guide</a></li><li><a href="http://mknight.cn/RabbitMQ%20%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2.html" target="_blank" rel="noopener">RabbitMQ 集群部署</a></li></ul><p>MQ 使用：</p><ul><li><a href="https://ddatsh.com/post/dev/mq/rabbitmq-block/" target="_blank" rel="noopener">rabbbitmq 堆积分析</a></li><li><a href="https://juejin.im/post/5cef3cc36fb9a07f070e1057" target="_blank" rel="noopener">RabbitMQ使用教程（四）如何通过持久化保证消息99.99%不丢失？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/6d9475f6ly1g3t3f9mb01j20hs0but9z.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;本文介绍如何利用 Docker 方式创建 rabbitmq 集群。&lt;/p&gt;
    
    </summary>
    
      <category term="容器" scheme="https://michael728.github.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="Docker" scheme="https://michael728.github.io/tags/Docker/"/>
    
      <category term="容器" scheme="https://michael728.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="消息队列" scheme="https://michael728.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>利用 Docker 安装 CICD 神器 Jenkins</title>
    <link href="https://michael728.github.io/2019/06/04/cicd-docker-jenkins/"/>
    <id>https://michael728.github.io/2019/06/04/cicd-docker-jenkins/</id>
    <published>2019-06-04T15:55:08.000Z</published>
    <updated>2019-06-05T15:40:56.723Z</updated>
    
    <content type="html"><![CDATA[<p>Jenkins 学习系列：</p><ul><li><a href="https://michael728.github.io/2018/10/11/cicd-jenkins-01/">CentOS 安装 CICD 利器 Jenkins</a></li><li><a href="https://michael728.github.io/2019/06/04/cicd-docker-jenkins/">利用 Docker 安装 CICD 神器 Jenkins</a></li></ul><p>本文主要介绍如何利用 Docker 来快速搭建 Jenkins，相比较以前的方式，方便快捷很多！</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>由于是基于 Docker 安装 Jenkins，因此，你的环境上必须要安装好 Dokcer，并配置好加速器，不然下载镜像速度可能会比较慢。怎么安装，可以参考如下文章：</p><ul><li><a href="https://michael728.github.io/2019/06/01/docker-centos-install/">Linux–CentOS 安装 Docker 教程</a></li><li><a href="https://michael728.github.io/2019/06/02/docker-useful-often-commands/">Docker 入门指南——常用命令</a></li><li><a href="https://michael728.github.io/2019/06/02/docker-create-develop-environment/">使用容器 Docker 创建开发环境</a></li></ul><h2 id="Docker-命令运行-Jenkins"><a href="#Docker-命令运行-Jenkins" class="headerlink" title="Docker 命令运行 Jenkins"></a>Docker 命令运行 Jenkins</h2><p><a href="https://hub.docker.com/r/jenkinsci/blueocean/tags" target="_blank" rel="noopener">jenkinsci/blueocean</a> 是官方推荐的镜像版本，集成了流水线插键，推荐：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  -u root \</span><br><span class="line">  --name devops-jenkins \</span><br><span class="line">  -d \</span><br><span class="line">  -p 8080:8080 \</span><br><span class="line">  -p 50000:50000 \</span><br><span class="line">  -v /data/docker_local/jenkins-data:/var/jenkins_home \</span><br><span class="line">  -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">  jenkinsci/blueocean:1.15.1</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>-u root</code>：（可选）由于默认的 jenkins用户无权访问 <code>/var/run/docker.sock</code>，您需要以 root 身份运行 Jenkins 以允许 Jenkins 在你流水线上生成 docker 容器执行步骤。这仅影响在 Jenkins 主节点上的运行，如果你计划在你的流水线执行机上去执行，那这不是必须的。</li><li><code>jenkinsci/blueocean</code> 容器的端口 <code>8080</code> 到主机上的端口 <code>8080</code>。 第一个数字代表主机上的端口，而最后一个代表容器的端口。因此，如果您为此选项指定 <code>-p 49000:8080</code> ，您将通过端口主机端口 <code>49000</code> 访问 Jenkins</li></ul><p>更多对参数的说明，访问<a href="https://jenkins.io/doc/book/installing/" target="_blank" rel="noopener">Installing Jenkins</a></p><h2 id="Docker-Compose-运行-Jenkins"><a href="#Docker-Compose-运行-Jenkins" class="headerlink" title="Docker-Compose 运行 Jenkins"></a>Docker-Compose 运行 Jenkins</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">version: "3"</span><br><span class="line">services:</span><br><span class="line">    jenkins:</span><br><span class="line">        image: jenkinsci/blueocean:1.15.1</span><br><span class="line">        container_name: devops-jenkins # 容器名</span><br><span class="line">        user: root</span><br><span class="line">        restart: always</span><br><span class="line">        ports:</span><br><span class="line">            - "8080:8080"</span><br><span class="line">            - "50000:50000"</span><br><span class="line">        volumes:</span><br><span class="line">            - "/data/docker_local/jenkins-data:/var/jenkins_home"</span><br><span class="line">            - "/var/run/docker.sock:/var/run/docker.sock"</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="配置插键代理"><a href="#配置插键代理" class="headerlink" title="配置插键代理"></a>配置插键代理</h3><p>为了提高插键的下载速度，插键高级配置中，配置国内的代理：</p><ul><li><a href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</a></li></ul><p>有一个页面，专门查看 Jenkins 镜像状态的：</p><ul><li><a href="http://mirrors.jenkins-ci.org/status.html" target="_blank" rel="noopener">the status of Jenkins mirrors</a></li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>查看 Jenkins 的运行日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f jenkins</span><br></pre></td></tr></table></figure><h2 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h2><ul><li><a href="https://github.com/Michael728/awesome-docker-service-for-me/tree/master/jenkins" target="_blank" rel="noopener">awesome-docker-service-for-me</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://jenkins.io/zh/doc/book/installing/" target="_blank" rel="noopener">官宣-安装Jenkins-中文</a> 发现翻译的并不是特别好，推荐看<a href="https://jenkins.io/doc/book/installing/" target="_blank" rel="noopener">英文</a></li><li><a href="https://www.imbajin.com/K8S%E7%89%9B%E5%88%80%E5%B0%8F%E8%AF%95CI%E4%B9%8BJenkins%E7%AF%87(%E4%BA%8C" target="_blank" rel="noopener">K8S牛刀小试CI之Jenkins on Docker篇(二)</a>/)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jenkins 学习系列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://michael728.github.io/2018/10/11/cicd-jenkins-01/&quot;&gt;CentOS 安装 CICD 利器 Jenkins&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://michael728.github.io/2019/06/04/cicd-docker-jenkins/&quot;&gt;利用 Docker 安装 CICD 神器 Jenkins&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文主要介绍如何利用 Docker 来快速搭建 Jenkins，相比较以前的方式，方便快捷很多！&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://michael728.github.io/categories/DevOps/"/>
    
    
      <category term="cicd" scheme="https://michael728.github.io/tags/cicd/"/>
    
      <category term="DevOps" scheme="https://michael728.github.io/tags/DevOps/"/>
    
      <category term="Jenkins" scheme="https://michael728.github.io/tags/Jenkins/"/>
    
      <category term="Docker" scheme="https://michael728.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>使用容器 Docker 创建开发环境</title>
    <link href="https://michael728.github.io/2019/06/02/docker-create-develop-environment/"/>
    <id>https://michael728.github.io/2019/06/02/docker-create-develop-environment/</id>
    <published>2019-06-02T07:41:19.000Z</published>
    <updated>2019-06-08T05:01:28.865Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/6d9475f6ly1g3n9oufsy9j20hs0b4myy.jpg" alt></p><p>Docker 容器学习笔记系列：</p><ul><li><a href="https://michael728.github.io/2019/06/01/docker-centos-install/">Linux–CentOS 安装 Docker 教程</a></li><li><a href="https://michael728.github.io/2019/06/02/docker-useful-often-commands/">Docker 入门指南——常用命令</a></li><li><a href="https://michael728.github.io/2019/06/02/docker-create-develop-environment/">使用容器 Docker 创建开发环境</a></li></ul><p>个人在开发时能方便快捷的搭建对应的测试环境，比如搭建一个 Redis 数据库、MongoDB 数据库、Elasticsearch 服务。这样就不用拿公共的基础设施做测试了，避免损坏数据、破坏了线上环境。</p><p>本文就介绍如何利用容器 Docker 来快速搭建开发测试环境。</p><a id="more"></a><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="简单创建"><a href="#简单创建" class="headerlink" title="简单创建"></a>简单创建</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name mysql \</span><br><span class="line">-p 3306:3306 \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>-d</code>：以后台方式运行</li><li><code>--name</code>：将运行的容器命名为 <code>mysql</code></li><li><code>-p</code>：端口映射，<code>host_ip:container_ip</code>，将主机的 3306 端口映射为 容器内部的 3306 端口，数据库连接时，是连接的你的 <code>host_ip</code>，这二者的顺序不要搞混</li><li><code>-e</code>：设置环境变量，指定 <code>root</code> 账号的密码为 <code>123456</code></li></ul><p>上面这种方式运行后，我们将容器中的 mysql 数据和配置文件拷贝到宿主机上。（获取原始配置文件）。</p><p>因为没有将宿主机和容器相关目录挂载，这样会导致容器如果被删除，数据会丢失。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 创建好目录，不然会报错</span><br><span class="line">mkdir -p /dada/docker_local/mysql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将容器中的 mysql 配置文件复制到宿主机中指定路径下，路径你可以根据需要，自行修改</span><br><span class="line">docker cp mysql:/etc/mysql/mysql.conf.d/mysqld.cnf /data/docker_local/mysql/config</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将容器中的 mysql 存储目录复制到宿主机中</span><br><span class="line">docker cp mysql:/var/lib/mysql/ /data/docker_local/mysql/data</span><br></pre></td></tr></table></figure><p>这里放一份默认的配置文件 <code>mysqld.cnf</code>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">pid-file        = /var/run/mysqld/mysqld.pid</span><br><span class="line">socket          = /var/run/mysqld/mysqld.sock</span><br><span class="line">datadir         = /var/lib/mysql</span><br><span class="line"><span class="meta">#</span>log-error      = /var/log/mysql/error.log</span><br><span class="line"><span class="meta">#</span> By default we only accept connections from localhost</span><br><span class="line"><span class="meta">#</span>bind-address   = 127.0.0.1</span><br><span class="line"><span class="meta">#</span> Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">symbolic-links=0</span><br></pre></td></tr></table></figure></p><p>完成上面的操作之后，将已经运行的容器删除：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm mysql</span><br></pre></td></tr></table></figure></p><h3 id="正式创建"><a href="#正式创建" class="headerlink" title="正式创建"></a>正式创建</h3><p>接下来正式运行 MySQL 容器：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name mysql \</span><br><span class="line">-p 3306:3306 \</span><br><span class="line">-v /data/docker_local/mysql/config/mysqld.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf \</span><br><span class="line">-v /data/docker_local/mysql/data/mysql:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure></p><ul><li><code>-v</code>  将宿主机中的文件挂载到将容器中，容器中产生的数据会持久化下来，语法：<code>-v [host-src:]container-dest[:&lt;options&gt;]</code></li></ul><p>其实，如果你一开始就有了默认的配置文件，那么，就可以跳过之前的步骤，直接运行正式的创建 MySQL 容器的命令。</p><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 创建持久化目录</span><br><span class="line">mkdir -p /data/docker_local/mongo/configdb</span><br><span class="line">mkdir -p /data/docker_local/mongo/data/db</span><br><span class="line"></span><br><span class="line">docker run -d \</span><br><span class="line">--name mongo \</span><br><span class="line">-v /data/docker_local/mongo/configdb:/data/configdb \</span><br><span class="line">-v /data/docker_local/mongo/data/db:/data/db \</span><br><span class="line">-p 27017:27017 \</span><br><span class="line">mongo:4 \</span><br><span class="line">--auth</span><br></pre></td></tr></table></figure><p>启动参数含义在 MySQL 启动时已经见过了，除了 <code>auth</code>：</p><ul><li><code>--auth</code>：开启权限验证模式。默认情况下，mongo 数据库没有添加认证约束，为了增强数据库的安全性，我们需要对数据库添加授权认证。当我不加这个认证约束时，一个数据库的账号可以操作另一个数据库的数据，只有加了这个参数，我们针对某些数据库设置的角色，才仅在这个数据库上生效。</li></ul><h3 id="添加管理员账号"><a href="#添加管理员账号" class="headerlink" title="添加管理员账号"></a>添加管理员账号</h3><ul><li>进入容器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mongo mongo admin</span><br></pre></td></tr></table></figure></li></ul><p>进入容器 <code>mongo</code>，运行命令 <code>mongo admin</code>，实现了：</p><ul><li>进入 mongo 命令行</li><li>切换为 admin 数据库</li></ul><p>创建一个拥有最高权限的 root 账号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createUser(&#123; user: &apos;admin&apos;, pwd: &apos;123456&apos;, roles: [ &#123; role: &quot;root&quot;, db: &quot;admin&quot; &#125; ] &#125;);</span><br></pre></td></tr></table></figure></p><p>role 角色参数：</p><ul><li><code>Read</code>：允许用户读取指定数据库</li><li><code>readWrite</code>：允许用户读写指定数据库</li><li><code>dbAdmin</code>：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile</li><li><code>userAdmin</code>：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户</li><li><code>clusterAdmin</code>：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限</li><li><code>readAnyDatabase</code>：只在admin数据库中可用，赋予用户所有数据库的读权限</li><li><code>readWriteAnyDatabase</code>：只在admin数据库中可用，赋予用户所有数据库的读写权限</li><li><code>userAdminAnyDatabase</code>：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限</li><li><code>dbAdminAnyDatabase</code>：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限</li><li><code>root</code>：只在admin数据库中可用。超级账号，超级权限</li></ul><h3 id="创建访问指定数据库的用户"><a href="#创建访问指定数据库的用户" class="headerlink" title="创建访问指定数据库的用户"></a>创建访问指定数据库的用户</h3><p>管理员已经创建成功后，我们需要重新连接 mongo 数据库，用管理员进行登录，并为目标数据库创建目标用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 进入容器，并切换到 admin 数据库</span><br><span class="line">docker exec -it mongo mongo admin</span><br><span class="line"><span class="meta">#</span> 授权 admin</span><br><span class="line">db.auth("admin", "123456");</span><br><span class="line"><span class="meta">#</span> 创建访问指定数据库的用户</span><br><span class="line">use beta;</span><br><span class="line">db.createUser(&#123; user: 'test', pwd:'test', roles: [ &#123;role:"readWrite",db:"beta"&#125;]&#125;);</span><br><span class="line">db.auth("test","test");</span><br><span class="line"><span class="meta">#</span> 尝试插入一条数据</span><br><span class="line">use beta</span><br><span class="line">db.test.insertOne(&#123;name:"michael",age:"28"&#125;)</span><br><span class="line"><span class="meta">#</span> 搜索 test collection 全部记录</span><br><span class="line">db.test.find()</span><br></pre></td></tr></table></figure><p>test 用户可以对(也只能对) beta 库进行操作</p><p>补充：</p><ul><li>查看容器运行日志：<code>docker logs mysql</code></li></ul><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><p><code>docker-compse</code> 俗称 Docker 三剑客，这里试试用它来同时启动 MySQL、MongoDB 吧：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">version: "2"</span><br><span class="line">services:</span><br><span class="line">    mongodb:</span><br><span class="line">        image: mongo:4</span><br><span class="line">        container_name: mongodb # 容器名</span><br><span class="line">        ports:</span><br><span class="line">            - "27017:27017"</span><br><span class="line">        volumes:</span><br><span class="line">            - "/data/docker_local/mongo/configdb:/data/configdb"</span><br><span class="line">            - "/data/docker_local/mongo/data/db:/data/db"</span><br><span class="line">        command: --auth # 开启授权验证</span><br><span class="line">    mysql:</span><br><span class="line">        image: mysql:5.7</span><br><span class="line">        container_name: mysqldb # 容器名</span><br><span class="line">        ports:</span><br><span class="line">            - "3306:3306"</span><br><span class="line">        command: mysqld --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci #设置utf8字符集</span><br><span class="line">        restart: always</span><br><span class="line">        environment:</span><br><span class="line">          MYSQL_ROOT_PASSWORD: 123456 #root管理员用户密码</span><br><span class="line">          MYSQL_USER: test   #创建test用户</span><br><span class="line">          MYSQL_PASSWORD: test  #设置test用户的密码</span><br><span class="line">        volumes:</span><br><span class="line">            - "/data/docker_local/mysql/config/mysqld.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf"</span><br><span class="line">            - "/data/docker_local/mysql/data/mysql:/var/lib/mysql"</span><br></pre></td></tr></table></figure><p>进入到上面编写的docker-compose.yml文件的目录，运行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 启动所有服务</span><br><span class="line">docker-compose up -d</span><br><span class="line"><span class="meta">#</span> 单启动 mysql</span><br><span class="line">docker-compose up -d mysql</span><br><span class="line"><span class="meta">#</span> 暂停 mysql</span><br><span class="line">docker-compose stop mysql</span><br><span class="line"><span class="meta">#</span> 重新启动容器</span><br><span class="line">docker-compose restart mysql</span><br><span class="line"><span class="meta">#</span> 登录到容器中</span><br><span class="line">docker-compose exec mysql bash</span><br><span class="line"><span class="meta">#</span> 删除所有容器和镜像</span><br><span class="line">docker-compose down</span><br><span class="line"><span class="meta">#</span> 显示所有容器</span><br><span class="line">docker-compose ps</span><br><span class="line"><span class="meta">#</span> 查看mysql的日志</span><br><span class="line">docker-compose logs mysql</span><br><span class="line"><span class="meta">#</span> 查看mysql的实时日志</span><br><span class="line">docker-compose logs -f mysql</span><br></pre></td></tr></table></figure><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>使用 Nginx 容器搭建文件服务区</p><p>file.conf：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        client_max_body_size 4G;</span><br><span class="line">        listen  8889;  ## listen for ipv4; this line is default and implied</span><br><span class="line">        server_name &lt;host_ip or domain_name&gt;; # 换成你服务器的 IP 或绑定的域名</span><br><span class="line">        charset utf-8;</span><br><span class="line">        root /data;</span><br><span class="line">        location / &#123;</span><br><span class="line">            autoindex on; # 要想设置nginx的目录浏览功能，必须要打开下面这个参数</span><br><span class="line">            autoindex_exact_size off; # 默认是开，以b为单位，关闭后，会显示MB GB</span><br><span class="line">            autoindex_localtime on;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>docker-compose.yml：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: "2"</span><br><span class="line">services:</span><br><span class="line">    nginx:</span><br><span class="line">        image: nginx</span><br><span class="line">        container_name: nginx # 容器名</span><br><span class="line">        ports:</span><br><span class="line">            - "8889:8889"</span><br><span class="line">        volumes:</span><br><span class="line">            - "/data/nginx/conf.d:/etc/nginx/conf.d"</span><br><span class="line">            - "/data/nginx/data:/data"</span><br><span class="line">        restart: always</span><br></pre></td></tr></table></figure><p>为了避免中文乱码，需要配置 <code>charset utf-8;</code></p><h3 id="怎么给文件服务器设置访问密码呢？只需要修改一下配置即可："><a href="#怎么给文件服务器设置访问密码呢？只需要修改一下配置即可：" class="headerlink" title="怎么给文件服务器设置访问密码呢？只需要修改一下配置即可："></a>怎么给文件服务器设置访问密码呢？只需要修改一下配置即可：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        client_max_body_size 4G;</span><br><span class="line">        listen  8889;  ## listen for ipv4; this line is default and implied</span><br><span class="line">        server_name 207.148.104.42;</span><br><span class="line">        charset utf-8;</span><br><span class="line">        root /data;</span><br><span class="line">        location / &#123;</span><br><span class="line">            auth_basic "Restricted";</span><br><span class="line">            auth_basic_user_file /data/pass_file;</span><br><span class="line">            autoindex on;</span><br><span class="line">            autoindex_exact_size off;</span><br><span class="line">            autoindex_localtime on;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成用户名和密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htpasswd -c -d pass_file michael</span><br></pre></td></tr></table></figure><ul><li><code>htpasswd</code> 命令没有的话，需要：<code>yum install httpd-tools -y</code> 安装；</li><li><code>-c</code> 创建一个文件；</li><li><code>-d</code> 强制 CRYPT 加密密码（最多8个字符，不安全）</li><li><code>-s</code> Force SHA encryption of the password (insecure)</li></ul><p>参考：<a href="https://blog.csdn.net/dutsoft/article/details/55004064" target="_blank" rel="noopener">Nginx配置静态文件服务</a></p><h3 id="控制访问-nginx-的-IP"><a href="#控制访问-nginx-的-IP" class="headerlink" title="控制访问 nginx 的 IP"></a>控制访问 nginx 的 IP</h3><p>网段的写法是这样的：<code>192.168.1.0/24</code> 这样的形式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deny 192.168.1.11;</span><br><span class="line">deny 192.168.1.123;</span><br><span class="line">deny 192.168.1.0/24; # 屏蔽整个192.168.1.* C段IP</span><br></pre></td></tr></table></figure><p>允许某几个 IP 能访问，其他 IP 均不能访问：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">allow 192.168.1.1;</span><br><span class="line">allow 192.168.1.2;</span><br><span class="line">deny all;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        client_max_body_size 4G;</span><br><span class="line">        listen  8889;  ## listen for ipv4; this line is default and implied</span><br><span class="line">        server_name 207.148.104.42;</span><br><span class="line">        charset utf-8;</span><br><span class="line">        root /data;</span><br><span class="line">        location / &#123;</span><br><span class="line">            allow 112.10.84.226;</span><br><span class="line">            deny all;</span><br><span class="line">            auth_basic "Restricted";</span><br><span class="line">            auth_basic_user_file /data/pass_file;</span><br><span class="line">            autoindex on;</span><br><span class="line">            autoindex_exact_size off;</span><br><span class="line">            autoindex_localtime on;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="http://www.21yunwei.com/archives/2540" target="_blank" rel="noopener">[原创]nginx如何禁止指定IP或IP段访问</a></li><li><a href="https://segmentfault.com/a/1190000015591117" target="_blank" rel="noopener">Nginx基础篇（4）- Nginx请求限制和访问控制</a></li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="ifconfig-command-not-found-解决办法"><a href="#ifconfig-command-not-found-解决办法" class="headerlink" title="ifconfig command not found 解决办法"></a>ifconfig command not found 解决办法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install net-tools -y</span><br></pre></td></tr></table></figure><h2 id="本文示例"><a href="#本文示例" class="headerlink" title="本文示例"></a>本文示例</h2><ul><li><a href="https://github.com/Michael728/awesome-docker-service-for-me/tree/master/" target="_blank" rel="noopener">Github-awesome-docker-service-for-me</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://bestzuo.cn/posts/3822108690.html" target="_blank" rel="noopener">使用Docker快速搭建各种测试环境</a> 本文主要参考</li><li><a href="http://luoxia.me/code/2017/04/01/docker%E5%88%9D%E6%AD%A5%E5%AE%9E%E8%B7%B5/" target="_blank" rel="noopener">Docker初步实践</a></li><li><a href="https://blog.csdn.net/yori_chen/article/details/81036149" target="_blank" rel="noopener">CSDN-docker安装mongo及开启用户认证</a></li><li><a href="http://www.spoofer.top/2017/08/07/docker-compose%E5%AE%89%E8%A3%85mysql5.7" target="_blank" rel="noopener">docker-compose 安装mysql5.7</a></li><li><a href="https://juejin.im/post/5a2e4bd66fb9a044fa19cfb7" target="_blank" rel="noopener">使用 Docker Compose 搭建 MySQL 数据库主从复制实例</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/6d9475f6ly1g3n9oufsy9j20hs0b4myy.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;Docker 容器学习笔记系列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://michael728.github.io/2019/06/01/docker-centos-install/&quot;&gt;Linux–CentOS 安装 Docker 教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://michael728.github.io/2019/06/02/docker-useful-often-commands/&quot;&gt;Docker 入门指南——常用命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://michael728.github.io/2019/06/02/docker-create-develop-environment/&quot;&gt;使用容器 Docker 创建开发环境&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;个人在开发时能方便快捷的搭建对应的测试环境，比如搭建一个 Redis 数据库、MongoDB 数据库、Elasticsearch 服务。这样就不用拿公共的基础设施做测试了，避免损坏数据、破坏了线上环境。&lt;/p&gt;
&lt;p&gt;本文就介绍如何利用容器 Docker 来快速搭建开发测试环境。&lt;/p&gt;
    
    </summary>
    
      <category term="容器" scheme="https://michael728.github.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="docker" scheme="https://michael728.github.io/tags/docker/"/>
    
      <category term="Env" scheme="https://michael728.github.io/tags/Env/"/>
    
  </entry>
  
  <entry>
    <title>Docker 入门指南——常用命令</title>
    <link href="https://michael728.github.io/2019/06/02/docker-useful-often-commands/"/>
    <id>https://michael728.github.io/2019/06/02/docker-useful-often-commands/</id>
    <published>2019-06-02T06:13:44.000Z</published>
    <updated>2019-06-07T17:20:02.882Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/6d9475f6ly1g3mthif5qvj20iu09l0t6.jpg" alt></p><p>Docker 容器学习笔记系列：</p><ul><li><a href="https://michael728.github.io/2019/06/01/docker-centos-install/">Linux–CentOS 安装 Docker 教程</a></li><li><a href="https://michael728.github.io/2019/06/02/docker-useful-often-commands/">Docker 入门指南——常用命令</a></li><li><a href="https://michael728.github.io/2019/06/02/docker-create-develop-environment/">使用容器 Docker 创建开发环境</a></li></ul><p>前面已经介绍了 Docker 的安装方式，本文总结一下使用 Docker 的基本概念和常用命令。</p><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="镜像-Image"><a href="#镜像-Image" class="headerlink" title="镜像 Image"></a>镜像 Image</h3><p>镜像是一些打包好的已有的环境，可以被用来启动和创建容器</p><h3 id="容器-Container"><a href="#容器-Container" class="headerlink" title="容器  Container"></a>容器  Container</h3><p>容器是镜像的实例化</p><h3 id="容器的UUID"><a href="#容器的UUID" class="headerlink" title="容器的UUID"></a>容器的UUID</h3><p>UUID – 通用唯一标识符（<code>Universally Unique Identifier</code>）</p><p>容器有三种方式来进行标识：</p><ul><li>长UUID</li><li>短UUID</li><li>Name</li></ul><p>UUID 是 Docker daemon 产生的，在一台主机上是唯一的，在创建容器的时候可以通过 <code>--name</code> 来指定容器的名字，如果不指定会自动分配一个字符串名称。</p><p>通过 <code>docker ps</code>、<code>docker inspect</code> 等命令可以查看到容器的标识信息</p><h3 id="容器启动过程"><a href="#容器启动过程" class="headerlink" title="容器启动过程"></a>容器启动过程</h3><ol><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ol><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><ul><li>查看 <code>image</code> 列表：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker iamges</span><br></pre></td></tr></table></figure><ul><li>下载镜像：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.domain.com/library/ubuntu:14.04</span><br></pre></td></tr></table></figure><h3 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 常用下面这种方式制作镜像，Dockerfile 文件更透明</span><br><span class="line">docker build [-f DockerfileName] -t image_name DockerfilePath</span><br></pre></td></tr></table></figure><p>这里 <code>DockerfilePath</code> 是 Context 上下文目录，在创建的时候会全部上传到 Docker Server 端，所以这个目录不要太大。</p><p>参数说明：</p><ul><li><code>-f</code>/<code>--file</code>：Name of the Dockerfile (Default is ‘PATH/Dockerfile’)，Dockerfile的完整路径</li><li><code>-t</code>/<code>--tag</code>：Name and optionally a tag in the ‘name:tag’ format，指定了镜像名称，镜像的名字及 tag，通常 <code>name:tag</code> 或者 <code>name</code> 格式</li><li><code>--no-cache</code>：Do not use cache when building the image，<a href="https://www.centos.bz/2016/11/rebuild-docker-image-without-cache/" target="_blank" rel="noopener">这篇文章</a>介绍了使用这个参数的场景，构建镜像中有时候包含 <code>git clone</code> 命令，会默认使用缓存，新代码就不会下载了，所以，有时候需要加上这个参数；</li><li><code>--pull</code>，默认 <code>false</code>。Always attempt to pull a newer version of the image，设置该选项，总是尝试 pull 镜像的最新版本</li></ul><p>其他的 <code>build</code> 参数，可以采用 <code>docker build -h</code> 查看。</p><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>删除 <code>image</code> 之前，需要先删除 <code>container</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br><span class="line">docker rm container_id/container_name</span><br></pre></td></tr></table></figure></p><p>删除 <code>image</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rmi &lt;image-id&gt;</span><br><span class="line">docker rmi &lt;image-name&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure></p><p>删除虚悬镜像(<code>dangling image</code>)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$docker image ls -f dangling=true #列出虚悬镜像</span><br><span class="line"></span><br><span class="line">$ docker image prune</span><br><span class="line">WARNING! This will remove all dangling images.</span><br><span class="line">Are you sure you want to continue? [y/N] y</span><br></pre></td></tr></table></figure></p><h3 id="无tag镜像-dangling"><a href="#无tag镜像-dangling" class="headerlink" title="无tag镜像(dangling)"></a>无tag镜像(dangling)</h3><p>显示无 tag 镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker images --filter &quot;dangling=true&quot;</span><br></pre></td></tr></table></figure></p><p>当新构建的镜像占用这个镜像ID的 <code>repo:tag</code> 时，会出现这些图像，将其保留为 <code>：</code> 或 <code>untagged</code>。可以使用如下命令批量删除这类镜像<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker rmi $(docker images -f "dangling=true" -q)</span><br></pre></td></tr></table></figure></p><h3 id="迁移镜像"><a href="#迁移镜像" class="headerlink" title="迁移镜像"></a>迁移镜像</h3><p>保存镜像到文件，语法格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure></p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker save image_name -o file.tar</span><br><span class="line"># Or</span><br><span class="line">docker save image_name --output file.zip</span><br></pre></td></tr></table></figure></p><p>将镜像保存一个 <code>tar</code> 包文件了，也可以是 <code>zip</code> 格式的压缩包。</p><p>加载一个 <code>tar</code> 包的镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i file.tar</span><br></pre></td></tr></table></figure></p><h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><ul><li><p>查看运行中的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></li><li><p>查看所有容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></li><li><p>显示运行的容器里的进程信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top cid</span><br></pre></td></tr></table></figure></li></ul><p>此处， cid 表示你运行的容器名</p><ul><li><p>显示容器详细信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect cid</span><br></pre></td></tr></table></figure></li><li><p>日志查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker logs cid</span><br><span class="line"># 实时查看日志输出</span><br><span class="line">docker logs -f cid</span><br></pre></td></tr></table></figure></li><li><p>查看容器root用户密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs cid 2&gt;&amp;1 | grep &apos;^User: &apos; | tail -n1</span><br></pre></td></tr></table></figure></li></ul><h3 id="容器运行"><a href="#容器运行" class="headerlink" title="容器运行"></a>容器运行</h3><p>语法格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Usage:docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure></p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name cidregistry.domain.com/library/ubuntu:14.04</span><br></pre></td></tr></table></figure></p><p>如果直接 <code>docker run -it registry.domain.com/library/ubuntu</code> 可能会出错，因为不加 <code>tag</code> ，默认就去运行 <code>latest</code> 版本，而本地没有 <code>latest</code> 版本，所以，需要将 <code>image</code>+<code>tag</code>，以冒号分隔拉去。</p><ul><li><code>-i</code> 交互操作</li><li><code>-t</code> 终端</li><li><code>--name</code> 指定容器名字</li><li><code>-d</code> 后台运行一个容器</li><li><code>--rm</code>，表明退出容器后随之将其删除，可以避免浪费空间</li><li><code>-p</code> 映射端口</li><li><code>-v</code> 挂载 volumn</li><li><code>--privileged=false</code> 容器内 root 拥有真正 root 权限</li></ul><p>当处于一个容器中时，利用<code>exit</code>退出容器</p><ul><li>在容器中运行一段程序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run ubuntu apt-get update</span><br></pre></td></tr></table></figure><h3 id="启动已终止（stop）容器："><a href="#启动已终止（stop）容器：" class="headerlink" title="启动已终止（stop）容器："></a>启动已终止（stop）容器：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart 3e8 # 3e8 为容器的 id 号，不需要全写，也可以用容器名替代</span><br></pre></td></tr></table></figure><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><ul><li><p>进入正在运行的容器，退出不会造成容器停止：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it cid /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>附着到正在运行的容器中，退出时会导致容器终止，不常用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach cid</span><br></pre></td></tr></table></figure></li></ul><h3 id="从容器拷贝文件出来"><a href="#从容器拷贝文件出来" class="headerlink" title="从容器拷贝文件出来"></a>从容器拷贝文件出来</h3><p>拷贝文件出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp cid:/container_path to_path</span><br></pre></td></tr></table></figure></p><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker rm cid</span><br><span class="line"># 强制删除</span><br><span class="line">docker rm -f cid</span><br><span class="line"># 删除所有容器</span><br><span class="line"># -q 表示只列出容器的 id 值</span><br><span class="line">docker rm `docker ps -a -q`</span><br></pre></td></tr></table></figure><h3 id="容器运行状态修改"><a href="#容器运行状态修改" class="headerlink" title="容器运行状态修改"></a>容器运行状态修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start/stop/kill/restart cid</span><br></pre></td></tr></table></figure><h3 id="更改容器名字"><a href="#更改容器名字" class="headerlink" title="更改容器名字"></a>更改容器名字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rename old new</span><br></pre></td></tr></table></figure><h2 id="修改容器，制作镜像"><a href="#修改容器，制作镜像" class="headerlink" title="修改容器，制作镜像"></a>修改容器，制作镜像</h2><p><code>image</code> 相当于类，<code>container</code> 相当于实例，不过可以动态给实例安装新软件，然后把这个 <code>container</code> 用 <code>commit</code> 命令固化成一个 <code>image</code>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m "修改yum源" -a "michaelxiang" cid registry.domain.com/ci/centos-os:latest</span><br></pre></td></tr></table></figure></p><p>这种制作镜像的方式并不推荐，因为不如 Dockerfile 方式透明。</p><h2 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker login registry.domain.com -u username -p password</span><br><span class="line">docker push registry.domain.com/michael/IMAGE[:TAG]</span><br></pre></td></tr></table></figure><p>如果支持 accesstoken 权限认证：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login registry.domain.com -u test -p ACCESSTOKEN:XXXXXXXXXXXXX:ACCESSTOKEN</span><br></pre></td></tr></table></figure><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><p>它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p><p>Compose 中有两个重要的概念：</p><ul><li>服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li><li>项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</li></ul><p>Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理</p><ul><li><a href="https://deepzz.com/post/docker-compose-file.html" target="_blank" rel="noopener">如何写docker-compose.yml，Docker compose file 参考文档</a></li><li><a href="https://docs.docker.com/compose/reference/overview/" target="_blank" rel="noopener">官宣-Overview of docker-compose CLI</a></li><li><a href="https://yeasy.gitbooks.io/docker_practice/compose/commands.html" target="_blank" rel="noopener">Docker 三剑客之 Compose 项目</a></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system df</span><br></pre></td></tr></table></figure><h2 id="docker-配置"><a href="#docker-配置" class="headerlink" title="docker 配置"></a>docker 配置</h2><h3 id="daemon-json-文件"><a href="#daemon-json-文件" class="headerlink" title="daemon.json 文件"></a>daemon.json 文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "insecure-registries": ["registry.xxx.com"],</span><br><span class="line">    "registry-mirrors": ["https://xxxx.mirror.domain.com"],</span><br><span class="line">    "exec-opts": ["native.cgroupdriver=systemd"],</span><br><span class="line">    "storage-driver": "overlay2",</span><br><span class="line">    "storage-opts": [</span><br><span class="line">                "overlay2.override_kernel_check=true"</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="Q1：Docker-空间问题"><a href="#Q1：Docker-空间问题" class="headerlink" title="Q1：Docker 空间问题"></a>Q1：Docker 空间问题</h3><p>Docker长时间运行后的volumes目录清理</p><ul><li><a href="https://blog.lutty.me/linux/2017-07/docker-clean-volumes-dir.html" target="_blank" rel="noopener">悟能-Docker长时间运行后的volumes目录清理</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>命令：</p><ul><li><a href="https://docs.docker.com/engine/reference/run/" target="_blank" rel="noopener">官宣——Command-Line Interfaces (CLIs)</a> 强烈<br>推荐</li><li><a href="http://yansu.org/2017/02/21/docker-summary.html" target="_blank" rel="noopener">Docker 使用总结</a> 本文的主要参考</li><li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">Docker 入门教程</a></li><li><a href="https://legacy.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="noopener">Docker —— 从入门到实践</a></li><li><a href="https://zhuanlan.zhihu.com/p/23599229" target="_blank" rel="noopener">只要一小时，零基础入门Docker</a></li><li><a href="https://segmentfault.com/a/1190000008876540#articleHeader4" target="_blank" rel="noopener">SF-docker命令详解</a></li><li><a href="https://www.jianshu.com/p/d1f5ac9f9d4e" target="_blank" rel="noopener">简书-Docker命令使用</a></li><li><a href="https://www.centos.bz/2017/01/docker-images-list-images/" target="_blank" rel="noopener">Docker命令行参考(8) – docker images列出镜像</a> 删除无 tag 镜像</li></ul><p>镜像登录：</p><ul><li><a href="https://segmentfault.com/a/1190000012175537" target="_blank" rel="noopener">docker搭建私有仓库、自签发证书、登录认证</a></li></ul><p>容器间的通信：</p><ul><li><a href="http://www.louisvv.com/archives/695.html" target="_blank" rel="noopener">Docker容器与宿主机同网段互相通信</a></li><li><a href="https://www.jianshu.com/p/21d66ca6115e" target="_blank" rel="noopener">关于对docker run –link的理解</a></li><li><a href="https://cizixs.com/2016/06/12/docker-network-modes-explained/" target="_blank" rel="noopener">cizixs-docker 容器的网络模式</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/6d9475f6ly1g3mthif5qvj20iu09l0t6.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;Docker 容器学习笔记系列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://michael728.github.io/2019/06/01/docker-centos-install/&quot;&gt;Linux–CentOS 安装 Docker 教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://michael728.github.io/2019/06/02/docker-useful-often-commands/&quot;&gt;Docker 入门指南——常用命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://michael728.github.io/2019/06/02/docker-create-develop-environment/&quot;&gt;使用容器 Docker 创建开发环境&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前面已经介绍了 Docker 的安装方式，本文总结一下使用 Docker 的基本概念和常用命令。&lt;/p&gt;
    
    </summary>
    
      <category term="容器" scheme="https://michael728.github.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="Docker" scheme="https://michael728.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>程序流程图学习笔记</title>
    <link href="https://michael728.github.io/2019/06/01/tools-dev-program-flowchart/"/>
    <id>https://michael728.github.io/2019/06/01/tools-dev-program-flowchart/</id>
    <published>2019-06-01T15:57:10.000Z</published>
    <updated>2019-06-02T07:31:02.662Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/6d9475f6ly1g3muh769rxj20hs0cqdho.jpg" alt></p><p>最近刚刚加入了部署小组，对接各个部署系统，业务逻辑有点繁杂，这时候想起来之前学过的流程图，或许，它可以帮我顺利整理出各个业务逻辑吧，因此，有了本文。</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>流程图（<code>FlowChart</code>）是表示算法、工作流或流程的一种框图表示，它以不同类型的框代表不同种类的步骤，每两个步骤之间则以箭头连接。这种表示方法便于说明解决已知问题的方法。流程图在分析、设计、记录及操控许多领域的流程或程序都有广泛应用。</p><h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><blockquote><p>美国国家标准协会是1960年代就开始制定流程图及一些标准符号[3]。而在1970年，国际标准化组织采用其方案[4]。现时通用的版本ISO 5807是在1985年修订[5]。</p></blockquote><p>所以，流程图的绘制是有标准的，每种符号都有其代表的含义。做事，就要做专业。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g2t56jj4ydj30t70lqgn8.jpg" alt></p><p><img src="https://i.loli.net/2019/05/07/5cd1a394d4f07.jpg" alt="2.jpg"></p><h2 id="循环流程图示例"><a href="#循环流程图示例" class="headerlink" title="循环流程图示例"></a>循环流程图示例</h2><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>for 循环形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (表达式 1；表达式 2；表达式 3)&#123;</span><br><span class="line">    执行语句；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2019/05/08/5cd2eb7e450a4.jpg" alt="1.jpg"></p><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p>while 循环形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (条件表达式)&#123;</span><br><span class="line">    执行语句；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2019/05/08/5cd2eb7e4306d.jpg" alt="2.jpg"></p><h3 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do-while 循环"></a>do-while 循环</h3><p><code>do-while</code> 循环形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">    执行语句；</span><br><span class="line">&#125; while(条件表达式)</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2019/05/08/5cd2eca45ddb4.jpg" alt="3.jpg"></p><h2 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h2><ol><li>如果你在公司里不是一锤定音式的人物的话，你就需要对你的文档进行版本管理。流程图也不例外，什么时间发布的什么版本，都要清楚地标出来，「最新」是个用不得的词。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E7%A8%8B%E5%9B%BE" target="_blank" rel="noopener">wiki-流程图</a></li><li><a href="https://support.office.com/zh-tw/article/%E5%BB%BA%E7%AB%8B%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E5%9C%96-e207d975-4a51-4bfa-a356-eeec314bd276" target="_blank" rel="noopener">office-建立基本流程圖</a> 这个包含了一些 Visio 制作流程图的技巧</li><li><a href="https://www.edrawsoft.cn/software/flowchart/" target="_blank" rel="noopener">edraw-流程图专栏</a> 这里介绍了很多技巧</li><li><a href="https://dingyu.me/blog/flowchart-howtos" target="_blank" rel="noopener">丁宇-画Web流程图的一点心得</a> 该作者博客还总结了一篇英文版的 <a href="https://dingyu.me/blog/the-definitive-guide-to-web-flowcharts" target="_blank" rel="noopener">The definitive guide to Web flowcharts</a></li><li><a href="https://blog.csdn.net/sxhelijian/article/details/8222858" target="_blank" rel="noopener">编程基本功训练：流程图画法及练习</a> 介绍了一些比较复杂的例子，借鉴意义</li><li><a href="https://blog.csdn.net/srk950606/article/details/49637147" target="_blank" rel="noopener">【软件工程】看我火眼金睛——系统流程图、程序流程图、数据流图、活动图、状态图、顺序图辨析</a> 介绍了流程图、时序图、数据流程图等基本概念</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/6d9475f6ly1g3muh769rxj20hs0cqdho.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;最近刚刚加入了部署小组，对接各个部署系统，业务逻辑有点繁杂，这时候想起来之前学过的流程图，或许，它可以帮我顺利整理出各个业务逻辑吧，因此，有了本文。&lt;/p&gt;
    
    </summary>
    
      <category term="ToolsDev" scheme="https://michael728.github.io/categories/ToolsDev/"/>
    
    
      <category term="绘图" scheme="https://michael728.github.io/tags/%E7%BB%98%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Linux——CentOS 安装 Docker 教程</title>
    <link href="https://michael728.github.io/2019/06/01/docker-centos-install/"/>
    <id>https://michael728.github.io/2019/06/01/docker-centos-install/</id>
    <published>2019-06-01T09:54:52.000Z</published>
    <updated>2019-06-02T16:12:15.404Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/6d9475f6ly1g3m4o85kngj20hs0buwg3.jpg" alt></p><p>Docker 容器学习笔记系列：</p><ul><li><a href="https://michael728.github.io/2019/06/01/docker-centos-install/">Linux–CentOS 安装 Docker 教程</a></li><li><a href="https://michael728.github.io/2019/06/02/docker-useful-often-commands/">Docker 入门指南——常用命令</a></li><li><a href="https://michael728.github.io/2019/06/02/docker-create-develop-environment/">使用容器 Docker 创建开发环境</a></li></ul><p>本文主要介绍 CentOS 系统安装 Docker 的流程。</p><a id="more"></a><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><h3 id="OS-要求"><a href="#OS-要求" class="headerlink" title="OS 要求"></a>OS 要求</h3><p>CentOS7:</p><blockquote><p>The centos-extras repository must be enabled. This repository is enabled by default, but if you have disabled it, you need to <a href="https://wiki.centos.org/AdditionalResources/Repositories" target="_blank" rel="noopener">re-enable</a> it.<br>The overlay2 storage driver is recommended</p></blockquote><h3 id="卸载旧的版本"><a href="#卸载旧的版本" class="headerlink" title="卸载旧的版本"></a>卸载旧的版本</h3><p>较旧版本的 Docker 被称为 <code>docker</code> 或 <code>docker-engine</code>。如果已安装这些，请卸载它们以及相关的依赖项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><p><code>/var/lib/docker</code> 目录下保存着镜像、容器、卷、网络。官方文档安装的 <code>docker-ce</code> 包，内部源中只有 <code>docker-engine</code>包，<code>docker-ce</code> 是最新的社区版本的包名。</p><h2 id="安装-Docker-CE"><a href="#安装-Docker-CE" class="headerlink" title="安装 Docker CE"></a>安装 Docker CE</h2><h3 id="使用源安装"><a href="#使用源安装" class="headerlink" title="使用源安装"></a>使用源安装</h3><h4 id="设置源"><a href="#设置源" class="headerlink" title="设置源"></a>设置源</h4><p>1.安装依赖的包，<code>yum tils</code> 提供了 <code>yum-config-manager</code> 套件， <code>device-mapper-persistent-data</code> 和 <code>lvm2</code> 是 <code>devicemapper</code> 存储驱动所依赖的包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure><p>2.使用如下命令设置 stable 源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>国内可选择<a href="https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/" target="_blank" rel="noopener">清华大学源-Docker Community Edition 镜像使用帮助</a></p><h4 id="安装-Docker-CE-1"><a href="#安装-Docker-CE-1" class="headerlink" title="安装 Docker CE"></a>安装 Docker CE</h4><p>1.安装最新版本的 Docker CE：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install docker-ce</span><br></pre></td></tr></table></figure></p><p>2.要安装特定版本的 Docker CE，可在 repo 中列出可用版本，然后选择并安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure></p><p>Docker 安装之后， docker 组就被创建了，但没有用户加到这个群组中。</p><p>3.启动 Docekr：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure></p><p>4.可以通过运行 <code>hello-world</code> 镜像来验证 docker 的安装成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world`</span><br></pre></td></tr></table></figure></p><p>这个命令下载一个测试镜像，在容器中运行它。当容器运行时，它会打印一条信息并退出。</p><h3 id="从-RPM-包安装"><a href="#从-RPM-包安装" class="headerlink" title="从 RPM 包安装"></a>从 RPM 包安装</h3><p>如果无法使用 Docker的源来安装 Docker，则可以下载适用于您的发行版的 <code>.rpm</code> 文件并手动安装。每次要升级 Docker 时都需要下载新文件。</p><ol><li>去 <a href="https://download.docker.com/linux/centos/7/x86_64/stable/Packages/" target="_blank" rel="noopener">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</a> 下载 rpm 包</li><li>安装 Docker CE：<code>$ sudo yum install /path/to/package.rpm</code></li></ol><h3 id="升级-Docker-CE"><a href="#升级-Docker-CE" class="headerlink" title="升级 Docker CE"></a>升级 Docker CE</h3><p>使用 <code>yum -y upgrade docker-ce</code> 升级版本。</p><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><ol><li>卸载 Docker 包：<code>$ sudo yum remove docker-ce</code></li><li>主机上的镜像、容器、卷或自定义配置文件不会自动删除。为了删除这些文件，可以运行如下命令：<code>$ sudo rm -rf /var/lib/docker</code></li></ol><p>你必须手动删除任何已编辑的配置文件</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li>如果非 root 用户想要使用 Docker，你应该将该用户添加到 docker 组中：<code>sudo usermod -aG docker your-user</code></li><li>安装 Docker CE 之后，它在基于 <code>DEB</code> 的发行版上会自动启动。在基于 <code>RPM</code> 的发行版上，需要使用相应的 <code>systemctl</code> 或 <code>service</code> 命令手动启动它</li></ol><h2 id="使用-systemd-控制-Docker"><a href="#使用-systemd-控制-Docker" class="headerlink" title="使用 systemd 控制 Docker"></a>使用 systemd 控制 Docker</h2><p><a href="https://docs.docker.com/config/daemon/systemd/#start-the-docker-daemon" target="_blank" rel="noopener">使用 systemd 控制 Docker</a></p><h3 id="手动启动"><a href="#手动启动" class="headerlink" title="手动启动"></a>手动启动</h3><p>大多数 Linux 发行版使用 <code>systemctl</code> 启动服务，如果没有，就用 <code>service</code>命令：</p><ul><li><code>systemctl</code>:<code>$ sudo systemctl start docker</code></li><li><code>service</code>:<code>$ sudo service docker start</code></li></ul><h3 id="系统自启"><a href="#系统自启" class="headerlink" title="系统自启"></a>系统自启</h3><p>If you want Docker to start at boot, see<br>如果你想要实现开启自启 <code>docker</code>，可以看看这篇文章 <a href="https://docs.docker.com/install/linux/linux-postinstall//" target="_blank" rel="noopener">Configure Docker to start on boot</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files|grep docker # 查看 Docker 服务状态</span><br></pre></td></tr></table></figure><h3 id="配置-Docker-daemon-选项"><a href="#配置-Docker-daemon-选项" class="headerlink" title="配置 Docker daemon 选项"></a>配置 Docker daemon 选项</h3><p>推荐的方法是使用平台独立的 <code>daemon.json</code> 文件，默认位于 <code>/etc/docker/</code> 中。详细配置项，查看<a href="https://docs.docker.com/engine/reference/commandline/dockerd//#daemon-configuration-file" target="_blank" rel="noopener">官宣-Daemon configuration file</a>，有一份中文的备注说明：<a href="https://www.cnblogs.com/ningskyer/articles/8330143.html" target="_blank" rel="noopener">docker daemon(dockerd)配置文件daemon.json</a>。</p><p>你可以使用 <code>daemon.json</code> 配置几乎所有守护程序配置选项。下面的例子配置了两个选项。你不能使用 <code>daemon.json</code> 机制配置的一个选项是 <code>HTTP proxy</code>。</p><h4 id="Runtime-directory-and-storage-driver"><a href="#Runtime-directory-and-storage-driver" class="headerlink" title="Runtime directory and storage driver"></a>Runtime directory and storage driver</h4><p>你可能想要通过移动镜像、容器和卷到独立分区来控制磁盘空间。</p><p>为了实现这个，可以在 <code>daemon.json</code> 中做如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data-root&quot;: &quot;/mnt/docker-data&quot;,</span><br><span class="line">    &quot;storage-driver&quot;: &quot;overlay&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="HTTP-HTTPS-proxy"><a href="#HTTP-HTTPS-proxy" class="headerlink" title="HTTP/HTTPS proxy"></a>HTTP/HTTPS proxy</h4><p>Docker 守护进程使用 <code>HTTP_PROXY</code>, <code>HTTPS_PROXY</code> 和 <code>NO_PROXY</code> 环境变量在它的启动环境中来配置 HTTP 和 HTTPS 代理。你不能使用 <code>daemon.json</code> 文件来配置这些环境变量。</p><p>如果你使用的是 HTTP 或 HTTPS 代理服务器，例如在公司设置中，则需要将此配置添加到 Docker systemd 服务文件中。</p><p>1.为 docker 服务创建一个 systemd 目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir -p /etc/systemd/system/docker.service.d</span><br></pre></td></tr></table></figure></p><p>2.创建一个文件 <code>/etc/systemd/system/docker.service.d/http-proxy.conf</code>，加入 <code>HTTP_PROXY</code> 环境变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTP_PROXY=http://proxy.example.com:80/&quot;</span><br></pre></td></tr></table></figure></p><p>或者，如果你使用 HTTPS 代理服务，创建一个文件 <code>/etc/systemd/system/docker.service.d/https-proxy.conf</code>，加入 <code>HTTPS_PROXY</code> 环境变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTPS_PROXY=https://proxy.example.com:443/&quot;</span><br></pre></td></tr></table></figure></p><p>3.如果你拥有内部的 Docker registries 服务或者要使用<a href="https://www.daocloud.io/mirror" target="_blank" rel="noopener">国内的镜像加速器-daocloud.io</a>，你需要通过指定 <code>NO_PROXY</code> 环境变量来不通过代理访问它们：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTP_PROXY=http://proxy.example.com:80/&quot; &quot;NO_PROXY=localhost,127.0.0.1,docker-registry.somecorporation.com,daocloud.io&quot;</span><br></pre></td></tr></table></figure></p><p>这样，你访问 <code>NO_PROXY</code> 中的网址时，就不会走代理，速度会比较快。</p><p>Or, if you are behind an HTTPS proxy server:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTPS_PROXY=https://proxy.example.com:443/&quot; &quot;NO_PROXY=localhost,127.0.0.1,docker-registry.somecorporation.com&quot;</span><br></pre></td></tr></table></figure></p><p>一个实际配置的栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/systemd/system/docker.service.d/ # 先保证有这个目录</span><br><span class="line">cat &lt;&lt;&apos;EOF&apos;&gt;/etc/systemd/system/docker.service.d/http-proxy.conf # 这里一定要记得让内部镜像仓地址不要走代理,否则无法访问我们私有的镜像仓</span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTP_PROXY=http://127.0.0.1:3128/&quot;</span><br><span class="line">Environment=&quot;HTTPS_PROXY=http://127.0.0.1:3128/&quot;</span><br><span class="line">Environment=&quot;NO_PROXY=localhost,127.0.0.0/8,.domain.com&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p><p>4.Flush changes:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure></p><p>5.重启 Docker：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure></p><p>6.验证配置项已经被加载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl show --property=Environment docker</span><br><span class="line">Environment=HTTP_PROXY=http://proxy.example.com:80/</span><br></pre></td></tr></table></figure></p><p>如果你采用的 HTTPS 代理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl show --property=Environment docker</span><br><span class="line">Environment=HTTPS_PROXY=https://proxy.example.com:443/</span><br></pre></td></tr></table></figure></p><h3 id="手动创建-systemd-单元文件"><a href="#手动创建-systemd-单元文件" class="headerlink" title="手动创建 systemd 单元文件"></a>手动创建 systemd 单元文件</h3><p>当你手动安装 Docker 时，如果你想要用 systemd 管理 Docker，可以安装两个单元文件 <code>service</code> 和 <code>socket</code>，参考 <a href="https://github.com/moby/moby/tree/master/contrib/init/systemd" target="_blank" rel="noopener">moby/contrib/init/systemd/</a>，下载文件至 <code>/etc/systemd/system</code>。</p><h2 id="配置使用-docker-镜像仓库"><a href="#配置使用-docker-镜像仓库" class="headerlink" title="配置使用 docker 镜像仓库"></a>配置使用 docker 镜像仓库</h2><h3 id="选择一：ustc的镜像"><a href="#选择一：ustc的镜像" class="headerlink" title="选择一：ustc的镜像"></a>选择一：ustc的镜像</h3><p>新版的 Docker 使用 <code>/etc/docker/daemon.json（Linux）</code> 配置 Daemon：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker" target="_blank" rel="noopener">USTC-Docker镜像使用帮助</a></li></ul><h3 id="选择二：Docker-中国官方镜像加速"><a href="#选择二：Docker-中国官方镜像加速" class="headerlink" title="选择二：Docker 中国官方镜像加速"></a>选择二：Docker 中国官方镜像加速</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.docker-cn.com/registry-mirror" target="_blank" rel="noopener">Docker 中国官方镜像加速</a></li></ul><p>Docker 拖取镜像默认走的是 HTTPS 协议（443端口），一般私有仓库都没有合法的 HTTPS 证书，通过通过配置私有仓库为非安全仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;insecure-registries&quot; : [&quot;hub.h.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>insecure-registries</code> 就是配置的非安全仓库的地址。</p><p>测试配置的结果：</p><blockquote><p>busybox是一个集成了一百多个最常用linux命令和工具的软件,同时它也是一个最小的Linux系统，它提供了该系统的主要功能，例如grep、find、mount以及telnet等但不包含一些与GNU相关的功能和选项</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull busybox</span><br></pre></td></tr></table></figure><h2 id="Docker-存储驱动"><a href="#Docker-存储驱动" class="headerlink" title="Docker 存储驱动"></a>Docker 存储驱动</h2><p>Linux kernel 4.0以后才支持的overlay2（Linux kernel 3.18以后才支持的叫overlayFS）。同时请确保docker的服务端版本不低于1.12，否则无法支持。<code>uname -sr</code> 可以查看系统内核版本。</p><p><code>Docker 1.12.6/v17.03</code> 文档中 CentOS7 系统下安装时，明确说明，用于生产时，必须使用 <code>devicemapper</code> 驱动的 <code>direct-lvm</code> 模式，需要我们提前准备好块设备，以提供更好的稳定性和性能。默认使用 <code>devicemapper</code> 驱动的 <code>loop-lvm</code> 模式，因为安装简单，只适用于测试环境。从 <code>docker info</code> 信息可以看出，<code>loop-lvm</code> 模式最大可用空间只有107GB。生产环境下必须使用 <code>devicemapper</code> 驱动的 <code>direct-lvm</code> 模式，使用块设备，速度更快并且能更有效地使用系统资源。</p><p>在 <code>Docker v17.06</code> 及以后的版本中，关于 <code>OverlayFS</code> 存储驱动，尽量使用 <code>overlay2</code> 而不要使用 <code>overlay</code>，官方的说明是 <code>overlay</code> 可以使用但不建议。使用 <code>overlay2</code> 时 Linux 系统内核要求4.0以上，或者 CentOS7 的内核在 <code>3.10.0-693</code> 以上。Docker-CE v17.06 及以上，在使用 <code>overlay2</code> 驱动时，还需要设置额外的参数，以禁止检测内核为4.0版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>查看当前存储驱动</span><br><span class="line">docker info|grep -i storage</span><br><span class="line"><span class="meta">#</span>停止Docker</span><br><span class="line">service docker stop</span><br><span class="line"><span class="meta">#</span>清空数据，如果有啥需要的请自己备份</span><br><span class="line">rm -rf /var/lib/docker/*</span><br><span class="line"><span class="meta">#</span>修改配置文件</span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"><span class="meta">#</span>如果没有这个文件或没有内容，就直接把下面的粘贴进去</span><br><span class="line"><span class="meta">#</span>不然就只添加那一条</span><br><span class="line"><span class="meta">#</span>如果不是在最后一行加请自行在末尾添加逗号</span><br><span class="line">&#123;</span><br><span class="line"> "storage-driver": "overlay2"</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span>如果是CentOS7或者RedHat7内核在3.10.0-693以下的，设置额外的参数：</span><br><span class="line">&#123;</span><br><span class="line"> "storage-driver": "overlay2",</span><br><span class="line"> "storage-opts": [</span><br><span class="line"> "overlay2.override_kernel_check=true"</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span>当然，也可以通过给docker修改启动参数的方式来</span><br><span class="line"><span class="meta">#</span> 1.修改/etc/init.d/docker</span><br><span class="line"><span class="meta">#</span> 这个直接在 dockerd 后面加参数就行，不过其实和下面的差不多</span><br><span class="line"><span class="meta">#</span> 2.修改/etc/sysconfig/docker</span><br><span class="line"><span class="meta">#</span> 改成类似 other_args="-s overlay2"</span><br><span class="line"><span class="meta">#</span> 3.修改/usr/lib/systemd/system/docker.service</span><br><span class="line"><span class="meta">#</span> 改成类似 ExecStart=/usr/bin/dockerd -s overlay2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>启动docker</span><br><span class="line">service docker start</span><br></pre></td></tr></table></figure><p>通常在生产构建机器上，一般系统盘大小都不大，都会挂载一个较大容量的数据盘，比如 data 目录。那么，为了避免日后 Docker 的根目录 <code>/var/lib/mock</code>过大，撑爆系统盘，我们需要想办法修改一下 Docker 的根目录，主要有两种办法：</p><p>1.先备份 <code>/var/lib/docker</code>的内容，然后在创建<code>/data/docker</code>的软连接: <code>ln -s /data/docker /var/lib/docker</code></p><p>2.修改 <code>daemon.json</code> 配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="meta">#</span> before before 17.06-ce</span><br><span class="line">"graph": "/data/docker",</span><br><span class="line"><span class="meta">#</span> docker after 17.06-ce</span><br><span class="line">"data-root":"/data/docker",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.docker.com/install/linux/docker-ce/centos/#prerequisites" target="_blank" rel="noopener">官宣-Get Docker CE for CentOS</a></li><li><a href="https://docs.docker.com/config/daemon/systemd/#httphttps-proxy" target="_blank" rel="noopener">官宣-Control Docker with systemd-Docker代理设置</a></li><li><a href="http://sheawey.com/post/how-to-install-docker-in-centos7.html" target="_blank" rel="noopener">如何在CentOS 7中安装Docker</a> 这篇文章中提到为了使用 overlay2 必须升级 CentOS 内核，其实也可以不用的</li></ul><p>Dockuer Hub 镜像：</p><ul><li><a href="https://blog.yanzhe.tk/2017/11/09/docker-set-proxy/" target="_blank" rel="noopener">第二天堂-Docker 设置 socks5 代理或使用国内镜像</a></li><li><a href="https://ieevee.com/tech/2016/09/28/docker-mirror.html" target="_blank" rel="noopener">伊布-国内 docker 仓库镜像对比</a> 文中附有一个测试镜像速度的脚本</li><li><a href="https://yq.aliyun.com/articles/29941" target="_blank" rel="noopener">阿里云-Docker 镜像加速器</a></li><li><a href="https://mirrors.huaweicloud.com/" target="_blank" rel="noopener">华为云-Docker Hub 服务</a></li></ul><p>存储驱动：</p><ul><li><a href="https://blog.phpgao.com/update_linux_kernel.html" target="_blank" rel="noopener">老高的技术博客-centos升级内核版本以支持overlay2</a></li><li><a href="http://dockone.io/article/1765" target="_blank" rel="noopener">深入了解Docker存储驱动</a> 一个关于容器和 K8s 相关的社区</li><li><a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/" target="_blank" rel="noopener">官宣-Use the OverlayFS storage driver</a></li><li><a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/" target="_blank" rel="noopener">官宣-Docker storage drivers</a></li><li><a href="http://www.senra.me/docker-switch-storage-driver-to-overlay2-to-optimize-performance/" target="_blank" rel="noopener">senra-Docker切换OverLay(2)——提高性能，加快速度</a></li><li><a href="http://blog.51cto.com/10321203/2090536" target="_blank" rel="noopener">CentOS7.x系统中使用Docker时，在存储方面需要注意的问题</a></li><li><a href="https://www.centosdoc.com/docker/53.html" target="_blank" rel="noopener">运维笔记-DOCKER更改镜像存储位置</a> 描述了常见修改存储位置的两个方法，同时，提到了新旧版本的配置项的注意点</li><li><a href="https://stackoverflow.com/questions/24309526/how-to-change-the-docker-image-installation-directory/34731550#34731550" target="_blank" rel="noopener">SOF-How to change the docker image installation directory</a> 解释了不同版本根目录配置项的区别</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/6d9475f6ly1g3m4o85kngj20hs0buwg3.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;Docker 容器学习笔记系列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://michael728.github.io/2019/06/01/docker-centos-install/&quot;&gt;Linux–CentOS 安装 Docker 教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://michael728.github.io/2019/06/02/docker-useful-often-commands/&quot;&gt;Docker 入门指南——常用命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://michael728.github.io/2019/06/02/docker-create-develop-environment/&quot;&gt;使用容器 Docker 创建开发环境&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文主要介绍 CentOS 系统安装 Docker 的流程。&lt;/p&gt;
    
    </summary>
    
      <category term="容器" scheme="https://michael728.github.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="docker" scheme="https://michael728.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>【转】说说云计算中的地域和可用区概念</title>
    <link href="https://michael728.github.io/2019/06/01/cloud-concept-region-az/"/>
    <id>https://michael728.github.io/2019/06/01/cloud-concept-region-az/</id>
    <published>2019-06-01T03:53:38.000Z</published>
    <updated>2019-06-01T04:23:25.079Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接： <a href="https://yq.aliyun.com/articles/4214" target="_blank" rel="noopener">说说云计算中的地域和可用区概念</a></p></blockquote><p>亚马逊 AWS 是公共云计算的先驱，一些云计算中重要的产品设计和基础概念可以说都是亚马逊引入的。这其中有两个非常重要的概念：地域（<code>Region</code>）和可用区（<code>AZ：Availabe Zone</code>）。很多第一次接触云计算的同学，光看这两个名字的字面意义，虽然也能够猜出大致的意思，但深入的学习了解云计算一段时间之后，才能深刻的体会这两个概念对于云计算的重要影响。包括国内的这些云计算服务商，也是过了很长时间才陆续在产品中引入可用区的设计的。</p><p>理想情况下，我们当然希望云计算能够彻底消除地域的影响，就像我们用电的时候不用关心发电厂在哪里一样。但现实显然没有那么美好，不同地域的机房之间的网络还做不到像电网一样透明。所以在云计算产品的最底层，首先需要考虑不同地域的影响。不同地域之间，一般只能通过公网连通，内部之间网络是不通的。当然，对于云计算服务商来说，为管理需要，一般还是会通过有限的带宽来连通不同地域的机房，用于云计算内部资源管理，以及一些特殊的产品场景，比如跨地域的镜像复制。但因为内部带宽有限，一般不会完全开放给用户使用。</p><p>所以，地域就是物理意义上的不同地方的机房，这个不同地方，一般来说距离较远，机房之间用光纤直连的成本较高。并且相对来说会在用户需求量较大的地方部署地域机房，比如阿里云的云服务器的地域在境内有杭州，上海，北京，深圳，青岛，海外已经上线的包括香港、硅谷和新加坡。实际上阿里云一开始是没有上海地域的，因为上海杭州距离较近，部署直连光纤的成本也相对可控，阿里内部之前很多应用都是分别部署在杭州和上海，基本上是当作一个地域来使用的，后来可能因为需求大而分开了。</p><p>所以，地域很好理解，就是物理上相隔较远的机房，因为跨地域的机房之间的带宽无法满足内网需求，所以不同地域的机器之间内网是不通的。当然，随着骨干网络等物理层基础设施的发展，未来跨地域内网连通并非完全不可能的事情。在这个过程中，公共云计算服务商也可能根据用户的诉求，在某些场景开放一些有限的内部网络带宽来做产品，比如，前面说的阿里云的跨地域镜像复制，以及最近推出来的OSS跨地域复制等。一般来说，在数据和存储领域内的产品会先行支持跨地域的功能，毕竟数据容灾是更强烈的需求。</p><p>那么，同一个地域之内又分成多个可用区，为什么要搞这么复杂？原因很简单，IT系统从远古时代就有同城容灾的需求，那使用云计算以后，怎么实现同城跨机房容灾呢？如果用户购买的云服务器无法区分在哪个机房，那么就无法在业务应用层面来设计同城容灾。所以云计算服务商提出了同地域内不同可用区的概念，简单点理解，可以认为就是同城不同机房，云计算服务商会从底层的机房电力/网络等层面仔细设计来保障一个可用区出现故障的时候不会影响到另外一个可用区，当然你要说杭州彻底被钱塘江潮淹没的情况，那可用区也救不了你，要在业务应用层面考虑通过不同的地域来设计异地容灾了。</p><p>所以，简单来说，可以将地域理解为不同城市的机房，将可用区理解为同一个城市的不同机房。当然，实际上不同可用区也可能是在同一个机房，可用区的概念严格来说是按照电力和网络设备等相互独立来设计的。同一个地域内的不同可用区之间，内网是连通的，但是网络的响应时间会有差异。下面是我用阿里云杭州地域做的一次 ping 的测试，来观察同地域不同可用区之间的网络情况。</p><p>主机1在杭州可用区 B，主机2在杭州可用区 D，数据库 1 在杭州可用区 B。同一个可用区内，从主机 1 ping 数据库 1 的结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ping rdsxxx.mysql.rds.aliyuncs.com</span><br><span class="line">PING rdsxxx.mysql.rds.aliyuncs.com (100.98.xx.xxx) 56(84) bytes of data.</span><br><span class="line">64 bytes from 100.98.xx.xxx: icmp_seq=1 ttl=56 time=0.260 ms</span><br><span class="line">64 bytes from 100.98.xx.xxx: icmp_seq=2 ttl=56 time=0.472 ms</span><br><span class="line">64 bytes from 100.98.xx.xxx: icmp_seq=3 ttl=56 time=0.396 ms</span><br></pre></td></tr></table></figure><p>同地域跨不同可用区，从主机 2 ping 数据库1 的结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ping rdsxxx.mysql.rds.aliyuncs.com</span><br><span class="line">PING rdsxxx.mysql.rds.aliyuncs.com (100.98.xx.xxx) 56(84) bytes of data.</span><br><span class="line">64 bytes from 100.98.xx.xxx: icmp_seq=1 ttl=54 time=1.63 ms</span><br><span class="line">64 bytes from 100.98.xx.xxx: icmp_seq=2 ttl=54 time=1.73 ms</span><br><span class="line">64 bytes from 100.98.xx.xxx: icmp_seq=3 ttl=54 time=1.74 ms</span><br></pre></td></tr></table></figure><p>很明显，不同可用区之间的内网是连通的，但响应时间比同一个可用区之内要慢 1ms 多。所以，在实际应用中，如果需要考虑同城容灾或者同城双活，需要尽量将应用和数据库分布部署在不同的可用区。如果对响应时间高度敏感，则建议部署在同一个可用区内。在购买云服务器和数据库的时候，要注意选择了。</p><p>另外，目前阿里云大数据平台主要部署在杭州地域，如果业务应用的数据需要进入到阿里云大数据平台加工处理，则云服务器和数据库最好优先在杭州地域购买，以后阿里云应该会在更多地域部署大数据平台。不过悲催的是，杭州机房资源整体上比较紧张，杭州地域的云服务器时不时可能断供一小段时间。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里写一下自己对「地域」和「可用区」的理解：</p><p>这两个概念都是对管理的主机的的一个区域的划分。「地域」这个划分的范围比较大，好比一个城市圈的范围。那么「可用区」这个范围可以理解为城市圈中的一个个小区。这个小区住不下了，可以去另外一个小区住。同一个地域里，可用区之间访问是方便、快捷的，所以，一个服务部署时，常常需要在同一「地域」下的不同「可用区」中都部署一下，这样一个挂了、另外一个可以撑起来，不至于服务全挂了。</p><h2 id="补充资料"><a href="#补充资料" class="headerlink" title="补充资料"></a>补充资料</h2><ul><li><a href="https://www.cnblogs.com/cmt/p/aliyun-region-availability-zone.html" target="_blank" rel="noopener">云计算之路-阿里云上：地域与可用区</a></li><li><a href="https://www.cnblogs.com/sammyliu/p/8902556.html" target="_blank" rel="noopener">云区域（region)，可用区（AZ），跨区域数据复制（Cross-region replication）与灾备（Disaster Recovery）（部分1</a></li><li><a href="https://www.cnblogs.com/sammyliu/p/8900697.html" target="_blank" rel="noopener">云区域（region)，可用区（AZ），跨区域数据复制（Cross-region replication）与灾备（Disaster Recovery）（部分2）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接： &lt;a href=&quot;https://yq.aliyun.com/articles/4214&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;说说云计算中的地域和可用区概念&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="Cloud" scheme="https://michael728.github.io/categories/Cloud/"/>
    
    
      <category term="Cloud" scheme="https://michael728.github.io/tags/Cloud/"/>
    
      <category term="概念" scheme="https://michael728.github.io/tags/%E6%A6%82%E5%BF%B5/"/>
    
      <category term="术语" scheme="https://michael728.github.io/tags/%E6%9C%AF%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>利用 Hexo + Github Pages 搭建博客并优化 Next 主题教程</title>
    <link href="https://michael728.github.io/2019/05/19/hexo-blog-full-note/"/>
    <id>https://michael728.github.io/2019/05/19/hexo-blog-full-note/</id>
    <published>2019-05-19T02:10:51.000Z</published>
    <updated>2019-06-01T15:42:42.691Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文总结一下 Hexo 搭建博客的主要流程，能够在日后快速恢复博客环境。</p><p>Hexo 的官方文档写的已经很全面了，本文仅将一些注意点列出。</p><p>安装 Hexo 的文档参考：</p><ul><li><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">官宣-Hexo 文档</a></li></ul><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>安装 Hexo 之前，你的电脑上需要有</p><ul><li>Node.js</li><li>Git</li></ul><p>如果是 Mac 用户， 您在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 <code>Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install</code> 安装命令行工具</p><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>全局安装 <code>hexo-cli</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><p>如果遇到权限的问题，可以使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R $(whoami) /usr/local/lib/node_modules/</span><br></pre></td></tr></table></figure></p><p>设置 <code>/usr/local/lib/node_modules/</code> 文件夹属于当前用户。</p><p>此外，如果你要使用 root 权限安装的话，可以使用 <code>sudo -s</code> 切为 root 用户进行相关操作。这么做的话，会将一些文件夹的默认属组设置为 root 了，不推荐。</p><p>npm 权限问题：</p><ul><li><a href="https://npm.community/t/global-installs-sudo-npm-i-g-fail-on-mac-after-6-5-upgrade-works-fine-after-6-4-1-downgrade/4082" target="_blank" rel="noopener">Global installs (sudo npm i -g) fail on Mac after 6.5 upgrade. Works fine after 6.4.1 downgrade</a></li><li><a href="https://zhuanlan.zhihu.com/p/35856841" target="_blank" rel="noopener">npm，yarn如何查看源和换源</a></li></ul><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init MyBlog</span><br><span class="line">cd MyBlog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>执行完毕之后，博客其实已经 OK 了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>执行上面命令即可本地预览博客内容了。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p><a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">官宣-站点配置文件</a> 内容中介绍了很多字段的用途</p><p>Hexo 提供快速一键部署，将博客部署到 GIthub Pages。</p><p>安装 <code>hexo-deployer-git</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd MyBlog</span><br><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>修改站点配置文件中的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># npm install hexo-deployer-git --save</span><br><span class="line">deploy:</span><br><span class="line">- type: git</span><br><span class="line">  repo: git@github.com:Michael728/michael728.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p>执行部署：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">hexo 常用指令</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo version # 显示hexo版本</span><br><span class="line">hexo new &lt;title&gt; # 创建新文章</span><br><span class="line">hexo g/generate # 生成静态文件</span><br><span class="line">hexo clean # 清除缓存文件和已生成的静态文件（public）</span><br><span class="line">hexo server # 启动本地服务器</span><br><span class="line">hexo d/deploy # 部署网站</span><br><span class="line">hexo list &lt;type&gt; # 列出网站资料</span><br></pre></td></tr></table></figure><p>npm 常用指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install 模块名 -g --save # g全局安装 save安装包信息将加入到dependencies（生产阶段的依赖）</span><br><span class="line">npm install gulp@3.9.1 # 指定版本</span><br><span class="line">npm install # 该命令可以根据dependencies配置安装所有的依赖包</span><br><span class="line">npm update [-g] 模块名</span><br><span class="line">npm outdated 模块名 # 检查模块是否过时</span><br><span class="line">npm ls -g # 查看全局安装的模块</span><br><span class="line">npm uninstall 模块名</span><br><span class="line">npm info hexo-cli # 查看hexo-cli模块的信息</span><br></pre></td></tr></table></figure></p><ul><li><a href="https://www.jianshu.com/p/087d839e1d0c" target="_blank" rel="noopener">npm常用命令</a></li><li><a href="http://www.cnblogs.com/PeunZhang/p/5553574.html" target="_blank" rel="noopener">【原】npm 常用命令详解</a></li></ul><h2 id="Hexo-写作技巧"><a href="#Hexo-写作技巧" class="headerlink" title="Hexo 写作技巧"></a>Hexo 写作技巧</h2><ul><li><a href="https://bestzuo.cn/posts/3147047336.html" target="_blank" rel="noopener">Sanarous-hexo博客Next主题进阶写作技巧</a></li></ul><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note [class] [no-icon] %&#125;</span><br><span class="line">这里写你需要写的内容</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">// 注意上面的class和no-icon属性是可以选择的</span><br><span class="line">[class]   : default | primary | success | info | warning | danger.</span><br><span class="line">[no-icon] : Disable icon in note.</span><br></pre></td></tr></table></figure></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note success no-icon %&#125;</span><br><span class="line">success形式的类别</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></p><p>效果：<br><div class="note success no-icon">            <p>success形式的类别</p>          </div></p><p>这里使用 <code>no-icon</code> 表示不显示图标，可选，默认会带有图标。</p><h3 id="使用主题自带-FontAwesome-图标"><a href="#使用主题自带-FontAwesome-图标" class="headerlink" title="使用主题自带 FontAwesome 图标"></a>使用主题自带 FontAwesome 图标</h3><p>源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- &lt;i class=&quot;fa fa-pencil&quot;&gt;&lt;/i&gt; 铅笔</span><br><span class="line">- &lt;i class=&quot;fa fa-cloud-upload&quot;&gt;&lt;/i&gt; 上传</span><br><span class="line">- &lt;i class=&quot;fa fa-download&quot;&gt;&lt;/i&gt; 下载</span><br></pre></td></tr></table></figure></p><p>效果：</p><ul><li><i class="fa fa-pencil"></i> 铅笔</li><li><i class="fa fa-cloud-upload"></i> 上传</li><li><i class="fa fa-download"></i> 下载</li></ul><h3 id="文本居中"><a href="#文本居中" class="headerlink" title="文本居中"></a>文本居中</h3><p>源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% cq %&#125;</span><br><span class="line">人生乃是一面镜子，</span><br><span class="line">从镜子里认识自己，</span><br><span class="line">我要称之为头等大事，</span><br><span class="line">也只是我们追求的目的！</span><br><span class="line">&#123;% endcq %&#125;</span><br></pre></td></tr></table></figure></p><p>效果：</p><blockquote class="blockquote-center"><p>人生乃是一面镜子，<br>从镜子里认识自己，<br>我要称之为头等大事，<br>也只是我们追求的目的！</p></blockquote><h3 id="主题自带-label-标签"><a href="#主题自带-label-标签" class="headerlink" title="主题自带 label 标签"></a>主题自带 label 标签</h3><p>首先在主题 <code>_config.xml</code> 配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Label tag.</span><br><span class="line">label: true</span><br></pre></td></tr></table></figure></p><p>源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% label primary@primary内容 %&#125;</span><br></pre></td></tr></table></figure></p><p>效果：<br><span class="label primary">primary内容</span></p><h3 id="主题自带-tabs-标签"><a href="#主题自带-tabs-标签" class="headerlink" title="主题自带 tabs 标签"></a>主题自带 tabs 标签</h3><p>主题配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Tabs tag</span><br><span class="line">tabs:</span><br><span class="line">  enable: true</span><br><span class="line">  transition:</span><br><span class="line">    tabs: true</span><br><span class="line">    labels: true</span><br><span class="line">  border_radius: 0</span><br></pre></td></tr></table></figure><p>源码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs 选项卡, 2 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">这是选项卡 1 内容</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">这是选项卡 2 内容</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">这是选项卡 3** 哇，你找到我了！φ(≧ω≦*)♪～</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure></p><p>效果：<br><div class="tabs" id="选项卡"><ul class="nav-tabs"><li class="tab"><a href="#选项卡-1">选项卡 1</a></li><li class="tab active"><a href="#选项卡-2">选项卡 2</a></li><li class="tab"><a href="#选项卡-3">选项卡 3</a></li></ul><div class="tab-content"><div class="tab-pane" id="选项卡-1"><p>这是选项卡 1 内容</p></div><div class="tab-pane active" id="选项卡-2"><p>这是选项卡 2 内容</p></div><div class="tab-pane" id="选项卡-3"><p>这是选项卡 3*<em> 哇，你找到我了！φ(≧ω≦</em>)♪～</p></div></div></div></p><h3 id="主题自带样式按钮"><a href="#主题自带样式按钮" class="headerlink" title="主题自带样式按钮"></a>主题自带样式按钮</h3><p>源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btn https://www.baidu.com, 点击下载百度, download fa-lg fa-fw %&#125;</span><br></pre></td></tr></table></figure></p><p>效果：<br><a class="btn" href="https://www.baidu.com" target="_blank" rel="noopener"><i class="fa fa-download fa-lg fa-fw"></i>点击下载百度</a></p><h2 id="Hexo-其他知识"><a href="#Hexo-其他知识" class="headerlink" title="Hexo 其他知识"></a>Hexo 其他知识</h2><h3 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h3><p>由于一直使用的是「微博图床」，渣浪微博和简书开启了图片防盗链，请大家在博客中加入以下标签来绕过：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"referrer"</span> <span class="attr">content</span>=<span class="string">"never"</span> /&gt;</span> ​​​​</span><br></pre></td></tr></table></figure><p>Next 主题只需要在 <code>themes/next/layout/_partials/head/head.swig</code> 中添加上面一行内容即可。</p><h2 id="Next-主题"><a href="#Next-主题" class="headerlink" title="Next 主题"></a>Next 主题</h2><ul><li><a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/README.md" target="_blank" rel="noopener">theme-next/hexo-theme-next</a></li></ul><h3 id="安装-Next"><a href="#安装-Next" class="headerlink" title="安装 Next"></a>安装 Next</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd MyBlog</span><br><span class="line">$ git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>Next 扩展都安装在<code>themes/next/source/lib</code>文件夹下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd MyBlog</span><br><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><h3 id="启动-Next-主题"><a href="#启动-Next-主题" class="headerlink" title="启动 Next 主题"></a>启动 Next 主题</h3><p>编辑站点配置文件 <code>_config.yml</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next # 启用next主题</span><br></pre></td></tr></table></figure></p><h3 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h3><ul><li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">next-开始使用</a></li></ul><h3 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h3><p>站点配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language: zh-CN # 最新版中，不再使用zh-Hans</span><br></pre></td></tr></table></figure></p><h3 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h3><p>编辑主题配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  #about: /about/ || user</span><br><span class="line">  #tags: /tags/ || tags</span><br><span class="line">  #categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure><p>菜单内容的设置格式是：<code>item name: link || icon</code>。其中 `item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。</p><p>设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 <code>languages/{language}.yml</code> （<code>{language}</code> 为你所使用的语言）。</p><p>icon 使用的是 <a href="https://fontawesome.com/icons" target="_blank" rel="noopener">fontawesome</a> 图标，严格区分大小写。</p><h3 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h3><p>将准备好的头像放置在主题目录下的 <code>source/images/</code> 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  # In theme directory (source/images): /images/avatar.gif</span><br><span class="line">  # In site directory (source/uploads): /uploads/avatar.gif</span><br><span class="line">  # You can also use other linking images.</span><br><span class="line">  url: /images/logo.jpg</span><br></pre></td></tr></table></figure><h3 id="百度统计"><a href="#百度统计" class="headerlink" title="百度统计"></a>百度统计</h3><ol><li>登录<a href="http://tongji.baidu.com/" target="_blank" rel="noopener">百度统计</a>， 定位到站点的<a href="https://tongji.baidu.com/sc-web/18360470/home/site/getjs?siteId=12775404" target="_blank" rel="noopener">代码获取页面</a></li><li>复制 hm.js? 后面那串统计脚本 id，如：</li><li>编辑 主题配置文件， 修改字段 <code>baidu_analytics</code> 字段，值设置成你的百度统计脚本 id</li></ol><h3 id="阅读次数"><a href="#阅读次数" class="headerlink" title="阅读次数"></a>阅读次数</h3><p>使用 <a href="https://leancloud.cn/dashboard/applist.html#/apps" target="_blank" rel="noopener">LeanCloud</a></p><p>参考这个 <a href="https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener">为NexT主题添加文章阅读量统计功能</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true # 启用了 valine，所以这里可以置为 false</span><br><span class="line">  app_id: xxx</span><br><span class="line">  app_key: xxx</span><br></pre></td></tr></table></figure><h3 id="设置-RSS"><a href="#设置-RSS" class="headerlink" title="设置 RSS"></a>设置 RSS</h3><p>主题配置文件中，<code>rss</code> 字段设为空，启用，设为 <code>false</code> 则不启用。启用的话，需要安装插键：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure></p><h3 id="添加标签页面"><a href="#添加标签页面" class="headerlink" title="添加标签页面"></a>添加标签页面</h3><ol><li>新建页面 <code>hexo new page tags</code></li><li>设置页面类型，编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li></ol><p>如果有集成评论服务，页面也会带有评论。 若需要关闭的话，请添加字段 comments 并将值设置为 false，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><ol start="3"><li>修改菜单，在菜单中添加链接。编辑 主题配置文件 ， 添加 tags 到 menu 中</li></ol><p>标签示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 标签测试文章</span><br><span class="line">tags:</span><br><span class="line">  - Testing</span><br><span class="line">  - Another Tag</span><br></pre></td></tr></table></figure></p><p>请参阅 <a href="https://hexo.io/zh-cn/docs/front-matter.html#%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener">Hexo 的分类与标签文档</a>，了解如何为文章添加标签或者分类</p><p>补充：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br></pre></td></tr></table></figure></p><p>分类方法的分歧<br>如果您有过使用WordPress的经验，就很容易误解Hexo的分类方式。WordPress支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是Hexo不支持指定多个同级分类。下面的指定方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">- Life</span><br></pre></td></tr></table></figure></p><p>会使分类Life成为Diary的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。</p><p>并列分类，了解一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Linux]</span><br><span class="line">- [Tools]</span><br></pre></td></tr></table></figure></p><p>并列+子分类，再了解一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Linux, Hexo]</span><br><span class="line">- [Tools, PHP]</span><br></pre></td></tr></table></figure></p><p>同样的方法，添加分类页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure></p><h3 id="设置字体"><a href="#设置字体" class="headerlink" title="设置字体"></a>设置字体</h3><p>设置字体可参考:<a href="https://theme-next.iissnan.com/theme-settings.html#fonts-customization" target="_blank" rel="noopener">官宣-字体</a></p><h3 id="设置代码高亮主题"><a href="#设置代码高亮主题" class="headerlink" title="设置代码高亮主题"></a>设置代码高亮主题</h3><p><a href="https://theme-next.iissnan.com/theme-settings.html#syntax-highlight-scheme" target="_blank" rel="noopener">代码高亮预览</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Code Highlight theme</span><br><span class="line"># Available value: normal | night | night eighties | night blue | night bright</span><br><span class="line"># https://github.com/chriskempson/tomorrow-theme</span><br><span class="line">highlight_theme: night eighties</span><br></pre></td></tr></table></figure><h3 id="侧边栏社交链接"><a href="#侧边栏社交链接" class="headerlink" title="侧边栏社交链接"></a>侧边栏社交链接</h3><p>主题配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/Michael728 || github</span><br><span class="line">  微博: https://weibo.com/1838446070/profile?topnav=1&amp;wvr=6 || weibo</span><br><span class="line">  博客园: https://www.cnblogs.com/michael-xiang/ || globe</span><br><span class="line">  知乎: https://www.zhihu.com/people/michaelXoX || globe</span><br><span class="line">  Twitter: https://twitter.com/728_michael || twitter</span><br><span class="line">  Telegram: https://t.me/michaelxiang || telegram</span><br></pre></td></tr></table></figure></p><p>图标名称 是 Font Awesome 图标的名字（不必带 <code>fa-</code> 前缀）。 enable 选项用于控制是否显示图标，你可以设置成 false 来去掉图标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">social_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  icons_only: false</span><br><span class="line">  transition: false</span><br></pre></td></tr></table></figure><h3 id="开启打赏功能"><a href="#开启打赏功能" class="headerlink" title="开启打赏功能"></a>开启打赏功能</h3><p>只需要 主题配置文件 中填入 微信 和 支付宝 收款二维码图片地址 即可开启该功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">reward_settings:</span><br><span class="line">  # If true, reward would be displayed in every article by default.</span><br><span class="line">  # You can show or hide reward in a specific article throuth `reward: true | false` in Front-matter.</span><br><span class="line">  enable: true</span><br><span class="line">  animation: false</span><br><span class="line">  comment: 我知道是不会有人点的，但万一有人想不开呢👇</span><br><span class="line"></span><br><span class="line">reward:</span><br><span class="line">  wechatpay: /images/wechatpay.jpg</span><br><span class="line">  alipay: /images/alipay.png</span><br></pre></td></tr></table></figure></p><h3 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Blog rolls</span><br><span class="line">links_icon: link</span><br><span class="line">links_title: 关注列表 #Links</span><br><span class="line">links_layout: block</span><br><span class="line">#links_layout: inline</span><br><span class="line">links:</span><br><span class="line">  #Title: http://example.com</span><br><span class="line">  Blog List: https://michael728.github.io/2018/09/16/blog-interesting/</span><br><span class="line">  ZeeCoder: https://zcheng.ren/posts/</span><br><span class="line">  ehlxr: https://ehlxr.me/</span><br><span class="line">  卡瓦邦噶: https://www.kawabangga.com/</span><br><span class="line">  David Dai: https://blog.stdioa.com/</span><br><span class="line">  建站日志: https://michael728.github.io/2016/09/03/blog-logfile/</span><br></pre></td></tr></table></figure><h3 id="站点建立时间"><a href="#站点建立时间" class="headerlink" title="站点建立时间"></a>站点建立时间</h3><p>这个时间将在站点的底部显示，例如 <code>©2013 - 2015</code>。 编辑 主题配置文件，新增字段 since：</p><h3 id="订阅微信公众号"><a href="#订阅微信公众号" class="headerlink" title="订阅微信公众号"></a>订阅微信公众号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Wechat Subscriber</span><br><span class="line">wechat_subscriber:</span><br><span class="line">  enabled: true</span><br><span class="line">  qcode: /uploads/wechat-qcode.jpg</span><br><span class="line">  description: 欢迎您扫一扫上面的微信公众号，订阅我的博客！</span><br></pre></td></tr></table></figure><h3 id="设置动画效果"><a href="#设置动画效果" class="headerlink" title="设置动画效果"></a>设置动画效果</h3><p>主题配置文件设置。比较在乎速度，可以关闭动画。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Use velocity to animate everything.</span><br><span class="line">motion:</span><br><span class="line">  enable: true</span><br><span class="line">  async: false</span><br><span class="line">  transition:</span><br><span class="line">    # Transition variants:</span><br><span class="line">    # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut</span><br><span class="line">    # swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut</span><br><span class="line">    # bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut</span><br><span class="line">    # slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut</span><br><span class="line">    # slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut</span><br><span class="line">    # perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut</span><br><span class="line">    post_block: fadeIn</span><br><span class="line">    post_header: slideDownIn</span><br><span class="line">    post_body: slideDownIn</span><br><span class="line">    coll_header: slideLeftIn</span><br><span class="line">    # Only for Pisces | Gemini.</span><br><span class="line">    sidebar: slideUpIn</span><br></pre></td></tr></table></figure><h3 id="设置背景动画"><a href="#设置背景动画" class="headerlink" title="设置背景动画"></a>设置背景动画</h3><p>编辑 主题配置文件， 搜索 <code>canvas_nest</code> 或 <code>three_waves</code>，根据您的需求设置值为 true 或者 false 即可</p><p>我只启用了 canvas_nest</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">canvas_nest: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1.0.0/canvas-nest.min.js</span><br><span class="line">canvas_nest_nomobile: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest-nomobile.min.js</span><br></pre></td></tr></table></figure><h3 id="搜索–Local-Search"><a href="#搜索–Local-Search" class="headerlink" title="搜索–Local Search"></a>搜索–Local Search</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>站点配置文件，新增如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></p><p>编辑主题配置文件，启用本地搜索：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure></p><h3 id="不蒜子统计"><a href="#不蒜子统计" class="headerlink" title="不蒜子统计"></a>不蒜子统计</h3><p>编辑 主题配置文件 中的 <code>busuanzi_count</code> 的配置项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  # 文章阅读次数，关闭，避免与leanclound_visitors冲突</span><br><span class="line">  post_views: false</span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure></p><h3 id="fancybox"><a href="#fancybox" class="headerlink" title="fancybox"></a>fancybox</h3><div class="note info">            <p>fancyBox is a tool that offers a nice and elegant way to add zooming functionality for images, html content and multi-media on your webpages</p>          </div><ul><li>检查<code>_config.yml</code> 中是否开启了 fancybox</li><li>找到 vendors，把 <code>fancybox</code> 和 <code>fancybox_css</code> 设置成推荐值</li></ul><p>参考：</p><ul><li><a href="https://github.com/theme-next/hexo-theme-next/issues/593" target="_blank" rel="noopener">文章里面的图片点击没有反应，也没有放大效果 [solved]</a></li></ul><h3 id="内容分享"><a href="#内容分享" class="headerlink" title="内容分享"></a>内容分享</h3><p><a href="https://github.com/theme-next/theme-next-needmoreshare2" target="_blank" rel="noopener">theme-next-needmoreshare2</a>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd themes/next</span><br><span class="line">git clone https://github.com/theme-next/theme-next-needmoreshare2 source/lib/needsharebutton</span><br></pre></td></tr></table></figure></p><p>主题配置文件配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">needmoreshare2:</span><br><span class="line">  enable: true</span><br><span class="line">  postbottom:</span><br><span class="line">    enable: true</span><br><span class="line">    options:</span><br><span class="line">      iconStyle: box</span><br><span class="line">      boxForm: horizontal</span><br><span class="line">      position: bottomCenter</span><br><span class="line">      networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span><br><span class="line">  float:</span><br><span class="line">    enable: false</span><br><span class="line">    options:</span><br><span class="line">      iconStyle: box</span><br><span class="line">      boxForm: horizontal</span><br><span class="line">      position: middleRight</span><br><span class="line">      networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span><br></pre></td></tr></table></figure></p><h3 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h3><p>Next 评论配置很简单，支持很丰富。</p><p><code>front matter</code> 中设置 <code>comments: false</code>，当前页就不会显示评论框了。</p><h4 id="Disqus-评论启用，但是得网络畅通才能看到："><a href="#Disqus-评论启用，但是得网络畅通才能看到：" class="headerlink" title="Disqus 评论启用，但是得网络畅通才能看到："></a>Disqus 评论启用，但是得网络畅通才能看到：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">disqus:</span><br><span class="line">  enable: true</span><br><span class="line">  shortname: xxx</span><br><span class="line">  count: true</span><br></pre></td></tr></table></figure><p>编辑 主题配置文件， 将 disqus 下的 enable 设定为 true，同时提供您的 shortname。count 用于指定是否显示评论数量</p><h4 id="Valine"><a href="#Valine" class="headerlink" title="Valine"></a>Valine</h4><p><a href="https://valine.js.org/avatar.html" target="_blank" rel="noopener">Valine</a>这个评论系统也是用到了 <a href="https://leancloud.cn/dashboard/app.html?appid=7CDtrbb4U7nQzOdctmXXnMqt-gzGzoHsz#/general" target="_blank" rel="noopener">leancloud</a></p><ul><li>点击登录或注册Leancloud;</li><li>创建应用(如果已经创建了博客应用，就不用再创建了)</li><li>获取 APP ID 和 APP KEY: 刚刚创建的应用 &gt; 设置 &gt; 应用 KEY</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: false # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version.</span><br><span class="line">  appid:  xxx # your leancloud application appid</span><br><span class="line">  appkey:  xxx # your leancloud application appkey</span><br><span class="line">  notify: true # mail notifier , https://github.com/xCss/Valine/wiki https://valine.js.org/notify.html</span><br><span class="line">  verify: true # Verification code</span><br><span class="line">  placeholder: ヾﾉ≧∀≦)o来啊，快活啊!  # comment box placeholder</span><br><span class="line">  avatar: identicon # wavatar retro gravatar style https://github.com/xCss/Valine/wiki/avatar-setting-for-valine</span><br><span class="line">  guest_info: nick,mail,link # custom comment header</span><br><span class="line">  pageSize: 10 # pagination size</span><br><span class="line">  visitor: true # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&apos; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html</span><br></pre></td></tr></table></figure><ul><li>visitor 文章访问量统计。</li><li>recordIP，默认是 fasle，是否记录评论者IP</li><li><a href="https://valine.js.org/configuration.html" target="_blank" rel="noopener">valine 配置项查看</a></li></ul><p>头像设置，可以用你对应的邮箱设置 <a href="http://cn.gravatar.com/" target="_blank" rel="noopener">Gravatar</a>，这样你评论时，就是注册时使用的邮箱了。</p><p>邮件提醒，进入Leancloud&gt;选择你的评论所存放的应用&gt;设置&gt;邮件模板，按下图设置好用于重置密码的邮件主题&gt;然后保存:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Hi, &#123;&#123;username&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">你在 &#123;&#123;appname&#125;&#125; 的评论收到了新的回复，请点击查看：</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;a href=&quot;https://michael728.github.io/&quot; style=&quot;display: inline-block; padding: 10px 20px; border-radius: 4px; background-color: #3090e4; color: #fff; text-decoration: none;&quot;&gt;马上查看&lt;/a&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>参考：</p><ul><li><a href="https://github.com/zhaojun1998/Valine-Admin" target="_blank" rel="noopener">valine-admin</a></li><li><a href="https://io-oi.me/technology/computer/computer-aided-art/2018/07/15/use-valine-in-theme-next.html" target="_blank" rel="noopener">在 NexT 中使用 Valine 评论系统</a></li></ul><h3 id="hexo-next-新增阅读排行页面"><a href="#hexo-next-新增阅读排行页面" class="headerlink" title="hexo next 新增阅读排行页面"></a>hexo next 新增阅读排行页面</h3><p>参考这两个教程：</p><ul><li><a href="https://hoxis.github.io/hexo-next-read-rank.html" target="_blank" rel="noopener">hexo next 新增阅读排行页面</a></li><li><a href="https://io-oi.me/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化</a></li><li><a href="https://io-oi.me/technology/computer/computer-aided-art/2018/07/15/use-valine-in-theme-next.html" target="_blank" rel="noopener">在 NexT 中使用 Valine 评论系统</a></li></ul><h3 id="在Hexo博客中加入豆瓣读书页面"><a href="#在Hexo博客中加入豆瓣读书页面" class="headerlink" title="在Hexo博客中加入豆瓣读书页面"></a>在Hexo博客中加入豆瓣读书页面</h3><p><a href="https://github.com/mythsman/hexo-douban" target="_blank" rel="noopener">hexo-douban</a> 可以实现生成豆瓣读书、电影、游戏的页面。具体的使用方法可以看项目的主页或者这篇文章</p><ul><li><a href="https://bestzuo.cn/posts/hexo-douban.html" target="_blank" rel="noopener">在Hexo博客中加入豆瓣读书页面</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo douban -bm &amp;&amp; hexo g &amp;&amp;hexo deploy</span><br></pre></td></tr></table></figure><h3 id="看板娘"><a href="#看板娘" class="headerlink" title="看板娘"></a>看板娘</h3><ul><li><a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">EYHN/hexo-helper-live2d</a> Hexo 博客照着配置就行</li><li><a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">live2d-看板娘预览</a></li><li><a href="https://11.tt/posts/2018/how-to-play-with-live2d-on-hexo/" target="_blank" rel="noopener">用Live2D让看板喵入住你的Hexo博客吧(^o^)/~</a></li><li><a href="https://imjad.cn/archives/lab/add-dynamic-poster-girl-with-live2d-to-your-blog-01" target="_blank" rel="noopener">给博客添加能动的看板娘(Live2D)-关于模型的二三事</a> Hexo 博客看板娘配置进阶</li><li><a href="https://www.cnblogs.com/barryzhang/p/10535960.html" target="_blank" rel="noopener">博客园添加Live2d看板娘</a> 博客园增加看板娘</li></ul><h3 id="SEO-优化"><a href="#SEO-优化" class="headerlink" title="SEO 优化"></a>SEO 优化</h3><ul><li><a href="https://hoxis.github.io/Hexo+Next%20SEO%E4%BC%98%E5%8C%96.html" target="_blank" rel="noopener">Hexo博客Next主题SEO优化方法</a></li><li><a href="https://yfzhou.coding.me/2018/08/29/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88SEO%E4%BC%98%E5%8C%96%EF%BC%89/" target="_blank" rel="noopener">Hexo-Next搭建个人博客（SEO优化）</a></li><li><a href="https://mtianyan.gitee.io/post/a625fa82.html" target="_blank" rel="noopener">Hexo+Next主题搭建博客安装美化及SEO优化指南</a></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>博客建完的地址：<a href="https://michael728.github.io/">https://michael728.github.io/</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://chentging.github.io/2018/05/14/hexo%EF%BC%9A%EF%BC%88%E4%B8%89%EF%BC%89hexo-Next-%E4%B8%BB%E9%A2%98%E4%B8%8B%E8%BD%BD%E5%92%8C%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">hexo：（三）hexo Next 主题下载和配置</a></li><li><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化</a></li><li><a href="https://blog.runningcoder.me/2018/04/26/create-personal-blog-with-github-and-hexo-V/" target="_blank" rel="noopener">手摸手教你用github和hexo搭建个人博客（五）</a></li><li><a href="https://segmentfault.com/a/1190000009544924#articleHeader23" target="_blank" rel="noopener">hexo的next主题个性化配置教程</a></li><li><a href="https://iuok.me/posts/2911810154/" target="_blank" rel="noopener">NexT 主题的扩展以及设置</a></li><li><a href="https://bestzuo.cn/posts/blog-establish.html" target="_blank" rel="noopener">Sanarous-使用Hexo+Next主题搭建自己的个人博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;本文总结一下 Hexo 搭建博客的主要流程，能够在日后快速恢复博客环境。&lt;/p&gt;
&lt;p&gt;Hexo 的官方文档写的已经很全面了，本文仅将一些注
      
    
    </summary>
    
    
      <category term="Blog" scheme="https://michael728.github.io/tags/Blog/"/>
    
      <category term="Hexo" scheme="https://michael728.github.io/tags/Hexo/"/>
    
      <category term="Note" scheme="https://michael728.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>【转】程序员的核心能力</title>
    <link href="https://michael728.github.io/2019/05/11/think-core-skill-programmer/"/>
    <id>https://michael728.github.io/2019/05/11/think-core-skill-programmer/</id>
    <published>2019-05-11T09:23:10.000Z</published>
    <updated>2019-06-01T16:00:30.260Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="http://vitrun.github.io/computer/2017/11/26/core-skill-programmer.html" target="_blank" rel="noopener">程序员的核心能力</a></p><p>阅读博客时发现的这篇文章，觉得说的挺有道理，转载一下。自己近期也感觉到了一些焦虑感，觉得太多东西要学了，各个技术公众号、论坛，传递出来的这些东西，都让人感觉焦虑！一直在大容量的「被灌输」，自己的主动思考却少之又少，这必然不是成长的长久之道！</p></blockquote><p>程序员要掌握的知识，要具备的能力实在太多，多得头发都不够掉。</p><p>大体有两大方向。一是对工具的熟练掌握，如操作系统、网络、IO、编程语言等；另一个是用代码为现实问题生成解决方案的能力，这其中最重要的是抽象能力。</p><p>前一个方向是很容易意识到的，很多现象可以说明这一点，比如，世面上介绍如何使用语言、框架的书汗牛充栋；比如，很多人眼里进这一行的门槛是上1个月的语言培训课。</p><p>工具的意义不容否认，为此我还写过一篇《工具优先》。但工具的生命周期其实很短，从个人发展角度看，把过多时间投入到半衰期很短的事物上，并不划算。我入门时接触的是Pascal, BasicScript, ASP, IIS，不知道现在还有没有人用这些。很多程序员也赶时髦，本来写java的，golang流行了，python流行了，学！本来搞业务开发的，大数据火了，机器学习火了，学！打的旗号自然很鲜明：持续学习。几次之后，却怅然若失，貌似没一个是拿得出手的，不过是低水平重复，换个工具，继续做原来的事而已。充其量效率提高了，但效率型工作是可替代性最强的，被其它人替代，被机器替代。</p><p>一颗上进爱学习的心，怎么就被辜负了呢？因为核心能力没有提升。人的能力好比电子围绕原子核旋转，大部分情况下处于巡航状态，在这过程中不断积蓄能量，始终向核心方向用力，就会跃迁到更高级轨道（这里指更靠近核心的轨道，实际电子是更远离核心的道）。“一万小时理论”和“10万行代码理论”只片面强调了量，如果没有聚焦核心，刻意练习，只能是低水平重复，甚至轨道降级。</p><p>核心是抽象能力。这个世界的运行，有讲逻辑的，也有不讲逻辑的。程序员要处理的事是讲逻辑的那部分，因为你所依赖的计算机是讲逻辑的，要让它意气用事，感情用情，目前还很困难。通过抽象，我们识别并保留逻辑部分，抛弃其它内容，然后用计算机语言翻译、实现这个逻辑，进而解决问题。</p><p>抽象这个词，本身就挺抽象的。到底什么是抽象？</p><p>抽象是去除多余和细节。比如下面这个标志，一看就懂是座拱桥，但并没有显示拱桥的幅度、宽度和长度，因为这些数据对于你意识到这是一座拱桥并没有帮助。</p><p>什么是多余信息，取决于目的。考虑地铁换乘图，其目的是告诉乘客该搭哪条线，在哪里换乘，所以保留了结构关系：站点的分布，以及线路的汇合点，但忽略了物理关系：站点的地理位置、相对距离，甚至扭曲了线路的方向。而如果是开车用的导航图，则必须保证比例尺和实际情况一致，方向也不能有差错，以免误导。</p><p>抽象是建立模板或蓝图。不少公司里有邮件模板、文档模板、PPT模板、报销单模板，等等，它们规定好了结构、风格，并留出一个个空白，使用的时候填空就好。模板描述不变的内容，变量则延迟到使用场景中确定。Java编程时，经常要应用各种设计模式，其实质是通过抽象，固化不变的，封装变化的。比如，很常用的模板方法，流程和步骤无论什么场景都不变，已经在父类写好了，将具体场景的方法在父类里声明，但延迟到子类实现，封装的是方法实现。又比如，创建对象时，不常写new Tesla()，而是运用简单工厂模式，写成TeslaFactory.create()，因为对象的创建是易变的。与其在特斯拉多一个型号时，把所有new的地方都改一遍，不如在create方法里集中改。</p><p>总之，抽象是应对变化，或者说寻找不变性的手段。既可以是不同事物之间的不变性，也可以是同一事物不同历史时间的不变性。虽然这里讲的是编程，但其应用远不止于此，看看贝索斯是怎么说的：</p><p>我常被问一个问题：“在接下来的10年里，会有什么样的变化?”……但我很少被问到“在接下来的10年里，什么是不变的?”我认为第二个问题比第一个问题更加重要，因为你需要将你的战略建立在不变的事物上。</p><p>有了上面的解释，便不难理解面向对象编程的原则：依赖接口而不是实现，依赖抽象类而不是具体类。它让代码的适应性更强，将来少改代码，少出错。同时，做一些参数设定时，更加有理有据，而不是trial and error。线程池大小怎么定？不用关心具体工作，分析阻塞和非阻塞的时间比例，应用Amdahl’s law搞定。队列大小怎么定？不管究竟放的是什么，确定你期望的排队时长，用Little’s law算下。</p><p>世面上鲜有讲如何培养抽象思维的书，设计模式一类的，算搭一点边，但那是人家抽象的结果，而不是关于抽象的方法。也许我们在运用这些模式，或浏览一些工具和类库的代码过程中，偶有灵光一现，能从这些结果中反推作者的设计思想和精妙之处，毕竟它们也是抽象的结果。</p><p>学习使用工具时，如果多个心眼，留意为什么有这个工具，做了什么取舍，工具于你将不仅是效率意义。做业务开发时，如果不是简单地翻译需求，多想一层，哪里易变，哪里不易变，如何隔离变化，再简单的开发，于你也有精进意义。</p><p>抽象的层级可以有很多，能做多少层级的抽象是一种能力，而判断需要多少层级的抽象则是一种艺术。</p><p>地上一个猴，树上七个猴，一共有几个猴？1+7=8，一共八个猴，用数字符号代替猴子，这是第一层。从对象到数字，大多数人对此熟悉到甚至没有意识到这是一种抽象。再进一层，则有些困难了，当初我理解“加速度”这个概念，就费功。不光是数量，还有结构的抽象，关系的抽象。当然，它们离我们都很远……</p><p>可是，真的很远吗？当大部分人在关心如何写程序时，有人开始研究如何用程序写程序，当大部分人在关心如何看书、学习时，有人在教别人看书、学习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://vitrun.github.io/computer/2017/11/26/core-skill-programmer.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;程序员的核心能
      
    
    </summary>
    
      <category term="思考" scheme="https://michael728.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="思考" scheme="https://michael728.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>PyCharm/IDEA 使用技巧总结</title>
    <link href="https://michael728.github.io/2019/05/11/tools-dev-pycharm-idea/"/>
    <id>https://michael728.github.io/2019/05/11/tools-dev-pycharm-idea/</id>
    <published>2019-05-11T08:46:02.000Z</published>
    <updated>2019-06-01T15:59:02.528Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>工欲善其事必先利其器</p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>IDEA 没有类似 Eclipse 的工作空间的概念（workspace），最大单元就是 Project。这里可以把 Project 理解为 Eclipse 中的 workspace。Module 可以理解为 Eclipse 中的 project。一个 工程（Project） 下可以创建多个 模块（Moudle）。</p><ul><li>src 目录，用于存放代码</li><li>.idea 目录和 project01.iml 文件都是 IDEA 工程特有的。</li><li>删除 module ，这样不会删除代码文件，只是从 Project 中移除组织关系，如下图：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fyre627b5lj308u0c1t9g.jpg" alt><br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fyre7mxrxaj30au03yt8y.jpg" alt><h2 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h2></li></ul><h3 id="设置Tab为4个空格"><a href="#设置Tab为4个空格" class="headerlink" title="设置Tab为4个空格"></a>设置Tab为4个空格</h3><p>不要勾选<code>Use Tab character</code></p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fya4vpukusj30i60770tr.jpg" alt></p><h3 id="设置显示收藏栏等工具栏"><a href="#设置显示收藏栏等工具栏" class="headerlink" title="设置显示收藏栏等工具栏"></a>设置显示收藏栏等工具栏</h3><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fya4wuju8aj30b30bvafx.jpg" alt></p><h3 id="支持滚轮调节字体大小"><a href="#支持滚轮调节字体大小" class="headerlink" title="支持滚轮调节字体大小"></a>支持滚轮调节字体大小</h3><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fya4yfgfdgj30lo06qwfc.jpg" alt></p><h3 id="鼠标滑过，显示文档"><a href="#鼠标滑过，显示文档" class="headerlink" title="鼠标滑过，显示文档"></a>鼠标滑过，显示文档</h3><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fya4zlx0o2j30m70cxgnj.jpg" alt></p><h3 id="设置换行符默认为LF"><a href="#设置换行符默认为LF" class="headerlink" title="设置换行符默认为LF"></a>设置换行符默认为LF</h3><p><code>Editor-&gt;Code Style</code> 页面不仅能设置换行符，还可以设置 <code>wrap columns</code>。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fya51ozedij30kb07r758.jpg" alt></p><p>参考：</p><ul><li><a href="https://blog.csdn.net/ECHO_FOLLOW_HEART/article/details/48314523" target="_blank" rel="noopener">IntelliJ换行CRLF, LF, CR的解释和默认设置</a></li></ul><h3 id="设置-File-Encodings"><a href="#设置-File-Encodings" class="headerlink" title="设置 File Encodings"></a>设置 <code>File Encodings</code></h3><p><code>Settings-&gt;Editor-&gt;File Encodings</code>，编码全都设为 <code>UTF-8</code>。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fyp5wfd5qaj31bu0u0q99.jpg" alt></p><h3 id="设置显示空格"><a href="#设置显示空格" class="headerlink" title="设置显示空格"></a>设置显示空格</h3><p>「游标卡尺」的名号不是白叫的，所以，必须设置显示空格、缩进等，可以在 <code>Settings-&gt;Editor-&gt;General-&gt;Apperance</code>中设置显示空格、行号、CSS颜色、方法分隔符等效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+alt+s #输入whitespace，搜索相关设置，打开</span><br></pre></td></tr></table></figure><ul><li><a href="http://brucedone.com/archives/38" target="_blank" rel="noopener">舒服的pycharm设置</a></li></ul><h3 id="设置头信息"><a href="#设置头信息" class="headerlink" title="设置头信息"></a>设置头信息</h3><p><code>Settings-&gt;Editor-&gt;File and Code Templates-Files-&gt;Includes-&gt;File Header</code> 设置如下模板：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fyp5ugs59dj31b90u00yp.jpg" alt></p><p>Python 头信息设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Time    : $&#123;DATE&#125; $&#123;TIME&#125;</span><br><span class="line"># @Author  : Michael</span><br><span class="line"># @File    : $&#123;NAME&#125;.py</span><br><span class="line"># @Software: $&#123;PRODUCT_NAME&#125;</span><br></pre></td></tr></table></figure></p><p>Java 头信息设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description:</span><br><span class="line"> * User: $&#123;USER&#125;</span><br><span class="line"> * Date: $&#123;YEAR&#125;-$&#123;MONTH&#125;-$&#123;DAY&#125;</span><br><span class="line"> * Time: $&#123;TIME&#125;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><ul><li><a href="https://blog.csdn.net/qq_36482772/article/details/67218214" target="_blank" rel="noopener">PyCharm创建.py自动添加文件头注释</a></li><li><a href="https://blog.csdn.net/totally123/article/details/53466011" target="_blank" rel="noopener">IntelliJ IDEA文件头注释模板</a></li></ul><h3 id="自动编译"><a href="#自动编译" class="headerlink" title="自动编译"></a>自动编译</h3><p>有时候我们需要操作 class 文件时，却忘记了对 java 类文件进行编译，从而还是对旧的文件进行了操作。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fyp5zly24yj31jw0howjg.jpg" alt></p><h3 id="打开内存使用状态"><a href="#打开内存使用状态" class="headerlink" title="打开内存使用状态"></a>打开内存使用状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">settings—Appearance &amp; Behavior—Appearance—Show memory indicator</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://jadyer.cn/2016/04/20/idea-config/" target="_blank" rel="noopener">玄玉-idea配置小结</a> 博主介绍的很详细</li></ul><h3 id="import每个类而非整个包"><a href="#import每个类而非整个包" class="headerlink" title="import每个类而非整个包"></a>import每个类而非整个包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">settings—Editor—Colors Style—Java—Imports—Class count to use import with ‘*’ 设置大一点</span><br></pre></td></tr></table></figure><p>当 Java 类中 import 某个包下的类超过这里设置的个数，就会换成用星号来代替，比如 <code>import java.util.*</code></p><h3 id="版本控制下文件变化的显示"><a href="#版本控制下文件变化的显示" class="headerlink" title="版本控制下文件变化的显示"></a>版本控制下文件变化的显示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">settings—Version Control—Show directories with changed descendants</span><br></pre></td></tr></table></figure><p>开启后若想调整文件夹的显示颜色：<code>settings—Version Control—File Status Color</code></p><h3 id="省电模式"><a href="#省电模式" class="headerlink" title="省电模式"></a>省电模式</h3><p>在菜单栏 <code>File</code> 下面有一个选项是 <code>Power Save Mode</code>，这个叫「省电模式」，如果不小心勾选了这个选项，那么会关掉代码检查和代码提示等功能，所以需要注意。</p><h3 id="给提示时忽略大小写"><a href="#给提示时忽略大小写" class="headerlink" title="给提示时忽略大小写"></a>给提示时忽略大小写</h3><p>Java 是严格区分大小写的，未设置时，输入    <code>str</code> 时，它不会提示 <code>String</code>，要想实现忽略大小写的情况它也能智能提示，可以进行如下设置，而且，这样设置它也不是完全按照首字母进行匹配了，比如你输入 <code>hmap</code> 时，也会看到 <code>HashMap</code> 的智能提示，相当方便：</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fyp5kvvqloj30x00he77n.jpg" alt></p><h3 id="自定义-Terminal"><a href="#自定义-Terminal" class="headerlink" title="自定义 Terminal"></a>自定义 Terminal</h3><p><code>settings-&gt;Tools-&gt;Terminal</code></p><p><code>Shell path</code> 原来的值是:</p><ul><li><code>C:\Windows\System32\cmd.exe</code> Windows</li></ul><p>修改为：</p><ul><li><code>C:\Program Files\Git\bin\bash.exe</code> 修改为 <code>Git bash</code> 的终端；</li><li><code>&quot;C:\Windows\System32\cmd.exe&quot; /k &quot;&quot;%CMDER_ROOT%\vendor\init.bat&quot;&quot;</code> 修改为 <code>Cmder</code> 的终端，这种方式就会弹出 Cmder 的窗口，需要配置系统变量 <code>CMDER_ROOT</code>，值为：<code>D:\Green-SF\cmder</code>。</li></ul><p>参考：</p><ul><li><a href="https://www.jetbrains.com/help/pycharm/settings-tools-terminal.html" target="_blank" rel="noopener">Pycharm官宣-Terminal</a></li><li><a href="https://github.com/cmderdev/cmder/issues/282" target="_blank" rel="noopener">Github-Run cmder inside IntelliJ idea</a></li><li><a href="https://blog.qxzzf.com/363" target="_blank" rel="noopener">Windows 上切换 Jetbrains IDE 的 terminal 为 PowerShell 或 cmder</a></li></ul><h3 id="脚本运行结束后留在命令行"><a href="#脚本运行结束后留在命令行" class="headerlink" title="脚本运行结束后留在命令行"></a>脚本运行结束后留在命令行</h3><p>这样脚本运行中的变量在脚本结束后还可以调用，调试时还是挺好用</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fya556wvjbj310c0fkdj8.jpg" alt></p><ul><li><a href="https://segmentfault.com/a/1190000010783422" target="_blank" rel="noopener">pycharm常用设置和技巧</a></li></ul><h3 id="设置Tab标签页"><a href="#设置Tab标签页" class="headerlink" title="设置Tab标签页"></a>设置Tab标签页</h3><p><code>File-&gt;Editor-&gt;General-&gt;EditorTable-&gt;Tab closing Policy-&gt;Tab limit</code></p><p>在 <code>Windows-&gt;Editor Tabs</code> 可以设置标签页的相关内容，比如：</p><ul><li><code>Tabs Placement</code> 放置位置，我勾选了 <code>Right</code>、<code>Show tab in single row</code></li><li>勾选了 <code>Sort Tabs By Filename</code></li><li>勾选了 <code>Open New Tabs At The End</code></li></ul><p>我设置最多打开标签页10个，同时将位置移到了右边，通过<code>alt+←/→</code>可以切换工作区。默认是10，即最多打开十个窗口，再打开新的就会把之前的窗口T掉！</p><ul><li><a href="https://blog.csdn.net/SJZYLC/article/details/49078261" target="_blank" rel="noopener">IntelliJ IDEA设置打开窗口的数量</a></li></ul><h3 id="自动导包-import-popup"><a href="#自动导包-import-popup" class="headerlink" title="自动导包 import popup"></a>自动导包 <code>import popup</code></h3><p><code>Editor-&gt;General-&gt;Auto Import-&gt;Python-&gt;Show import popup</code><br><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fyp5c8o6m4j316u0oeq6x.jpg" alt></p><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><ul><li><a href="http://riaway.com/" target="_blank" rel="noopener">IDEA主题-</a></li><li><a href="https://draculatheme.com/" target="_blank" rel="noopener">Dracula</a></li></ul><h3 id="关联数据库"><a href="#关联数据库" class="headerlink" title="关联数据库"></a>关联数据库</h3><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fypyoon4bfj30bu0a0tac.jpg" alt></p><h3 id="生成-JavaDOC"><a href="#生成-JavaDOC" class="headerlink" title="生成 JavaDOC"></a>生成 JavaDOC</h3><p>Javadoc用于描述类或者方法的作用，具体介绍，可查看<a href="https://blog.csdn.net/vbirdbest/article/details/80296136" target="_blank" rel="noopener">CSDN-Javadoc 使用详解</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fyq6zthfcpj309q0b9q71.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Locale：输入语言类型：zh_CN</span><br><span class="line">Other command line arguments：-encoding UTF-8 -charset UTF-8</span><br></pre></td></tr></table></figure><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fyq729i5jnj30i70fmdhs.jpg" alt></p><h3 id="缓存和索引的清理"><a href="#缓存和索引的清理" class="headerlink" title="缓存和索引的清理"></a>缓存和索引的清理</h3><p>IDEA 首次加载项目时，都会创建索引。创建索引的过程，暂时不要去编辑代码，避免遇到未知问题。有时候意外断电或蓝屏，出现索引损坏情况，可以清除缓存和索引，还原成默认状态。</p><p>File-Invalidate Caches</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fyq7f37wkyj30bz0b97aw.jpg" alt></p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fyq7sdy4chj30gk04g0td.jpg" alt></p><p>这个会将本地修改历史也会清理掉，如果想要将这个数据保留，LocalHistory 需要提前备份：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># system  目录，系统文件目录，是 IDEA 与开发项目一个桥梁目录，里边主要有缓存、索引、容器文件输出等等</span><br><span class="line">/Users/michael/Library/Caches/IntelliJIdea2018.2/LocalHistory</span><br><span class="line"># 顺带看一下 config 目录，是 IDEA 个性化设置目录，是整个 IDE 设置目录</span><br><span class="line">/Users/michael/Library/Preferences/IntelliJIdea2018.2</span><br></pre></td></tr></table></figure></p><p>参考：</p><ul><li><a href="https://stackoverflow.com/questions/23115091/where-is-intellij-idea-config-stored-in-osx/23141889" target="_blank" rel="noopener">Where is IntelliJ IDEA config stored in OSX?</a></li><li><a href="https://intellij-support.jetbrains.com/hc/en-us/articles/206544519-Directories-used-by-the-IDE-to-store-settings-caches-plugins-and-logs" target="_blank" rel="noopener">官宣-Directories used by the IDE to store settings, caches, plugins and logs</a></li></ul><h3 id="取消更新"><a href="#取消更新" class="headerlink" title="取消更新"></a>取消更新</h3><p>取消 IDEA 自动更新，避免引入不稳定的问题：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fyq7wbba92j30nr07s3zi.jpg" alt></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>Mac 的 <code>Command</code> 键一般是对应了 Win 的 <code>Ctrl</code> 键，在 Win 上，还可以用 <code>Alt+&lt;n&gt;</code> 打开相关窗口，在 Mac 上同样要使用 <code>Command+&lt;n&gt;</code>。</p><p>除此以外，还可以在 <code>Settings-Keymap</code> 中，设置快捷键、输入快捷键查看对应的功能；</p><h3 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h3><ul><li><code>alt+r</code>：打开最近项目</li><li><p><code>ctrl+shift+o</code>：打开项目</p></li><li><p>自动补全快捷键，默认是 <code>ctrl+空格</code>，这个和一些中文输入法的切换快捷键冲突了，于是，我多设置了一个 <code>ctrl+/</code> ：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fyp6mdh7h6j31jm0mgwit.jpg" alt></p></li></ul><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>系统内置的：<code>postfix completion</code><br>自定义：<code>live templete</code></p><ul><li><code>psvm</code> 再按 Tab 生成 main 方法，或者，输入 main 之后，再按 <code>ctrl+j</code></li><li><code>sout</code> 输出函数<ul><li><code>soutp</code> 打印函数的形参</li><li><code>soutv</code> 打印变量值</li><li><code>xxx.out</code> 打印变量 xxx 的值</li></ul></li><li><code>fori</code> 循环<ul><li><code>iter</code> 增强 for 循环（for each）</li></ul></li><li><code>list.for</code><ul><li><code>list.fori</code></li><li><code>list.forr</code> 逆序遍历<ul><li><code>ifn</code> 条件判断</li></ul></li><li><code>inn</code> 不等于 <code>null</code><ul><li><code>prsf</code> 私有的静态的常量</li></ul></li></ul></li></ul><p>快捷键 <code>ctrl+j</code> 可以查看有哪些缩写字符。</p><p>更多关于模板的知识，点击<a href="https://www.jetbrains.com/help/idea/using-live-templates.html" target="_blank" rel="noopener">官宣-live templates</a></p><p>参考：</p><ul><li><a href="https://blog.csdn.net/tiantiandjava/article/details/42269173" target="_blank" rel="noopener">IntelliJ 创建main函数快捷</a></li></ul><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><p>查看继承关系<br>重构 修改变量名和方法名<br>大小写切换，常量通常定义为都是大写<br>构造器</p><ul><li><code>alt+↑/↓</code>: 快速在方法间跳转 ★★</li><li><code>alt+p</code>：打开Python控制台 ★★★</li><li><code>alt+enter</code>万能键，不同场景有不同的表现方式，在还没import(install)模块名上使用会import(install)相对应的模块，在方法名上使用补注释，在测试中使用帮你补充断言代码……不管出错了不知道怎么办，知道怎么办想这么办时都按下这个快捷键，有惊喜，万能纠错键 ★★★</li><li><code>alt+f12</code> 打开命令行终端(view-&gt;tool window)★★★；</li><li><code>ctrl+home</code>、<code>ctrl+end</code> 回到页首/页尾，关键字<code>Move Caret to Text End</code> 或者 开头 <code>Move Caret to Text Start</code>，<a href="https://segmentfault.com/q/1010000007099956" target="_blank" rel="noopener">参考</a></li><li><code>ctrl+n</code> 构造器、getter、setter 方法 ★★★</li><li>查看接口继承关系：<ul><li><code>ctrl + h</code> 查看 hierarchy,只能查看向上向下继承关系，而不能看实现了哪些接口。查看继承关系，右击，点击 Digram 查看；</li><li><code>ctrl + alt +B</code>  查找接口的实现类</li></ul></li><li><code>ctrl+e</code> 打开最近文件 ★★★</li><li><code>ctrl+y</code> 删除当前行 ★★★</li><li><code>ctrl+w</code> 不断按下这个快捷键，选择代码块范围逐步扩大；★★★</li><li><code>ctrl+alt+←/→</code> 快速跳转光标刚刚所在行 ★★★</li><li><code>ctrl+alt+L</code>，格式化代码</li><li><code>ctrl+space</code> 万能提示键</li><li><code>shift+enter</code>另起一行，光标在行内任意位置都能另起一行，且不破坏当行结构★★★</li><li><code>ctrl+alt+enter</code>向上另起一行 ★★★</li><li><code>ctrl+F4</code>：关闭当前页 ★★</li><li><code>crtl+q</code>查询documentation</li><li><code>ctrl+鼠标点击</code> 查看内置函数啥的</li><li><code>ctrl+D</code> 复制当前行</li><li><code>ctrl+f12</code> File Structure，查看 class method field。</li><li><code>ctrl+Shift+F</code>: 在整个项目中 或 指定目录里 进行全局搜索; ★★★</li><li><code>ctrl+shift+a</code>：Find Action 快捷键，输入关键词，不会的就问它，超级赞的快捷键 ★★★</li><li><code>ctrl+shift+u</code>：大小写转换，在 <code>Edit-&gt;Toggle Case</code> 中能看到选项</li><li><code>ctrl+shift+v</code>：从最近的缓冲区粘贴</li><li><code>ctrl+shift+backspace</code> 快速跳转到最后修改的地方★★★</li><li><code>ctrl + shift + v</code> 在 Pycharm 中，访问历史粘贴板 ★★</li><li><code>ctrl+shift+ +/-</code> ：代码块折叠★</li><li><code>ctrl+alt+shit+j</code>：多目标选择选择的词，或者用<code>alt+鼠标点击</code>也可以实现效果，<code>Select All occurrences</code>★★</li><li>双击<code>shift</code>搜索一切，不管是IDE功能、文件、方法、变量，它都能搜索，使用频率很高的一个快捷键,！可以按最近使用过的文件名, 类名, 方法名等去搜索定位! 注意，这个搜索不支持搜索关键字的内容。★★★</li><li><code>shift+F6</code>：文件重命名★★</li><li><code>shift+F2</code>：跳转到上一个高亮错误 或 警告位置</li><li>搜索<ul><li><code>Ctrl＋N</code>：快速搜索类</li><li><code>Ctrl＋Shift＋N</code>：快速搜索文件</li><li><code>Ctrl＋Alt+Shift＋N</code>：快速搜索函数</li></ul></li></ul><p>参考：</p><ul><li><a href="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/keymap-introduce.html" target="_blank" rel="noopener">极客学院-IntelliJ IDEA 使用教程-快捷键</a></li></ul><h3 id="alt-enter-快捷键的妙用"><a href="#alt-enter-快捷键的妙用" class="headerlink" title="alt+enter  快捷键的妙用"></a>alt+enter  快捷键的妙用</h3><p>创建对象时，可以先 <code>new</code> 后<code>alter+enter</code>，IDEA 会自动补全，直接让你输入对象名：</p><p><img src="https://ws1.sinaimg.cn/large/6d9475f6ly1fyq399jc4eg20lm06xdy8.gif" alt></p><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><ul><li><p><code>Shift+F6</code>  重命名<br>所有的文件，类名，函数名，属性名都可以重命名，值得点赞的是，只要你使用 <code>Shift+F6</code> 重命名，所有使用过这个名称的地方都会跟着改变；</p></li><li><p>函数的重构，<code>Ctrl+F6</code> 重构函数<br>当你需要重构方法时，无论是增加参数，修改返回值，还是更改函数实现，只需要Ctrl+F6，就可以把所有用到此函数的地方一起重构</p></li></ul><p>参考：</p><ul><li><a href="http://www.cnblogs.com/clwydjgs/p/9390488.html#!comments" target="_blank" rel="noopener">你们都在用IntelliJ IDEA吗？或许你们需要看一下这篇博文</a><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2></li></ul><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fyq1fwyvdij30ek0bfdlz.jpg" alt></p><h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fyq27kq7glj30hs0950th.jpg" alt></p><ol><li><code>step over</code> F8 下一步，当前断点如果是一个方法，不会进入方法体内；</li><li><code>step into</code> F7 下一步，当前断点如果是一个方法，则进入方法体内；</li><li><code>force step into</code> Alt+Shift+F7 下一步，当前行如果是一个方法，强制进入方法体内；</li><li><code>step out</code> Shift+F8 跳出</li><li><code>run to curser</code> Alt+F9 运行到鼠标所在行，临时设置断点，有用</li><li><code>resume program</code> F9 恢复程序运行，运行到下一个断点处，是不是有点像 pdb 中的 c 快捷键；</li><li><code>stop</code> Command+F2 停止</li><li><code>view breakpoints</code> 查看所有断点，可以在运行时选择哪些断点暂停略过；</li><li><code>mute breakpoints</code> 所有断点失效/生效的切换；</li></ol><h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><p>在循环里增加条件判断，具体操作：在断点处右击，在某个条件下，实施断点。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fyq3mbopc0j30g206jaar.jpg" alt></p><p>查看表达式的值（可以查看已有变量的值）：</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fyq3sydbgpj30j10dj76c.jpg" alt></p><h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><p><code>ctrl+alt+h</code> 快捷键</p><p>参考：</p><ul><li><a href="https://www.cnblogs.com/ghj1976/p/5382455.html" target="_blank" rel="noopener">IDEA的查询引用、调用关系图的功能</a></li><li><a href="https://my.oschina.net/Mkeeper/blog/1837432" target="_blank" rel="noopener">Intellij IDEA神器常用技巧八-2018版本新增快捷键</a></li><li><a href="http://qinghua.github.io/intellij-idea-debug/" target="_blank" rel="noopener">挖掘IntelliJ IDEA的调试功能</a></li></ul><h3 id="查看类的继承关系"><a href="#查看类的继承关系" class="headerlink" title="查看类的继承关系"></a>查看类的继承关系</h3><ul><li><a href="https://blog.csdn.net/Jae_Wang/article/details/80058541" target="_blank" rel="noopener">IDEA查看接口或类的继承实现关系图</a></li><li><a href="https://blog.csdn.net/qq_27093465/article/details/52857307" target="_blank" rel="noopener">IntelliJ IDEA 中如何查看一个类的所有继承关系(当前类的所有继承关系图)</a></li></ul><h2 id="高效定位代码-无处不在的跳转"><a href="#高效定位代码-无处不在的跳转" class="headerlink" title="高效定位代码-无处不在的跳转"></a>高效定位代码-无处不在的跳转</h2><h3 id="project之间跳转"><a href="#project之间跳转" class="headerlink" title="project之间跳转"></a>project之间跳转</h3><p><code>ctrl+alt+左右方括号</code>：</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fya57dy739j309u07wn05.jpg" alt></p><h3 id="查看快捷键"><a href="#查看快捷键" class="headerlink" title="查看快捷键"></a>查看快捷键</h3><p><code>ctrl+shift+a</code>：搜搜快捷键</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fya59cv3pwj30bu05iq5q.jpg" alt></p><h3 id="查看最近文件"><a href="#查看最近文件" class="headerlink" title="查看最近文件"></a>查看最近文件</h3><p><code>ctrl+e</code><br>可以在<code>ctrl+shift+a</code>：搜索reccent …</p><h3 id="快速跳转到最后修改的地方"><a href="#快速跳转到最后修改的地方" class="headerlink" title="快速跳转到最后修改的地方"></a>快速跳转到最后修改的地方</h3><p><code>ctrl+shift+backspace</code> 快速跳转到最后修改的地方</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fya5ck67t0j309b0d6gry.jpg" alt></p><h3 id="利用书签跳转"><a href="#利用书签跳转" class="headerlink" title="利用书签跳转"></a>利用书签跳转</h3><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fya5e3cuvmj30ik07i3yz.jpg" alt></p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fya5f37d10j305u07vgls.jpg" alt></p><ul><li><code>F11</code>：添加、取消书签</li><li><code>ctrl+f11</code>：添加、取消有标记的书签</li><li><code>ctrl+&lt;n&gt;</code>：跳转到有标记的书签处</li></ul><h3 id="添加收藏-Favorites"><a href="#添加收藏-Favorites" class="headerlink" title="添加收藏 Favorites"></a>添加收藏 Favorites</h3><p><code>alt+shift+f</code>：add to favorities</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fya5h1gwvhj30if059wes.jpg" alt></p><h3 id="编辑区和文件区的跳转"><a href="#编辑区和文件区的跳转" class="headerlink" title="编辑区和文件区的跳转"></a>编辑区和文件区的跳转</h3><p><code>alt+1</code>进入文件区<br><code>esc</code>：进入编辑区</p><h2 id="精准搜索"><a href="#精准搜索" class="headerlink" title="精准搜索"></a>精准搜索</h2><h3 id="类搜索"><a href="#类搜索" class="headerlink" title="类搜索"></a>类搜索</h3><p><code>ctrl+n</code>：快速搜索类</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fya5iswva8j309606qad5.jpg" alt></p><h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><p>快速打开指定的文件，方便★★★：<br><code>ctrl+shift+n</code></p><h3 id="函数搜索-symbol"><a href="#函数搜索-symbol" class="headerlink" title="函数搜索-symbol"></a>函数搜索-symbol</h3><p><code>ctrl+shift+alt+n</code></p><h3 id="搜索-Maven-依赖包中的内容"><a href="#搜索-Maven-依赖包中的内容" class="headerlink" title="搜索 Maven 依赖包中的内容"></a>搜索 Maven 依赖包中的内容</h3><p>有时候可能需要在源码分析时想要搜索 Maven 依赖包中的内容，只要如下设置即可扩大搜索范围：</p><p><code>ctrl+shift+f</code> -&gt;<code>scope</code>-&gt;<code>All Places</code></p><p><img src="https://ws1.sinaimg.cn/large/6d9475f6ly1g34o5yp49vj211a0g0wix.jpg" alt></p><h2 id="列操作"><a href="#列操作" class="headerlink" title="列操作"></a>列操作</h2><ul><li>选中单词转大写</li></ul><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fya5neqiudj30a00f0dnp.jpg" alt></p><h3 id="多光标选中"><a href="#多光标选中" class="headerlink" title="多光标选中"></a>多光标选中</h3><ul><li>多光标<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fya5oimhwtj30lj0hq180.jpg" alt></li></ul><p>按住 <code>Alt</code> 键，可以快速实现多光标、块选择。</p><h2 id="界面中的基本功能"><a href="#界面中的基本功能" class="headerlink" title="界面中的基本功能"></a>界面中的基本功能</h2><p>如果没有如老师那样的窗口，可点击<code>view——tool buttons</code>打开</p><h3 id="alt-lt-n-gt-快捷键-★★★"><a href="#alt-lt-n-gt-快捷键-★★★" class="headerlink" title="alt+&lt;n&gt;快捷键 ★★★"></a><code>alt+&lt;n&gt;</code>快捷键 ★★★</h3><p>如下图圈出的数字 n，可以使用<code>alt+&lt;n&gt;</code>的方式快捷使用，替代鼠标操作。</p><p>注意，Mac  使用的是 <code>command+&lt;n&gt;</code>方式；</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fya5prmf14j30gz0fnabn.jpg" alt></p><h4 id="打开收藏-★★★"><a href="#打开收藏-★★★" class="headerlink" title="打开收藏 ★★★"></a>打开收藏 ★★★</h4><p>在一些调试的函数那里打断点，然后<code>alt+7</code>收藏中就会方便的查看；</p><h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a><code>TODO</code></h4><p>在项目中使用<code># TODO</code>，可以在<code>Alt+6</code>中看到哪些待开发的备注</p><h2 id="调试技巧-1"><a href="#调试技巧-1" class="headerlink" title="调试技巧"></a>调试技巧</h2><h3 id="设置程序环境变量"><a href="#设置程序环境变量" class="headerlink" title="设置程序环境变量"></a>设置程序环境变量</h3><p>Run-&gt;Edit Configurations-&gt;Environment-&gt;Environment variables</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fya63mb1dzj30xq0c6whi.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.getenv(&quot;HOME_TEST&quot;);</span><br></pre></td></tr></table></figure><h2 id="必备插件"><a href="#必备插件" class="headerlink" title="必备插件"></a>必备插件</h2><p>官网插键库：<a href="https://plugins.jetbrains.com/" target="_blank" rel="noopener">https://plugins.jetbrains.com/</a></p><p>插键说明：</p><ul><li>Install JetBrains plugin：弹出IntelliJ IDEA 公司自行开发的插件仓库列表，供下载安装。</li><li>Browse repositories：弹出插键仓库中所有插键列表供下载安装。</li><li>Install plugin from disk：浏览本地的插键文件进行安装。</li></ul><p>推荐插键：</p><ul><li>BashSupport</li><li><a href="https://zealdocs.org/" target="_blank" rel="noopener">Dash</a>: <code>ctrl+shift+h</code></li><li><a href="https://plugins.jetbrains.com/plugin/9792-key-promoter-x" target="_blank" rel="noopener">Key Promoter X</a> 快捷键提示</li><li><a href="https://plugins.jetbrains.com/plugin/4509-statistic" target="_blank" rel="noopener">Statistic</a> 代码统计</li><li><a href="https://plugins.jetbrains.com/plugin/1065-checkstyle-idea" target="_blank" rel="noopener">CheckStyle-IDEA</a> 代码样式检查</li><li>Lombok plugin</li><li><a href="https://plugins.jetbrains.com/plugin/3847-findbugs-idea" target="_blank" rel="noopener">FindBugs-IDEA</a> 代码 Bug 检查</li><li>Mongo</li><li><a href="https://plugins.jetbrains.com/plugin/8006-material-theme-ui" target="_blank" rel="noopener">Material Theme</a> 主题插键</li><li>CamelCase 将不是驼峰格式的名称，快速转成驼峰格式，安装好后，选中要修改的名称，按快捷键 <code>shift+alt+u</code>。</li><li>Rainbow Brackets 彩虹括号</li><li><a href="https://www.cnblogs.com/jajian/p/8081658.html" target="_blank" rel="noopener">Alibaba Java Coding Guidelines</a></li><li>Maven Helper：安装之后，直接打开pom文件，即可查看依赖数，还能自动分析是否存在 jar 包冲突，查看<a href="https://blog.csdn.net/sunpeng_sp/article/details/77393348" target="_blank" rel="noopener">idea 中解决maven 包冲突的问题</a></li><li>String Manipulation：字符串转换工具，安装好插件后，选中需要处理的内容后，按快捷键 <code>Alt+m</code>，即可弹出工具功能列表</li><li>AceJump：允许您快速将光标导航到编辑器中可见的任何位置，只需点击<code>ctrl +;</code>，然后输入一个你想要跳转到的字符，之后键入匹配的字符就跳转到你想要挑战的地方了</li><li>activate-power-mode：写代码的时候，就会附加一些狂拽炫酷屌炸天的效果</li></ul><p>参考</p><ul><li><a href="https://www.hollischuang.com/archives/3220" target="_blank" rel="noopener">hollis-IntelliJ IDEA 18 周岁，吐血推进珍藏已久的必装插件</a></li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="Q1-intellj-Idea中给新建的项目导入jar包？"><a href="#Q1-intellj-Idea中给新建的项目导入jar包？" class="headerlink" title="Q1: intellj Idea中给新建的项目导入jar包？"></a>Q1: intellj Idea中给新建的项目导入jar包？</h3><ul><li><a href="https://www.cnblogs.com/zadomn0920/p/6196962.html" target="_blank" rel="noopener">推荐intellij idea Project Structure 讲解</a></li></ul><h3 id="Q2-IDEA如何快速生成Get-Set方法？"><a href="#Q2-IDEA如何快速生成Get-Set方法？" class="headerlink" title="Q2: IDEA如何快速生成Get/Set方法？"></a>Q2: IDEA如何快速生成Get/Set方法？</h3><ul><li><a href="http://blog.csdn.net/qq_34273222/article/details/60577679" target="_blank" rel="noopener">Intellij IDEA 生成Get/Set方法快捷键</a></li></ul><p><code>Alt + Insert</code> 组合，可唤出选择面板</p><h3 id="Q3-找不到提示"><a href="#Q3-找不到提示" class="headerlink" title="Q3: 找不到提示"></a>Q3: 找不到提示</h3><ul><li><a href="https://stackoverflow.com/questions/37282285/intellij-cannot-find-any-declarations" target="_blank" rel="noopener">IntelliJ cannot find any declarations</a></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>近期由于微博图床挂了，所以，截图都看不了了，点击原文链接，可查看图片：</p><ul><li><a href="https://michael728.github.io/2019/05/11/tools-dev-pycharm-idea/">PyCharm/IDEA 使用技巧总结</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/keymap-introduce.html" target="_blank" rel="noopener">IntelliJ IDEA 使用教程</a></li><li><a href="https://www.jianshu.com/p/8b4ee9499a79" target="_blank" rel="noopener">简书-IntelliJ IDEA 教程 技巧篇</a> 作者写了一系列的总结</li><li><a href="https://www.zhihu.com/question/37787004" target="_blank" rel="noopener">你有哪些想要分享的 PyCharm 使用技巧？</a></li><li><a href="http://www.imooc.com/learn/924" target="_blank" rel="noopener">IntelliJ IDEA神器使用技巧</a></li><li><a href="http://tengj.top/2017/02/22/idea1-1/" target="_blank" rel="noopener">Java人员正确使用 IntelliJ IDEA的方式</a></li><li><a href="http://qinghua.github.io/intellij-idea-debug/" target="_blank" rel="noopener">挖掘IntelliJ IDEA的调试功能</a></li><li><a href="http://idea.lanyus.com/" target="_blank" rel="noopener">IDEA 注册-lanyu</a></li><li><a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/keymap-introduce.md" target="_blank" rel="noopener">Github-judasn/IntelliJ-IDEA-Tutorial</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;工欲善其事必先利其器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;IDEA 没有类似 Eclipse
      
    
    </summary>
    
      <category term="ToolsDev" scheme="https://michael728.github.io/categories/ToolsDev/"/>
    
    
      <category term="IDE" scheme="https://michael728.github.io/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>shadowsocks+vps+mac</title>
    <link href="https://michael728.github.io/2019/04/27/tools-ss-vps/"/>
    <id>https://michael728.github.io/2019/04/27/tools-ss-vps/</id>
    <published>2019-04-27T06:21:24.000Z</published>
    <updated>2019-06-01T15:59:31.070Z</updated>
    
    <content type="html"><![CDATA[<p>Vultr 选择的是日本的节点，发现速度比较不错，油管视频 720P 无压力！而且，感觉 Vultr 的界面也很清新，用着很方便。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fyh2t0f4hgj328o0qcdpb.jpg" alt></p><a id="more"></a><p>我自搭梯子，选择的是：<code>Shadowsocks-libev+开启simple-obs插键+BBR加速</code>。</p><p>Vultr 通过我的链接注册充值，你我都可以获得 $10 账户返利，所以，如果有需要，就点击注册吧：</p><ul><li><a href="https://www.vultr.com/?ref=7488919" target="_blank" rel="noopener">Vultr  注册返利链接</a></li></ul><h2 id="VPS"><a href="#VPS" class="headerlink" title="VPS"></a>VPS</h2><p>vultr速度比较：</p><ul><li><a href="https://www.vultr.com/faq/#downloadspeedtests" target="_blank" rel="noopener">vultr-downloadspeedtests</a></li><li><a href="https://www.thevultr.org/" target="_blank" rel="noopener">vultr中文网</a></li></ul><h2 id="一键安装脚本"><a href="#一键安装脚本" class="headerlink" title="一键安装脚本"></a>一键安装脚本</h2><ul><li><a href="https://teddysun.com/486.html" target="_blank" rel="noopener">秋水逸冰 Shadowsocks 一键安装脚本（四合一）</a></li><li><a href="https://teddysun.com/489.html" target="_blank" rel="noopener">秋水逸冰 一键脚本搭建SS/搭建SSR服务并开启BBR加速</a></li><li><a href="https://www.vultrcn.com/6.html" target="_blank" rel="noopener">Vultr中文网-Vultr 一键搭建酸酸 Shad0ws0cks 图文教程（推荐）</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span><br><span class="line">chmod +x shadowsocks-all.sh</span><br><span class="line">./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure><p>Docker方式</p><ul><li><a href="https://docs.docker.com/install/linux/docker-ce/centos/#install-using-the-repository" target="_blank" rel="noopener">docker文档</a></li><li><a href="https://hub.docker.com/search/?isAutomated=0&amp;isOfficial=0&amp;page=1&amp;pullCount=1&amp;q=shadowsocks&amp;starCount=0" target="_blank" rel="noopener">docker-ss-搜索结果</a></li></ul><h2 id="加速配置："><a href="#加速配置：" class="headerlink" title="加速配置："></a>加速配置：</h2><p>我选用的 BBR 加速的方式</p><ul><li>BBR 安装：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh</span><br></pre></td></tr></table></figure><ul><li>锐速安装，参考<a href="https://github.com/91yun/serverspeeder" target="_blank" rel="noopener">锐速破解版linux一键自动安装包</a>：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -N --no-check-certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh &amp;&amp; bash serverspeeder.sh</span><br></pre></td></tr></table></figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ul><li><a href="https://shadowsocks.org/en/download/clients.html" target="_blank" rel="noopener">Shadowsocks各种客户端</a></li></ul><p>Mac 客户端下载</p><ul><li><a href="https://github.com/qinyuhang/ShadowsocksX-NG-R/releases" target="_blank" rel="noopener">ShadowsocksX-NG-R/releases</a></li><li><a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases" target="_blank" rel="noopener">ShadowsocksX-NG/releases</a></li><li><a href="https://github.com/shadowsocks/ShadowsocksX-NG/wiki/SIP003-Plugin" target="_blank" rel="noopener">NG 客户端插键配置</a></li></ul><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g2h75w3g2aj30ff08wq2y.jpg" alt></p><p>插键选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obfs=http;obfs-host=www.bing.com</span><br></pre></td></tr></table></figure><p>Android</p><ul><li><a href="https://github.com/shadowsocks/shadowsocks-android/releases" target="_blank" rel="noopener">shadowsocks/shadowsocks-android</a></li><li><a href="https://github.com/shadowsocks/simple-obfs-android/releases" target="_blank" rel="noopener">插键-shadowsocks/simple-obfs-android</a></li></ul><h2 id="服务端命令"><a href="#服务端命令" class="headerlink" title="服务端命令"></a>服务端命令</h2><p>启动脚本后面的参数含义，从左至右依次为：启动，停止，重启，查看状态。</p><ul><li>Shadowsocks-Python 版：<code>/etc/init.d/shadowsocks-python start | stop | restart | status</code></li><li>ShadowsocksR 版：<code>/etc/init.d/shadowsocks-r start | stop | restart | status</code></li><li>Shadowsocks-Go 版：<code>/etc/init.d/shadowsocks-go start | stop | restart | status</code></li><li>Shadowsocks-libev 版：<code>/etc/init.d/shadowsocks-libev start | stop | restart | status</code></li></ul><p>配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Shadowsocks-Python 版：</span><br><span class="line">/etc/shadowsocks-python/config.json</span><br><span class="line"></span><br><span class="line">ShadowsocksR 版：</span><br><span class="line">/etc/shadowsocks-r/config.json</span><br><span class="line"></span><br><span class="line">Shadowsocks-Go 版：</span><br><span class="line">/etc/shadowsocks-go/config.json</span><br><span class="line"></span><br><span class="line">Shadowsocks-libev 版：</span><br><span class="line">/etc/shadowsocks-libev/config.json</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://congcong0806.github.io/2018/04/20/SS/" target="_blank" rel="noopener">聪聪-SS/SSR 简介</a></li><li><a href="http://vc2tea.com/whats-shadowsocks/" target="_blank" rel="noopener">写给非专业人士看的 Shadowsocks 简介</a></li><li><a href="https://www.liaoyuqin.com/post/tools/ha-bi-da-ti-zi" target="_blank" rel="noopener">VPS+ShadowsocksR 搭建自己的 VPN</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vultr 选择的是日本的节点，发现速度比较不错，油管视频 720P 无压力！而且，感觉 Vultr 的界面也很清新，用着很方便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNbRwly1fyh2t0f4hgj328o0qcdpb.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ToolsDaily" scheme="https://michael728.github.io/categories/ToolsDaily/"/>
    
    
      <category term="ss" scheme="https://michael728.github.io/tags/ss/"/>
    
      <category term="vps" scheme="https://michael728.github.io/tags/vps/"/>
    
  </entry>
  
  <entry>
    <title>Linux lvm 分区知识笔记</title>
    <link href="https://michael728.github.io/2019/04/23/linux-lvm-partion/"/>
    <id>https://michael728.github.io/2019/04/23/linux-lvm-partion/</id>
    <published>2019-04-23T15:09:28.000Z</published>
    <updated>2019-04-30T13:11:59.576Z</updated>
    
    <content type="html"><![CDATA[<p>盘面上可以细分出扇区（Sector）与柱面（Cylinder)两种单位，其中扇区每个为512bytes那么大。</p><p>通常所说的”硬盘分区”就是指修改磁盘分区表，它定义了”第n个磁盘块是从第 x个柱面到第y个柱面”.因此，当系统要读取第n个磁盘块时，就是去读硬盘上第x个柱面到第y个柱面的信息.</p><a id="more"></a><p>整块磁盘的第一个扇区特别重要，因为它记录了整块磁盘的重要信息：</p><ol><li>主引导分区（Master Boot Record, MBR）：可以安装引导加载程序的地方，有446bytes.</li><li>分区表（partition table）：记录整块磁盘分区的状态，有64bytes。</li></ol><h2 id="磁盘分区表（partion-table）"><a href="#磁盘分区表（partion-table）" class="headerlink" title="磁盘分区表（partion table）"></a>磁盘分区表（partion table）</h2><p>在分区表所在的64bytes容量中，总共分为四组记录区。每组记录区记录了该区段的起始与结束的柱面号码。</p><ul><li>其实所谓的分区只是针对那个64bytes的分区表进行设置而已。</li><li>硬盘默认的分区表仅能写入四组分区信息</li><li>四组分区信息我们称为主（Primary）或者扩展（Extended）分区。</li><li>分区最小单位为柱面（cylinder）。</li></ul><p>分区的优点：</p><ol><li>数据安全</li><li>有助于数据读取的速度和性能</li></ol><p>扩展分区的目的是使用额外的扇区记录分区信息，扩展分区本身并不能拿来格式化。由扩展分区切出来的分区，就被称为逻辑分区（logical partition）。逻辑分区的设备名称号码由5号开始。</p><p>主分区、扩展分区和逻辑分区的定义：</p><ul><li>主分区与扩展分区最多可以有4个（磁盘限制）</li><li>扩展分区最多只有1个（操作系统限制）</li><li>逻辑分区是由扩展分区持续切割出来的分区</li><li>能够被格式化后作为数据访问的分区为主分区与逻辑分区，扩展分区无法格式化。</li><li>逻辑分区的个数依操作系统而不同，SATA硬盘则有11个逻辑分区（5号到15号）。</li></ul><p>分区是个很麻烦的东西，因为它是以柱面为单位的“连续”磁盘空间，且扩展分区又是类似独立的磁盘空间。</p><p>扩展分区是不能直接用的，他是以逻辑分区的方式来使用的，所以说扩展分区可分成若干逻辑分区。 他们的关系是包含的关系，所有的逻辑分区都是扩展分区的一部分。</p><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><h3 id="LVM卷管理"><a href="#LVM卷管理" class="headerlink" title="LVM卷管理"></a>LVM卷管理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">disk=/dev/vdb</span><br><span class="line">pvcreate $disk # 磁盘还没有分主分区或者扩展分区，就可以直接创建物理卷（Physical volume (PV) ）了，物理卷的名字就是磁盘的名字/分区的名字</span><br><span class="line">vgcreate ci-vg $disk # 创建卷组Volume group (VG)，卷组名为 ci-vg1</span><br><span class="line">lvcreate -L 100G  -n app_data ci-vg # or lvcreate -L 100G  --name app_data ci-vg，将ci-vg 卷组中的 100G 空间划分为逻辑卷Logical volume (LV)，逻辑卷名为 app_data</span><br><span class="line"><span class="meta">#</span> lvcreate -l +100%FREE -n app_data ci-vg 将卷组百分百的空间都划分给 app_data 这个逻辑卷</span><br><span class="line">lvdisplay # 查看逻辑卷路径</span><br><span class="line">mkfs.ext3 /dev/ci-vg/app_data # 格式化</span><br><span class="line">mount /dev/ci-vg/app_data /data # 挂载，前提是要有 /data 目录</span><br><span class="line">df -Th # 查看</span><br></pre></td></tr></table></figure><p>接着，为了开机自动挂载，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "mount /dev/ci-vg/apkg /apkg" &gt;&gt; /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure><p>这个命令在有些情况不会生效，开机自启挂载磁盘，稳妥的方式推荐编辑 <code>/etc/fstab</code> 文件：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/ci-vg/app_data /data ext3 defaults 0 0</span><br></pre></td></tr></table></figure></p><h3 id="分区常用命令"><a href="#分区常用命令" class="headerlink" title="分区常用命令"></a>分区常用命令</h3><ul><li>lsblk：查看磁盘分区情况 ★★★</li><li>vgdisplay: 查看卷组信息</li><li>vgs： 查看卷组信息，简略</li><li>fdisk -l：查看系统内分区信息</li></ul><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pvcreate /dev/vdc # 新增磁盘vdc，创建为物理卷</span><br><span class="line">vgextend ci-vg1 /dev/vdc # 将新增的物理卷添加到已有的逻辑卷组中</span><br><span class="line">lvextend -l +100%FREE /dev/ci-vg/data_app # # 用 lvextend 将 /dev/ci-vg1/apkg 所在卷组所有剩余空间都分配给了它</span><br><span class="line">resize2fs /dev/ci-vg/data_app # # 磁盘格式是 ext2 ext3 ext4 使用 resize2fs， xfs使用 xfs_growfs 对扩容后的 LV 格式大小调整</span><br></pre></td></tr></table></figure><h3 id="扩容参考"><a href="#扩容参考" class="headerlink" title="扩容参考"></a>扩容参考</h3><ul><li><a href="http://aurthurxlc.github.io/Aurthur-2017/Centos-7-extend-lvm-volume.html" target="_blank" rel="noopener">手把手教你给 CentOS 7 添加硬盘及扩容(LVM)</a></li><li><a href="https://www.dwhd.org/20150521_225146.html" target="_blank" rel="noopener">Linux LVM分区之VG扩容、LV扩容、LV缩减、LVM快照</a></li><li><a href="https://blog.lutty.me/linux/2017-04/linux-lvm-resize.html" target="_blank" rel="noopener">Linux LVM 动态扩容（在线）</a></li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="Q1：发现开机启动时，rc-local没有自启动执行"><a href="#Q1：发现开机启动时，rc-local没有自启动执行" class="headerlink" title="Q1：发现开机启动时，rc.local没有自启动执行"></a>Q1：发现开机启动时，<code>rc.local</code>没有自启动执行</h3><p>尝试了<code>chmod +x /etc/rc.d/rc.local</code>之后，问题依旧，排除了权限的问题。<br>编辑<code>rc.local</code>文件，在<code>touch /var/locak/subsys/local</code>下一行，加上<code>sleep 10</code>，问题解决。</p><h3 id="Q2-bash-pvcreate-command-not-found"><a href="#Q2-bash-pvcreate-command-not-found" class="headerlink" title="Q2: -bash: pvcreate: command not found"></a>Q2: <code>-bash: pvcreate: command not found</code></h3><p>通过<code>yum install lvm2</code>安装，支持命令。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://wiki.archlinux.org/index.php/LVM_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">LVM (简体中文)</a>)</li><li><a href="https://blog.csdn.net/wuweilong/article/details/7565530" target="_blank" rel="noopener">Linx卷管理详解</a></li><li><a href="http://blog.chinaunix.net/uid-20696246-id-1892246.html" target="_blank" rel="noopener">Linux逻辑卷详解总结</a></li><li><a href="https://gtcsq.readthedocs.io/en/latest/linux_tools/disk_note.html" target="_blank" rel="noopener">Linux 磁盘和分区</a></li><li><a href="https://linux.cn/article-3218-2.html" target="_blank" rel="noopener">Linux LVM简明教程</a></li></ul><p>开机挂载</p><ul><li><a href="https://blog.csdn.net/DayDreamingBoy/article/details/8278841" target="_blank" rel="noopener">CentOS 6.3开机自动挂载磁盘和文件夹</a> fstab 文件格式介绍</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;盘面上可以细分出扇区（Sector）与柱面（Cylinder)两种单位，其中扇区每个为512bytes那么大。&lt;/p&gt;
&lt;p&gt;通常所说的”硬盘分区”就是指修改磁盘分区表，它定义了”第n个磁盘块是从第 x个柱面到第y个柱面”.因此，当系统要读取第n个磁盘块时，就是去读硬盘上第x个柱面到第y个柱面的信息.&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://michael728.github.io/categories/Linux/"/>
    
    
      <category term="分区" scheme="https://michael728.github.io/tags/%E5%88%86%E5%8C%BA/"/>
    
      <category term="lvm" scheme="https://michael728.github.io/tags/lvm/"/>
    
  </entry>
  
  <entry>
    <title>笔记-玩转Spring全家桶</title>
    <link href="https://michael728.github.io/2019/04/18/note-spring/"/>
    <id>https://michael728.github.io/2019/04/18/note-spring/</id>
    <published>2019-04-18T15:51:01.000Z</published>
    <updated>2019-04-19T16:15:00.826Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"></blockquote><a id="more"></a><script type="text/javascript" src="https://ssl.gstatic.com/trends_nrtr/1754_RC01/embed_loader.js"></script> <script type="text/javascript"> trends.embed.renderExploreWidget("TIMESERIES", {"comparisonItem":[{"keyword":"spring","geo":"US","time":"today 12-m"},{"keyword":"springboot","geo":"US","time":"today 12-m"},{"keyword":"ejb","geo":"US","time":"today 12-m"}],"category":0,"property":""}, {"exploreQuery":"geo=US&q=spring,springboot,ejb&date=today 12-m,today 12-m,today 12-m","guestPath":"https://trends.google.com:443/trends/embed/"}); </script><iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:525px; height:245px;" src="https://www.processon.com/embed/mind/5cb9dedae4b085d0107d7958"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="https://michael728.github.io/categories/Java/"/>
    
    
      <category term="Note" scheme="https://michael728.github.io/tags/Note/"/>
    
      <category term="Java" scheme="https://michael728.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="https://michael728.github.io/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="https://michael728.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>工作中常用的 Shell 命令及技巧</title>
    <link href="https://michael728.github.io/2019/04/14/linux-useful-shell-commands-in-work/"/>
    <id>https://michael728.github.io/2019/04/14/linux-useful-shell-commands-in-work/</id>
    <published>2019-04-14T07:23:23.000Z</published>
    <updated>2019-06-08T01:32:00.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="调试-bash-脚本的技巧"><a href="#调试-bash-脚本的技巧" class="headerlink" title="调试 bash 脚本的技巧"></a>调试 bash 脚本的技巧</h2><ul><li>加 <code>-x</code> 参数运行 bash 脚本时，会显示执行的语句</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 也可以在 demo.sh 中加上 set -x</span><br><span class="line">bash -x demo.sh</span><br></pre></td></tr></table></figure><ul><li>设置环境变量，然后通过如上方式运行脚本时，会显示行号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PS4='+$&#123;BASH_SOURCE&#125;:$&#123;LINENO&#125;:$&#123;FUNCNAME[0]&#125;: '</span><br></pre></td></tr></table></figure><a id="more"></a><p>参考</p><ul><li>[耗子叔-如何调试BASH脚本](<a href="https://coolshell.cn/articles/1379.html/comment-page-1#comment-1965637" target="_blank" rel="noopener">https://coolshell.cn/articles/1379.html/comment-page-1#comment-1965637</a></li></ul><h2 id="快速输入历史命令"><a href="#快速输入历史命令" class="headerlink" title="快速输入历史命令"></a>快速输入历史命令</h2><p>输入关键词之后，连续使用<code>ctrl+r</code>快速切换</p><ul><li><a href="https://stackoverflow.com/questions/14231643/in-reverse-i-search-ctrlr-any-method-to-switch-between-similar-commands-in" target="_blank" rel="noopener">In reverse-i-search (Ctrl+R ) ,Any method to switch between similar commands in history</a></li><li><a href="https://codeday.me/bug/20170919/73974.html" target="_blank" rel="noopener">linux – 在反向搜索(Ctrl R),任何在历史记录中类似命令之间切换的方法</a></li></ul><p><code>Ctrl+p/n</code> 向上/向下 显示缓存命令</p><ul><li><a href="http://www.cnblogs.com/nucdy/p/5251659.html" target="_blank" rel="noopener">Ubuntu终端常用的快捷键</a></li></ul><h2 id="ssh远程执行命令"><a href="#ssh远程执行命令" class="headerlink" title="ssh远程执行命令"></a>ssh远程执行命令</h2><p>需要远程到其他节点上执行一些 shell 命令，示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/sh</span><br><span class="line">set -x</span><br><span class="line"></span><br><span class="line">ssh root@192.168.3.43 &gt; /dev/null 2&gt;&amp;1 &lt;&lt; EOF</span><br><span class="line">cd /tmp</span><br><span class="line">touch test.txt</span><br><span class="line">exit</span><br><span class="line">EOF</span><br><span class="line">echo done</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://www.jianshu.com/p/25c2407f5905" target="_blank" rel="noopener">简书-【ssh】ssh远程执行命令</a></li></ul><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">echo "Start Datetime:" $(date +"%Y-%m-%d %H:%M:%S")</span><br><span class="line">for i in &#123;1..3&#125;</span><br><span class="line">do</span><br><span class="line">  echo $i</span><br><span class="line">  git pull --all</span><br><span class="line">  if [ $? -ne 0 ]</span><br><span class="line">  then</span><br><span class="line">    echo "不成功"</span><br><span class="line">    # 睡眠2s</span><br><span class="line">    sleep 2</span><br><span class="line">  else</span><br><span class="line">    break</span><br><span class="line">  fi</span><br><span class="line">done</span><br><span class="line">echo "End Datetime:" $(date +"%Y-%m-%d %H:%M:%S")</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://www.cnblogs.com/EasonJim/p/8315939.html" target="_blank" rel="noopener">Linux下Shell的for循环语句</a></li><li><a href="https://www.cnblogs.com/EasonJim/p/8315896.html" target="_blank" rel="noopener">Shell脚本中的分号使用</a></li></ul><h2 id="if-判断"><a href="#if-判断" class="headerlink" title="if 判断"></a>if 判断</h2><p>判读字符串($str)是否包含另一个字符串($str1)：</p><p>方法1：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [  `echo $str | grep -e '$str1'`  ] ; then</span><br><span class="line">    echo yes</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>方法2(如果<code>$str1</code>在判断中直接使用字符串而不是变量，则不能加引号，如<code>if [[ $str =~ ^dx ]]</code>判读字符串<code>$str</code>是否以<code>dx</code>开头，<code>^dx</code>不能加引号)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [[ $str =~ $str1 ]] ; then</span><br><span class="line">    echo yes</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>比较两个字符串是否相等的办法是：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if [ "$test"x = "test"x ]; then</span><br></pre></td></tr></table></figure></p><p>这里的关键有几点：</p><ul><li>使用单个等号，我发现，2个等号也 OK；</li><li>注意到等号两边各有一个空格：这是unix shell的要求</li><li>注意到<code>&quot;$test&quot;x</code>最后的<code>x</code>，这是特意安排的，因为当$test为空的时候，上面的表达式就变成了<code>x = testx</code>，显然是不相等的。而如果没有这个 <code>x</code>，表达式就会报错：<code>[: =: unary operator expected</code></li></ul><p>参考：</p><ul><li><a href="https://www.cnblogs.com/276815076/archive/2011/10/30/2229286.html" target="_blank" rel="noopener">shell中if做比较</a></li></ul><h2 id="从URL截取字段"><a href="#从URL截取字段" class="headerlink" title="从URL截取字段"></a>从URL截取字段</h2><p>默认去除url的最后斜线：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url=http://xxx/patch/xxx/xxxx/</span><br><span class="line">tar_name=$(echo $&#123;url%*/&#125;|awk -F &apos;/&apos; &apos;&#123;print $NF&#125;&apos;)</span><br></pre></td></tr></table></figure><h2 id="shell判断字符串包含"><a href="#shell判断字符串包含" class="headerlink" title="shell判断字符串包含"></a>shell判断字符串包含</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if [[ $tar =~ tar.gz ]];then echo &quot;包含&quot;;fi</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.cnblogs.com/willhua/articles/6141046.html" target="_blank" rel="noopener">Shell判断字符串包含关系的几种方法</a></li></ul><h2 id="Bash-加-xe-表示什么意思"><a href="#Bash-加-xe-表示什么意思" class="headerlink" title="Bash 加 -xe 表示什么意思"></a>Bash 加 <code>-xe</code> 表示什么意思</h2><p><code>-e</code> 使shell立即退出，某些东西会返回一个错误(这通常在shell脚本中用作故障保护机制),<br><code>-x</code> 允许详细执行脚本，你可以看到发生了什么</p><ul><li><a href="https://codeday.me/bug/20181105/355713.html" target="_blank" rel="noopener">将-xe参数传递给/ bin / bash的做法是什么</a></li></ul><h2 id="Shell-中的引号"><a href="#Shell-中的引号" class="headerlink" title="Shell 中的引号"></a>Shell 中的引号</h2><p><a href="https://blog.csdn.net/miyatang/article/details/8077123" target="_blank" rel="noopener">https://blog.csdn.net/miyatang/article/details/8077123</a></p><h2 id="Shell定义变量和给变量赋值"><a href="#Shell定义变量和给变量赋值" class="headerlink" title="Shell定义变量和给变量赋值"></a>Shell定义变量和给变量赋值</h2><h3 id="将命令的执行结果赋值给变量："><a href="#将命令的执行结果赋值给变量：" class="headerlink" title="将命令的执行结果赋值给变量："></a>将命令的执行结果赋值给变量：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var=&apos;pwd&apos;</span><br><span class="line"># 或者</span><br><span class="line">var=$(pwd)</span><br></pre></td></tr></table></figure><h3 id="将-Bash-的内置命令-read-读入的内容赋值给变量："><a href="#将-Bash-的内置命令-read-读入的内容赋值给变量：" class="headerlink" title="将 Bash 的内置命令 read 读入的内容赋值给变量："></a>将 Bash 的内置命令 read 读入的内容赋值给变量：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -n &quot;Enter var:&quot;;read var</span><br></pre></td></tr></table></figure><h2 id="通配符与特殊符号"><a href="#通配符与特殊符号" class="headerlink" title="通配符与特殊符号"></a>通配符与特殊符号</h2><table><thead><tr><th>符号</th><th>意义</th></tr></thead><tbody><tr><td>*</td><td>代表0个到无穷多个任意字符</td></tr><tr><td>？</td><td>代表一定有一个任意字符</td></tr><tr><td>[]</td><td>同样是代表一定有一个在中括号内的字符（非任意字符）。例如，[abcd]代表一定有一个字符，可能是这四个中的一个</td></tr><tr><td>[-]</td><td>若减号在括号内，代表在编码顺序内的所有字符。例如，[0-9]代表0-9之间所有数字，因为数字的语系编码是连续的</td></tr><tr><td>[^]</td><td>若中括号第一个字符是<code>^</code>，表示原向选择，例如[^abc]代表一定有一个字符，只要是非a,b,c的其他字符就接收</td></tr></tbody></table><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><ul><li>找出<code>/etc/</code>目录下文件夹名字刚好有5个字母的文件名：<code>ll -d /etc/?????</code></li><li>找出<code>/etc/</code>下面文件名含有数字的的文件名：<code>ll -d /etc/*[0-9]*</code></li><li>找出<code>/etc/</code>下面文件名开头非小写字母的文件名：<code>ll -d /etc/[^a-z]*</code></li><li>将上面例子找到的文件复制到<code>/tmp</code>中：`</li></ul><h3 id="bash-中的特殊符号"><a href="#bash-中的特殊符号" class="headerlink" title="bash 中的特殊符号"></a>bash 中的特殊符号</h3><table><thead><tr><th>符号</th><th>内容</th></tr></thead><tbody><tr><td>#</td><td>注释符号</td></tr><tr><td>\</td><td>转义符号，将特殊字符或通配符还原成一般字符</td></tr><tr><td>竖线</td><td>管道</td></tr><tr><td>;</td><td>连续命令执行分隔符，连续命令的界定</td></tr><tr><td>~</td><td>用户的主文件夹</td></tr><tr><td>$</td><td>使用变量的前导符</td></tr><tr><td>&amp;</td><td>作业控制，将命令变成背景下工作</td></tr><tr><td>!</td><td>逻辑运算意义上的“非”</td></tr><tr><td>>,&gt;&gt;</td><td>数据流重定向，输出导向，分别是“替换”与“累加”</td></tr><tr><td>&lt;,&lt;&lt;</td><td>数据流重定向，输入导向</td></tr><tr><td>‘’</td><td>单引号，<strong>不具有变量置换的功能</strong></td></tr><tr><td>“”</td><td><strong>具有变量置换的功能</strong></td></tr><tr><td>``</td><td>两个重音符中间为可以先执行的命令，也可以使用$()</td></tr><tr><td>()</td><td>中间为子shell的起始与结束</td></tr><tr><td>{}</td><td>中间为命令块的组合</td></tr></tbody></table><h2 id="给Linux新增硬盘之后的操作"><a href="#给Linux新增硬盘之后的操作" class="headerlink" title="给Linux新增硬盘之后的操作"></a>给Linux新增硬盘之后的操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l #查看磁盘情况，发现有磁盘没有分区，比如是/dev/xvde</span><br><span class="line">fdisk /dev/xvde #进行磁盘分区的操作</span><br></pre></td></tr></table></figure><p><code>fdisk</code>磁盘分区时，可以输入<code>m</code>，会有提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Command (m for help): m</span><br><span class="line">Command action</span><br><span class="line">   a   toggle a bootable flag</span><br><span class="line">   b   edit bsd disklabel</span><br><span class="line">   c   toggle the dos compatibility flag</span><br><span class="line">   d   delete a partition</span><br><span class="line">   l   list known partition types</span><br><span class="line">   m   print this menu</span><br><span class="line">   n   add a new partition</span><br><span class="line">   o   create a new empty DOS partition table</span><br><span class="line">   p   print the partition table</span><br><span class="line">   q   quit without saving changes</span><br><span class="line">   s   create a new empty Sun disklabel</span><br><span class="line">   t   change a partition&apos;s system id</span><br><span class="line">   u   change display/entry units</span><br><span class="line">   v   verify the partition table</span><br><span class="line">   w   write table to disk and exit</span><br><span class="line">   x   extra functionality (experts only)</span><br></pre></td></tr></table></figure></p><p>我依次这么输入的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add a new partition:n</span><br><span class="line">partion type:p</span><br><span class="line">Partion number:分区个数 1</span><br><span class="line">First sector默认值:Enter</span><br><span class="line">Lase sector默认值:Enter</span><br><span class="line">print the partion table:p</span><br><span class="line">write table to disk and exit:w</span><br></pre></td></tr></table></figure></p><p>分区完成之后，需要格式化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t ext4 /dev/xvde1</span><br></pre></td></tr></table></figure></p><p>将新建分区挂载到/data目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data</span><br><span class="line">mount /dev/xvde /data</span><br></pre></td></tr></table></figure><p>挂载完毕，输入<code>df -hT</code>可以查看到新建的分区</p><p>设置文件系统的自动挂载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/fstab</span><br></pre></td></tr></table></figure></p><p>添加<code>/dev/xvde1 /data ext4 defaults 0 1</code></p><p>在 fstab 配置文件中加入挂载点之后其实就已经是开机自动挂载了，不需要用 mount 命令挂载。但是还是用 mount  实在，因为最后还是需要写入<code>/etc/fstab</code></p><p>第一段可以用分区名，也可以用 <code>blkid</code> 的方式获取 <code>UUID</code> 的值</p><p>参考：</p><ul><li><a href="http://www.jianshu.com/p/7b8c3509d5fe" target="_blank" rel="noopener">www.jianshu.com/p/7b8c3509d5fe</a></li><li><a href="https://my.oschina.net/leejun2005/blog/290073" target="_blank" rel="noopener">玩转 Linux 之：磁盘分区、挂载知多少？</a></li><li><a href="https://wiki.archlinux.org/index.php/LVM_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">LVM</a>)</li><li><a href="http://wiki.jikexueyuan.com/project/linux/disk-management.html" target="_blank" rel="noopener">Linux 磁盘管理</a></li></ul><h2 id="备份原有配置文件"><a href="#备份原有配置文件" class="headerlink" title="备份原有配置文件"></a>备份原有配置文件</h2><p>只将不带注释的内容提取出来，作为配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd.conf_bak</span><br><span class="line">grep -v &quot;#&quot; /etc/vsftpd/vsftpd.conf_bak &gt; /etc/vsftpd/vsftpd.conf</span><br></pre></td></tr></table></figure><p>-v 参数表示反选</p><h2 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h2><ul><li><a href="http://yanue.net/post-142.html" target="_blank" rel="noopener">Linux下修改主机名hostname</a></li></ul><h2 id="查看Linux系统版本"><a href="#查看Linux系统版本" class="headerlink" title="查看Linux系统版本"></a>查看Linux系统版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a # 适用于所有Linux系统</span><br><span class="line">cat /etc/os-release #推荐</span><br><span class="line">cat /etc/redhat-release # 仅适用于Redhat系列的Linux系统</span><br><span class="line">uname -a # 查看Linux内核</span><br><span class="line">cat /proc/version # 查看Linux内核</span><br></pre></td></tr></table></figure><ul><li><a href="http://www.codebelief.com/article/2017/02/check-system-version-on-linux/" target="_blank" rel="noopener">Linux 命令行：查看系统版本的几种方法</a></li><li><a href="https://blog.csdn.net/u011669700/article/details/79443134" target="_blank" rel="noopener">Linux查看安装的系统版本</a></li></ul><h2 id="显示-shell-执行过程"><a href="#显示-shell-执行过程" class="headerlink" title="显示 shell 执行过程"></a>显示 shell 执行过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set -x</span><br></pre></td></tr></table></figure><p>如果想隐藏某一行的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set -x</span><br><span class="line">xxxx</span><br><span class="line">set +x</span><br><span class="line">yyyy</span><br><span class="line">set -x</span><br></pre></td></tr></table></figure></p><ul><li><a href="https://blog.csdn.net/doiido/article/details/43966419" target="_blank" rel="noopener">Linux 查看脚本的执行过程</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-shell-debug/index.html" target="_blank" rel="noopener">Shell脚本调试技术</a></li></ul><h2 id="查看端口占用"><a href="#查看端口占用" class="headerlink" title="查看端口占用"></a>查看端口占用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7.4 software]# netstat -apn                查看当前运行的所有进程的端口使用情况</span><br><span class="line">[root@centos7.4 software]# netstat -apn | grep 端口号   查看指定端口使用情况</span><br><span class="line">[root@centos7.4 software]# kill 指定端口的pid号          杀死指定进程（端口号对应的pid）</span><br></pre></td></tr></table></figure><h2 id="打印第X行"><a href="#打印第X行" class="headerlink" title="打印第X行"></a>打印第X行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n X | tail -n 1</span><br></pre></td></tr></table></figure><h2 id="显示-Path-环境变量"><a href="#显示-Path-环境变量" class="headerlink" title="显示 Path 环境变量"></a>显示 Path 环境变量</h2><p>显示你的环境变量PATH，一个目录一行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH | tr : \\n</span><br></pre></td></tr></table></figure><h2 id="atime-mtime-ctime-的含义"><a href="#atime-mtime-ctime-的含义" class="headerlink" title="atime mtime ctime 的含义"></a>atime mtime ctime 的含义</h2><ul><li>atime (access time) 访问时间，表示文件最后被访问的时间；</li><li>mtime (modify time) 修改时间，文件内容被修改的最后时间，平常我们 <code>ls -l</code> 查看文件是，显示的就是 mtime；</li><li>ctime (change time) 变化时间，文件的元数据发生变化的时间，例如权限、所有者等，通俗来讲，就是文件属性或文件位置改动的时间；</li></ul><p>利用 <code>stat file_name</code> 可以查看文件 「amc」time 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "hello" &gt;&gt; issue</span><br></pre></td></tr></table></figure><p>写文件操作（<code>&gt;&gt;</code> 方式）不会导致 atime(访问时间）的修改，但是 mtime 和 ctime 会发生修改。mtime 修改了我们可以理解的，毕竟我们修改了文件的，</p><p>那为何ctime也修改了呢， 仔细可以发现我们文件的大小发生了变化，也就是元数据发生了变化，所以ctime也是要变化的</p><p>参考：</p><ul><li><a href="https://www.cnblogs.com/zhaojiedi1992/p/zhaojiedi_linux_031_linuxtime.html#commentform" target="_blank" rel="noopener">linux中文件的三种time（atime,mtime,ctime）</a></li></ul><h2 id="重定向相关"><a href="#重定向相关" class="headerlink" title="重定向相关"></a>重定向相关</h2><ul><li><a href="https://blog.csdn.net/ggxiaobai/article/details/53507530" target="_blank" rel="noopener">CSDN-Linux里的2&gt;&amp;1究竟是什么</a></li></ul><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>有时候需要服务器上需要打开防火墙的端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone=public --add-port=60001/udp --permanent</span><br><span class="line">sudo firewall-cmd --reload</span><br><span class="line"><span class="meta">#</span>之后检查新的防火墙规则</span><br><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure><p>由于只是用于开发环境，所以打算把防火墙关闭掉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//临时关闭防火墙,重启后会重新自动打开</span><br><span class="line">systemctl restart firewalld</span><br><span class="line">//检查防火墙状态</span><br><span class="line">firewall-cmd --state</span><br><span class="line">firewall-cmd --list-all</span><br><span class="line">//Disable firewall</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl status firewalld</span><br><span class="line">//Enable firewall</span><br><span class="line">systemctl enable firewalld</span><br><span class="line">systemctl start firewalld</span><br><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://www.jianshu.com/p/bad33004bb4f" target="_blank" rel="noopener">CentOS 7开放端口和关闭防火墙</a></li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="Q-Linux各目录的作用"><a href="#Q-Linux各目录的作用" class="headerlink" title="Q:Linux各目录的作用"></a>Q:Linux各目录的作用</h3><ul><li><a href="http://www.cnblogs.com/amboyna/archive/2008/02/16/1070474.html" target="_blank" rel="noopener">linux各文件夹的作用</a></li><li><a href="http://yijiebuyi.com/blog/c3f2a606f1f0bc098f02621dfcc8405b.html" target="_blank" rel="noopener">/usr 目录结构</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/02/a_history_of_unix_directory_structure.html" target="_blank" rel="noopener">Unix目录结构的来历</a></li></ul><h3 id="Q：http-blog-csdn-net-u011109356-article-details-54928955"><a href="#Q：http-blog-csdn-net-u011109356-article-details-54928955" class="headerlink" title="Q：http://blog.csdn.net/u011109356/article/details/54928955"></a>Q：<a href="http://blog.csdn.net/u011109356/article/details/54928955" target="_blank" rel="noopener">http://blog.csdn.net/u011109356/article/details/54928955</a></h3><p><code>/dev/xvda1</code> 占满</p><h2 id="Linux好文"><a href="#Linux好文" class="headerlink" title="Linux好文"></a>Linux好文</h2><ul><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/index.html#" target="_blank" rel="noopener">Linux工具快速教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;调试-bash-脚本的技巧&quot;&gt;&lt;a href=&quot;#调试-bash-脚本的技巧&quot; class=&quot;headerlink&quot; title=&quot;调试 bash 脚本的技巧&quot;&gt;&lt;/a&gt;调试 bash 脚本的技巧&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;加 &lt;code&gt;-x&lt;/code&gt; 参数运行 bash 脚本时，会显示执行的语句&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt; 也可以在 demo.sh 中加上 set -x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bash -x demo.sh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;设置环境变量，然后通过如上方式运行脚本时，会显示行号&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;export PS4=&#39;+$&amp;#123;BASH_SOURCE&amp;#125;:$&amp;#123;LINENO&amp;#125;:$&amp;#123;FUNCNAME[0]&amp;#125;: &#39;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://michael728.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://michael728.github.io/tags/Linux/"/>
    
      <category term="Shell" scheme="https://michael728.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Mac 配置教程-开发篇</title>
    <link href="https://michael728.github.io/2019/04/14/tools-dev-mac/"/>
    <id>https://michael728.github.io/2019/04/14/tools-dev-mac/</id>
    <published>2019-04-14T07:05:50.000Z</published>
    <updated>2019-06-08T01:24:56.044Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/6d9475f6ly1g225ynphtlj20hs0bt75w.jpg" alt></p><p>将 Mac 日常使用的软件和开发软件区分开，将之前写的 Mac 配置的文章分成了两篇：</p><ul><li><a href="https://michael728.github.io/2018/12/08/tools-daily-mac/">Mac 配置教程-日常篇</a></li><li><a href="https://michael728.github.io/2019/04/14/tools-dev-mac/">Mac 配置教程-开发篇</a></li></ul><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><ul><li><a href="https://toolinbox.net/iPic/" target="_blank" rel="noopener">iPic</a></li></ul><p>设置快捷键 <code>Command+Shift+u</code></p><ul><li><a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a></li></ul><p>设置快捷键是 <code>command+shift+p</code></p><h2 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew install ssh-copy-id</span><br><span class="line">ssh-copy-id root@1.2.3.4</span><br><span class="line"># 等价于</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@1.2.3.4 -p 22</span><br></pre></td></tr></table></figure><p><code>ssh-copy-id</code> 这个工具，它的原理其实是把自己的公钥（默认使用 <code>~/.ssh/id_rsa.pub</code> 这个文件中的内容）复制到目标服务器的<code>~/.ssh/authorized_keys</code> 文件内。</p><p>可以利用 SSH 的配置文件来记住已有的配置，快速登录：</p><p>编辑<code>~/.ssh/config</code> 文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host ss</span><br><span class="line">    HostName x.x.x.x</span><br><span class="line">    User root</span><br><span class="line">    Port 22</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>后续，仅需要<code>ssh ss</code>，即可免密登录。</p><h2 id="网络分析"><a href="#网络分析" class="headerlink" title="网络分析"></a>网络分析</h2><ul><li><a href="https://httptoolkit.tech/view/" target="_blank" rel="noopener">HTTP View</a> 超酷的HTTP(S)的调试助手，一键拦截HTTP(S)，仔细研究和检查流量，并准确地发现您的代码正在发送什么。</li></ul><h2 id="编程字体"><a href="#编程字体" class="headerlink" title="编程字体"></a>编程字体</h2><ul><li><a href="https://github.com/source-foundry/Hack" target="_blank" rel="noopener">Hack</a> 专为在源代码中使用而设计的开源字体</li></ul><h2 id="alfred"><a href="#alfred" class="headerlink" title="alfred"></a>alfred</h2><ul><li>唤起快捷键设为：command双击</li><li>输入框：<code>lock</code>，锁屏</li><li><code>empty</code> 清空回收站，瞬间强迫症患者清爽了。</li><li><code>eject</code> 命令可以弹出磁盘、存储卡或者虚拟磁盘镜像，如 .dmg 挂载后的磁盘。</li><li><code>open + 文件名</code>或者<code>空格 + 文件名</code> 搜索文件，<code>Enter</code> 键直接打开文件，<code>→</code>+<code>Reveal in Finder</code> 可以在文件夹中打开文件；</li><li><code>find + 文件名</code> 直接在文件夹中打开文件；</li><li>输入 <code>in</code> 命令，以及待搜索的文本，列出磁盘中包含该文本的相关文件，可以快速定位文件，相当于简易的终端 find 命令。</li></ul><h3 id="快捷搜索URL："><a href="#快捷搜索URL：" class="headerlink" title="快捷搜索URL："></a>快捷搜索URL：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">百度- https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;wd=&#123;query&#125;</span><br><span class="line">淘宝 -  https://s.taobao.com/search?q=&#123;query&#125;</span><br><span class="line">豆瓣电影：http://movie.douban.com/subject_search?search_text=&#123;query&#125;&amp;cat=1002</span><br><span class="line">bilibili：http://search.bilibili.com/all?keyword=&#123;query&#125;</span><br><span class="line">百度：https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;wd=&#123;query&#125;</span><br><span class="line">stackoverflow：http://www.stackoverflow.com/search?q=&#123;query&#125;</span><br><span class="line">githubUser：https://github.com/&#123;query&#125;</span><br><span class="line">githubSearch：https://github.com/search?utf8=%E2%9C%93&amp;q=&#123;query&#125;</span><br><span class="line">MDN：https://developer.mozilla.org/zh-CN/search?q=&#123;query&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://juejin.im/post/5b0e99436fb9a009e405dbb6" target="_blank" rel="noopener">掘金-Mac 提升开发效率的小工具</a></li></ul><h3 id="剪贴板历史"><a href="#剪贴板历史" class="headerlink" title="剪贴板历史"></a>剪贴板历史</h3><p>有了 Alfred 的剪贴板增强，以上场景都不是问题，首先要在 Features -&gt;; Clipboard 中打开剪贴板历史：</p><p>这里我把它们都设置为存储三个月，同时把打开剪贴板的默认快捷键为 <code>Ctrl + Shift + C</code>。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwfyt1x5kej30u90jgn77.jpg" alt></p><p>通过 <code>Command + 数字键</code>，就可以把它粘贴出来</p><h3 id="文本片段"><a href="#文本片段" class="headerlink" title="文本片段"></a>文本片段</h3><p>有一些文本是需要反复输入的，比如你的邮箱、QQ号、地址、手机号码、某个网址等信息，亦或者聊天常用语句、表情等等，这些都可以通过 Alfred 来管理，节省输入时间。打开 Features -&gt;; Snippets：</p><p><a href="https://www.alfredapp.com/extras/snippets/" target="_blank" rel="noopener">https://www.alfredapp.com/extras/snippets/</a></p><h3 id="字典设置"><a href="#字典设置" class="headerlink" title="字典设置"></a>字典设置</h3><p>输入<code>dc</code>开头，然后输入查询的单词；</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fx3w4qu0acj30uc0jw10l.jpg" alt></p><h3 id="workflow"><a href="#workflow" class="headerlink" title="workflow"></a>workflow</h3><p>个人推荐的workflow:</p><ul><li><a href="https://github.com/gharlan/alfred-github-workflow" target="_blank" rel="noopener">github</a>：使用之前，需要先<code>gh &gt; login</code>。</li><li>ip address：查看本机ip</li><li>快递查询：输入<code>kd+单号</code></li><li><a href="https://github.com/Rouwanzi/AlfredWorkflow_YoudaoTranslate" target="_blank" rel="noopener">YoudaoDict</a></li><li>人民币金额大写：<code>cny</code>然后输入数字即可</li><li><a href="https://github.com/bigluck/alfred2-hash" target="_blank" rel="noopener">Hash</a>：查看文件MD5值等</li><li><a href="https://github.com/ilstar/http_status_code" target="_blank" rel="noopener">http_status_code</a>:显示 http 状态码含义</li><li><a href="https://github.com/xudaolong/CodeVar" target="_blank" rel="noopener">CodeVar</a>：</li><li><a href="https://github.com/willfarrell/alfred-encode-decode-workflow" target="_blank" rel="noopener">encode</a></li><li><a href="https://github.com/wofeiwo/alfred-baidu-map" target="_blank" rel="noopener">百度地图</a></li></ul><p>我常用的存储在这儿了：<a href="https://github.com/Michael728/my-config-files/tree/master/alfred-work-flow" target="_blank" rel="noopener">my-config-files/alfred-work-flow</a></p><p>下载源：</p><ul><li><a href="http://www.alfredworkflow.com/" target="_blank" rel="noopener">alfredworkflow</a></li><li><a href="http://www.packal.org/workflow-list" target="_blank" rel="noopener">workflow-list</a></li><li><a href="https://github.com/zenorocha/alfred-workflows" target="_blank" rel="noopener">zenorocha/alfred-workflows</a></li></ul><h3 id="自定义终端"><a href="#自定义终端" class="headerlink" title="自定义终端"></a>自定义终端</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">on alfred_script(q)</span><br><span class="line">    tell application "iTerm"</span><br><span class="line">        set _length to count window</span><br><span class="line">    if _length = 0 then</span><br><span class="line">        create window with default profile</span><br><span class="line">    end if</span><br><span class="line">    set aa to (get miniaturized of current window)</span><br><span class="line">    if aa then</span><br><span class="line">        set miniaturized of current window to false</span><br><span class="line">    end if</span><br><span class="line">    set bb to (get visible of current window)</span><br><span class="line">    if bb is false then</span><br><span class="line">        set visible of current window to true</span><br><span class="line">    end if</span><br><span class="line">    set cc to frontmost</span><br><span class="line">    if cc is false then</span><br><span class="line">        activate</span><br><span class="line">    end if</span><br><span class="line">        (*if _length = 0 then*)</span><br><span class="line">            set theResult to current tab of current window</span><br><span class="line">        (*else</span><br><span class="line">            set theResult to (create tab with default profile) of current window</span><br><span class="line">        end if*)</span><br><span class="line">        write session of theResult text q</span><br><span class="line">end tell</span><br><span class="line">end alfred_script</span><br></pre></td></tr></table></figure><p>Alfred使用参考：</p><ul><li><a href="https://sspai.com/post/43973" target="_blank" rel="noopener">总是在 Mac 「装机必备」看到的搜索利器 Alfred，究竟是怎么用的？| 新手问号</a></li><li><a href="https://hufangyun.com/2018/alfred-workflow-recommend/" target="_blank" rel="noopener">效率神器 Alfred workflow 插件推荐</a></li><li><a href="http://blog.surfacew.com/tool/2016/08/03/Alfred/" target="_blank" rel="noopener">Alfred 效率神器全攻略</a></li><li><a href="http://louiszhai.github.io/2018/05/31/alfred/#%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85alfred" target="_blank" rel="noopener">Alfred神器使用手册</a></li><li><a href="https://www.jianshu.com/p/2ce1dd633f4f" target="_blank" rel="noopener">Mac效率神器Alfred系列教程—文件搜索</a></li></ul><h2 id="Beyond-Compare"><a href="#Beyond-Compare" class="headerlink" title="Beyond Compare"></a>Beyond Compare</h2><p>Beyond Compare：完美的diff工具；</p><h2 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a>Charles</h2><ul><li><a href="https://www.jianshu.com/p/89111882fa99" target="_blank" rel="noopener">Charles 注册码/破解</a></li></ul><h2 id="Dash"><a href="#Dash" class="headerlink" title="Dash"></a>Dash</h2><p>Dash：计算机语言文档神器；</p><ul><li>选中文本搜索开发文档：<code>alt/option+s</code></li></ul><h2 id="ForkLift-3"><a href="#ForkLift-3" class="headerlink" title="ForkLift 3"></a>ForkLift 3</h2><p>Mac 上的 Finder 的增强版本，FTP 工具，官网有<a href="https://binarynights.com/" target="_blank" rel="noopener">视频介绍</a>，强烈安利！</p><ul><li><a href="https://sspai.com/post/40554" target="_blank" rel="noopener">被忽视的 FTP 与文件管理工具：ForkLift 3 for Mac</a></li></ul><h2 id="go2shell"><a href="#go2shell" class="headerlink" title="go2shell"></a>go2shell</h2><p>从官网下载安装，然后打开，同意安装到Finder。</p><ul><li><a href="http://zipzapmac.com/go2shell" target="_blank" rel="noopener">go2shell官网</a></li><li><a href="https://www.cnblogs.com/shengulong/p/6655558.html" target="_blank" rel="noopener">Mac通过安装Go2Shell实现“在当前目录打开iTerm2”</a></li></ul><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ul><li><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载安装</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-keygen -t rsa -C "649168982@qq.com"</span><br><span class="line"><span class="meta">$</span> git config --global user.name "Michael728"</span><br><span class="line"><span class="meta">$</span> git config --global user.email "649168982@qq.com"</span><br></pre></td></tr></table></figure><p>我的 Git 配置文件在：<a href="https://github.com/Michael728/my-config-files/tree/master/git" target="_blank" rel="noopener">my-config-files/git</a></p><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><p>Q1： <code>git status</code>乱码<br>执行：<code>git config --global core.quotepath false</code><br>参考：<a href="http://blog.crhan.com/2012/09/git-status-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3/" target="_blank" rel="noopener">Git Status 中文乱码解决</a></p><p>Q2：Github 下载速度慢</p><ul><li><a href="https://aoenian.github.io/2018/05/12/github-access-fast/" target="_blank" rel="noopener">加快国内访问Github网站的速度</a></li><li><a href="https://www.wangmaoxian.com/201808/%E5%9B%BD%E5%86%85%E4%B8%BA%E4%BD%95%E8%AE%BF%E9%97%AEGithub%E5%A6%82%E6%AD%A4%E6%85%A2/" target="_blank" rel="noopener">国内为何访问Github如此慢</a></li></ul><h2 id="Homebrew-amp-Cask-amp-launchrocket"><a href="#Homebrew-amp-Cask-amp-launchrocket" class="headerlink" title="Homebrew &amp; Cask &amp; launchrocket"></a>Homebrew &amp; Cask &amp; launchrocket</h2><p><a href="https://brew.sh/index_zh-cn" target="_blank" rel="noopener">Homebrew-官网</a>安装 brew 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br></pre></td></tr></table></figure><p><a href="http://caskroom.io/" target="_blank" rel="noopener">Homebrew cask</a>可以优雅、简单、快速的安装和管理 OS X 图形界面程序，比如 Google Chrome 和 Dropbox，安装 cask 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew tap caskroom/cask</span><br></pre></td></tr></table></figure></p><p>常用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">brew search xxx // 搜索</span><br><span class="line">brew cask search xxx // 搜索</span><br><span class="line">brew list --versions // 查看安装过的包列表，同时显示版本号</span><br><span class="line">brew update // 更新 brew</span><br><span class="line">brew upgrade &lt;package_name&gt; // 更新用brew安装的软件</span><br><span class="line">brew cleanup // 清理旧版本的包缓存时，清除安装包</span><br><span class="line">brew cask cleanup // 清除安装包</span><br><span class="line">brew doctor // 检测</span><br><span class="line">brew outdated // 看一下哪些软件可以升级</span><br><span class="line">brew info xxx // 查看某个软件信息</span><br><span class="line">brew cask info xxx // 查看某个软件信息</span><br><span class="line">brew unlink vim</span><br></pre></td></tr></table></figure><p>更多命令可以通过<code>man brew</code>查看：</p><ul><li><a href="https://docs.brew.sh/Manpage" target="_blank" rel="noopener">brew 命令官网</a></li><li><a href="https://segmentfault.com/a/1190000012826983" target="_blank" rel="noopener">SF-homebrew的tap功能详解</a></li><li><a href="https://blog.csdn.net/beyond__devil/article/details/52649362" target="_blank" rel="noopener">CSDN-mac的homebrew命令详解&amp;全部选项翻译</a></li></ul><p>Homebrew 能够安装哪些软件：</p><ul><li><code>brew search xxx</code></li><li>在<a href="https://formulae.brew.sh/formula/" target="_blank" rel="noopener">官网</a>浏览</li><li>在<a href="https://brewformulas.org/" target="_blank" rel="noopener">Homebrew formulas index</a>查看详细的使用信息</li></ul><p>测试安装是否成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew install wget</span><br><span class="line">brew cask install google-chrome</span><br><span class="line">brew cask install cakebrew # brew</span><br><span class="line">brew cask install launchrocket # 管理 brew 安装的 service 的工具，安装之后可以看所有的 service 的运行状态</span><br></pre></td></tr></table></figure><ul><li>brew 方式安装的软件都在<code>/usr/local/Cellar</code>目录下，执行<code>brew link xxx</code>，则会在<code>/usr/local/share</code>创建软连接。</li><li>brew cask 方式安装的软件在<code>/usr/local/Caskroom</code>目录下</li></ul><p>Homebrew已成为Mac开发用户必不可少的工具, 大部分开发工具的安装和环境构建都非常方便. 但是如果配合<a href="https://www.cakebrew.com/" target="_blank" rel="noopener">Cakebrew</a>和<a href="(https://github.com/jimbojsb/launchrocket">LaunchRocket</a>, 那将会更方便管理。</p><p><a href="https://www.zhihu.com/question/22624898" target="_blank" rel="noopener">brew和brew cask有什么区别？</a>：<a href="http://caskroom.io/" target="_blank" rel="noopener">cask</a> 更偏向图形化软件的安装。</p><h3 id="拓展预览程序"><a href="#拓展预览程序" class="headerlink" title="拓展预览程序"></a>拓展预览程序</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install qlcolorcode qlstephen qlmarkdown quicklook-json qlimagesize webpquicklook qlvideo provisionql quicklookapk</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/sindresorhus/quick-look-plugins" target="_blank" rel="noopener">插键-sindresorhus/quick-look-plugins</a></li></ul><h3 id="Homebrew-源加速"><a href="#Homebrew-源加速" class="headerlink" title="Homebrew 源加速"></a>Homebrew 源加速</h3><p>知乎上给出了两种方式，因为有 VPS了，所以，目前我采用的是设置 <code>~/.curlrc</code> 文件配置如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socks5 = &quot;127.0.0.1:1086&quot;</span><br></pre></td></tr></table></figure></p><p>具体配置文件，可以查看：<a href="https://github.com/Michael728/my-config-files/tree/master/homebrew" target="_blank" rel="noopener">my-config-files-homebrew</a></p><p>参考：</p><ul><li><a href="https://www.zhihu.com/question/31360766" target="_blank" rel="noopener">Homebrew有比较快的源（mirror）吗？</a></li><li><a href="http://mirrors.ustc.edu.cn/help/homebrew-cask.git.html" target="_blank" rel="noopener">Homebrew Cask 源使用帮助</a></li><li><a href="https://sspai.com/topic/181" target="_blank" rel="noopener">Homebrew专栏</a></li><li><a href="http://blog.devtang.com/2014/02/26/the-introduction-of-homebrew-and-brewcask/" target="_blank" rel="noopener">使用brew cask来安装Mac应用</a></li></ul><h2 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h2><ul><li>快捷键打开ITerm2:打开设置，<code>keys-hotkey-show/hide window</code>，我设置快捷键为<code>command+~</code></li><li>切分屏幕：<code>command+d</code> 水平切分，<code>command+Shift+d</code>垂直切分；<code>Command + [</code> 和 <code>Command + ]</code> 来切换到左侧或者右侧的标签页。</li><li>一个标签页中开的窗口太多，有时候会找不到当前的鼠标，<code>command+/</code>找到它。</li><li>按<code>command+;</code>弹出自动补齐窗口，列出曾经使用过的命令</li><li>按<code>command+Shift+h</code>弹出历史粘贴记录窗口，<code>command+Shift+;</code>弹出历史命令记录窗口。</li><li><code>command+d</code>，新建垂直标签，利用 <code>command+[/]</code> 左右切换标签窗口。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ctrl + w —往回删除一个单词，光标放在最末尾</span><br><span class="line">ctrl + k —往前删除到末尾，光标放在最前面（可以使用ctrl+a）</span><br><span class="line">ctrl + u 删除光标以前的字符</span><br><span class="line">ctrl + k 删除光标以后的字符</span><br><span class="line">ctrl + a 移动光标至的字符头</span><br><span class="line">ctrl + e 移动光标至的字符尾</span><br><span class="line">ctrl + l 清屏</span><br></pre></td></tr></table></figure><p>iTerm2 中选择文本有三种方式，分别是：</p><ul><li>双击：选中单词</li><li>三击：选中整行</li></ul><p>参考：</p><ul><li><a href="http://wulfric.me/2015/08/iterm2/" target="_blank" rel="noopener">你应该知道的 iTerm2 使用方法–MAC终端工具</a></li></ul><h3 id="皮肤-字体"><a href="#皮肤-字体" class="headerlink" title="皮肤+字体"></a>皮肤+字体</h3><ul><li><a href="https://github.com/mbadolato/iTerm2-Color-Schemes/tree/master/schemes" target="_blank" rel="noopener">皮肤资源</a></li><li><a href="https://draculatheme.com/iterm/" target="_blank" rel="noopener">dracula</a>：本人采用的就是这个主题，因为VScode中也是它。</li><li><a href="https://powerline.readthedocs.io/en/latest/installation.html" target="_blank" rel="noopener">powerline字体教程</a></li></ul><p>字体安装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install powerline-status</span><br></pre></td></tr></table></figure><p>这套皮肤+字体的设置主要是为了配合zsh终端下的现实效果，zsh的使用配置，见文章：</p><ul><li><a href="http://michael728.github.io/2018/03/11/tools-zsh-tutorial/">zsh+on-my-zsh配置教程指南（程序员必备）</a></li></ul><p>最后效果如下图：</p><p><img src="https://ws1.sinaimg.cn/mw690/6d9475f6ly1fw7jjv06kdj20j103gwey.jpg" alt></p><p>皮肤安装教程见：</p><ul><li><a href="https://www.jianshu.com/p/7de00c73a2bb" target="_blank" rel="noopener">iTerm 2 &amp;&amp; Oh My Zsh【DIY教程——亲身体验过程】</a></li><li><a href="https://www.jianshu.com/p/53eb1075f627" target="_blank" rel="noopener">最简单iTerm2 + oh-my-zsh打造Mac炫酷终端教程-菜鸟版实操整理</a></li></ul><h3 id="FAQ-1"><a href="#FAQ-1" class="headerlink" title="FAQ"></a>FAQ</h3><p>Q1: iterm 本地终端中文不乱码，ssh远程中文乱码</p><ul><li><a href="iterm 配置utf8编码，本地终端中文不乱码，ssh远程中文乱码，咋整啊">iterm 配置utf8编码，本地终端中文不乱码，ssh远程中文乱码，咋整啊</a></li></ul><h2 id="Medis"><a href="#Medis" class="headerlink" title="Medis"></a>Medis</h2><p><a href="https://github.com/luin/medis" target="_blank" rel="noopener">https://github.com/luin/medis</a></p><p>redis 数据库客户端</p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><ul><li><a href="https://www.sequelpro.com/" target="_blank" rel="noopener">sequelpro</a> mysql 客户端，颜值高。免费</li></ul><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node官网</a>：下载LTS版本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo # 博客所需</span><br><span class="line">sudo npm install gitbook-cli -g # 笔记所需</span><br></pre></td></tr></table></figure><h2 id="Mosh"><a href="#Mosh" class="headerlink" title="Mosh"></a>Mosh</h2><p>Mosh 表示移动 Shell(Mobile Shell)，是一个用于从客户端跨互联网连接远程服务器的命令行工具。它能用于 SSH 连接，但是比 Secure Shell 功能更多。它是一个类似于 SSH 而带有更多功能的应用。程序最初由Keith Winstein 编写，用于类 Unix 的操作系统中，发布于 GNU GPL V3 协议下。</p><p>Mosh 最大的特点是基于UDP方式传输，支持在服务端创建一个临时的Key供客户端一次性连接，退出后失效；也支持通过SSH的配置进行认证，但数据传输本身还是自身的 UDP 方式。</p><p>Mosh 有两个非常有用的功能</p><ul><li>会话的中断不会导致当前正在前端执行的命令中断，相当于你所有的操作都是在 screen 命令中一样在后台执行。</li><li>会话在中断过后，不会立刻退出，而是启用一个计时器，当网络恢复后会自动重新连接，同时会延续之前的会话，不会重新开启一个。</li></ul><p>Mosh 替换 SSH 链接，需要你本机和远端 host 都安装 mosh 才OK：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install mosh # mac</span><br><span class="line">yum install mosh # centos</span><br><span class="line">apt-get install mosh # ubuntu</span><br></pre></td></tr></table></figure><p>PS：我用这款工具的主要原因是，在家里我的 Mac 连接虚拟机的速度非常慢，ssh 到虚拟机执行命令非常卡顿，使用 mosh 之后流畅了许多。</p><p>有时候需要服务器上需要打开防火墙的端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone=public --add-port=60001/udp --permanent</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure><h2 id="Python3安装"><a href="#Python3安装" class="headerlink" title="Python3安装"></a>Python3安装</h2><ul><li><a href="https://pythonguidecn.readthedocs.io/zh/latest/starting/install3/osx.html" target="_blank" rel="noopener">在Mac OS X上安装Python 3</a></li><li><a href="https://www.anaconda.com/download/#macos" target="_blank" rel="noopener">Python3-Anaconda</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 'export PATH="~/anaconda3/bin:$PATH"' &gt;&gt; ~/.bash_profile</span><br></pre></td></tr></table></figure><p>安装之后记得重启终端。</p><h2 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h2><ul><li><a href="https://www.getpostman.com/" target="_blank" rel="noopener">Postman官网</a></li></ul><h2 id="Pycharm"><a href="#Pycharm" class="headerlink" title="Pycharm"></a>Pycharm</h2><ul><li><a href="https://www.jetbrains.com/pycharm/download/#section=mac" target="_blank" rel="noopener">官宣-Pycharm</a></li><li><a href="http://idea.lanyus.com/" target="_blank" rel="noopener">lanyus</a> 福利，细心读者能发现 :)</li></ul><h2 id="SourceTree"><a href="#SourceTree" class="headerlink" title="SourceTree"></a>SourceTree</h2><p>源码管理：SourceTree</p><ul><li><a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">sourcetree官网</a></li></ul><h2 id="typora"><a href="#typora" class="headerlink" title="typora"></a>typora</h2><p>Markdown 编辑器： <a href="https://typora.io/" target="_blank" rel="noopener">typora官网</a></p><h2 id="安装-macvim-和-vim"><a href="#安装-macvim-和-vim" class="headerlink" title="安装 macvim 和 vim"></a>安装 macvim 和 vim</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install macvim</span><br></pre></td></tr></table></figure><p><a href="https://brewformulas.org/Macvim" target="_blank" rel="noopener">Homebrew formulas index-macvim</a>已经明确指出，这么安装和<code>brew install vim</code>的<code>vim</code>冲突，所有某些博客文章中安装<code>macvim</code>的指导说需要先安装<code>vim</code>的说法是有问题的，我那么执行时就报错了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This formula is in conflict with the following</span><br></pre></td></tr></table></figure><p>错误提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Updating Homebrew...</span><br><span class="line">Error: Cannot install macvim because conflicting formulae are installed.</span><br><span class="line">  vim: because vim and macvim both install vi* binaries</span><br><span class="line"></span><br><span class="line">Please `brew unlink vim` before continuing.</span><br></pre></td></tr></table></figure><p>我先执行了<code>brew install vim</code>，然后通过<code>brew unlink vim</code>去除了<code>/usr/local/share/</code>创建的 vim 相关的软连接，避免和<code>macvim</code>冲突。然后又通过<code>brew install macvim</code>安装了<code>macvim</code>。</p><p>如果你想采用<code>macvim</code>代替<code>vim</code>，需要：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew unlink vim</span><br><span class="line">brew link macvim</span><br><span class="line">alias vim='mvim -v' # 加入 zsh 配置文件</span><br></pre></td></tr></table></figure><p>如果你想采用 brew 安装的 vim，替换系统默认的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew unlink mackvim</span><br><span class="line">brew link vim</span><br><span class="line">export PATH="/usr/local/Cellar/vim/8.1.0550/bin:$PATH" # 加入 zsh 配置文件</span><br></pre></td></tr></table></figure><p>安装之后，还有一些兼容性的设置需要设置才行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vmap &lt;C-c&gt; "+y " 在Visual模式时，按Ctrl+c复制选择的内容</span><br><span class="line">set backspace=2 " http://cenalulu.github.io/linux/why-my-backspace-not-work-in-vim/</span><br><span class="line">set clipboard+=unnamed " 共享剪贴板 http://www.vitah.net/posts/9ddf2fa9/</span><br></pre></td></tr></table></figure><p>关于 Vim 的配置及使用，可以阅读：<a href="https://michael728.github.io/2018/12/02/tools-vim-plugin-config/">Vim 插键及配置</a></p><p>参考：</p><ul><li><a href="https://github.com/Homebrew/homebrew-core/issues/32464" target="_blank" rel="noopener">Macvim install fails on MacOS 10.14</a></li><li><a href="https://github.com/macvim-dev/macvim/wiki/FAQ" target="_blank" rel="noopener">FAQ-macvim-dev/macvim</a></li><li><a href="http://cenalulu.github.io/linux/why-my-backspace-not-work-in-vim/" target="_blank" rel="noopener">Mac的VIM中delete键失效的原因和解决方案</a></li><li><a href="http://www.vitah.net/posts/9ddf2fa9/" target="_blank" rel="noopener">macOS上安装MacVim</a></li></ul><h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><p>真是不得不介绍的神器，专门写了一篇文章：</p><ul><li><a href="https://michael728.github.io/2018/03/11/tools-zsh-tutorial/">zsh+on-my-zsh配置教程指南（程序员必备）</a></li><li><a href="http://shadow000902.space/2018/10/18/Mac-%E4%B8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%A7%84%E5%88%99%E5%8F%8A%E7%AE%A1%E7%90%86/" target="_blank" rel="noopener">Mac 下环境变量规则及管理</a></li></ul><h2 id="VScode"><a href="#VScode" class="headerlink" title="VScode"></a>VScode</h2><ul><li><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">官宣-VS Code</a></li><li><a href="https://michael728.github.io/2018/10/28/tools-vscode/">打造性感好用的VS Code编辑器</a></li></ul><p>在 VS code 中快捷键 <code>Shift + Command + p</code> 输入 code ,选择安装 code 命令：</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxzcmjc8qhj30gl07a75g.jpg" alt></p><p>然后就可以在终端中这么打开 VS Code了 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code .vimrc</span><br></pre></td></tr></table></figure><h2 id="Mac-相关好文"><a href="#Mac-相关好文" class="headerlink" title="Mac 相关好文"></a>Mac 相关好文</h2><ul><li><a href="https://wild-flame.github.io/guides/docs/mac-os-x-setup-guide/guide-introduction" target="_blank" rel="noopener">推荐-Mac OS X 配置指南 | Mac OS X Setup Guide</a></li><li><a href="http://python-web-guide.readthedocs.io/zh/latest/codingtools/codingtools.html" target="_blank" rel="noopener">Mac开发和编程工具</a></li><li><a href="https://juejin.im/post/5b0e99436fb9a009e405dbb6" target="_blank" rel="noopener">Mac 提升开发效率的小工具</a></li><li><a href="https://leohxj.gitbooks.io/a-programmer-prepares/software/mac/index.html" target="_blank" rel="noopener">GitBook-Mac-程序员的自我修养</a></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>原文链接：<a href="https://michael728.github.io/2018/12/08/hobby-mac/">Mac 配置总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/6d9475f6ly1g225ynphtlj20hs0bt75w.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;将 Mac 日常使用的软件和开发软件区分开，将之前写的 Mac 配置的文章分成了两篇：&lt;/p&gt;

      
    
    </summary>
    
      <category term="ToolsDev" scheme="https://michael728.github.io/categories/ToolsDev/"/>
    
    
      <category term="Tools" scheme="https://michael728.github.io/tags/Tools/"/>
    
      <category term="Mac" scheme="https://michael728.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Python 模块的加载顺序</title>
    <link href="https://michael728.github.io/2018/12/15/python-package-import-order/"/>
    <id>https://michael728.github.io/2018/12/15/python-package-import-order/</id>
    <published>2018-12-15T14:50:18.000Z</published>
    <updated>2018-12-15T15:12:18.800Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/6d9475f6ly1fy7u3g3083j20hs08w754.jpg" alt></p><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>模块， 一个 py 文件或以其他文件形式存在的可被导入的就是一个模块</p><h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><p>包，包含有 <strong>init</strong> 文件的文件夹</p><h3 id="relative-path"><a href="#relative-path" class="headerlink" title="relative path"></a>relative path</h3><p>相对路径，相对于某个目录的路径</p><h3 id="absolute-path"><a href="#absolute-path" class="headerlink" title="absolute path"></a>absolute path</h3><p>绝对路径，全路径</p><h2 id="Python-解释器是如何查找包和模块的"><a href="#Python-解释器是如何查找包和模块的" class="headerlink" title="Python 解释器是如何查找包和模块的"></a>Python 解释器是如何查找包和模块的</h2><p>Python 执行一个 py 文件，无论执行的方式是用绝对路径还是相对路径，interpreter 都会把文件所在的 directory 加入 sys.path 这个 list 中，并且是索引为 0 的位置。Python 就是在 sys.path 中查找包和模块的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.path)</span><br><span class="line">print(<span class="string">'Now in main.py'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'michael hello'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    hello()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行 python test.py</span></span><br><span class="line">$ python test.py</span><br><span class="line">[<span class="string">'/tmp/module-package/app'</span>, <span class="string">'/usr/lib64/python27.zip'</span>, <span class="string">'/usr/lib64/python2.7'</span>, <span class="string">'/usr/lib64/python2.7/plat-linux2'</span>, <span class="string">'/usr/lib64/python2.7/lib-tk'</span>, <span class="string">'/usr/lib64/python2.7/lib-old'</span>, <span class="string">'/usr/lib64/python2.7/lib-dynload'</span>, <span class="string">'/usr/lib64/python2.7/site-packages'</span>, <span class="string">'/usr/lib/python2.7/site-packages'</span>]</span><br><span class="line">Now <span class="keyword">in</span> test.py</span><br><span class="line">michael hello</span><br></pre></td></tr></table></figure><h2 id="Python-解释器查找包的顺序"><a href="#Python-解释器查找包的顺序" class="headerlink" title="Python 解释器查找包的顺序"></a>Python 解释器查找包的顺序</h2><p>解释器查找包：</p><ul><li>解释器会默认加载一些 modules，除了<code>sys.builtin_module_names</code> 列出的内置模块之外，还会加载其他一些标准库，都存放在<code>sys.modules</code>字典中。</li><li>然后就是搜索 <code>sys.path</code> 路径下的模块了。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">3</span>]: <span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: print(sys.builtin_module_names)</span><br><span class="line">(<span class="string">'_abc'</span>, <span class="string">'_ast'</span>, <span class="string">'_codecs'</span>, <span class="string">'_collections'</span>, <span class="string">'_functools'</span>, <span class="string">'_imp'</span>, <span class="string">'_io'</span>, <span class="string">'_locale'</span>, <span class="string">'_operator'</span>, <span class="string">'_signal'</span>, <span class="string">'_sre'</span>, <span class="string">'_stat'</span>, <span class="string">'_string'</span>, <span class="string">'_symtable'</span>, <span class="string">'_thread'</span>, <span class="string">'_tracemalloc'</span>, <span class="string">'_warnings'</span>, <span class="string">'_weakref'</span>, <span class="string">'atexit'</span>, <span class="string">'builtins'</span>, <span class="string">'errno'</span>, <span class="string">'faulthandler'</span>, <span class="string">'gc'</span>, <span class="string">'itertools'</span>, <span class="string">'marshal'</span>, <span class="string">'posix'</span>, <span class="string">'pwd'</span>, <span class="string">'sys'</span>, <span class="string">'time'</span>, <span class="string">'xxsubtype'</span>, <span class="string">'zipimport'</span>)</span><br></pre></td></tr></table></figure><p>这样的查找顺序将会导致同名包或模块被遮蔽。</p><p>示例2：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tree</span></span><br><span class="line">$ tree . -L <span class="number">1</span></span><br><span class="line">.</span><br><span class="line">├── __init__.py</span><br><span class="line">├── name</span><br><span class="line">├── os.py</span><br><span class="line">├── test2.py</span><br><span class="line">├── test.py</span><br><span class="line">└── test.pyc</span><br><span class="line"></span><br><span class="line"><span class="comment"># test2.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> hello</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Now in test2.py'</span>)</span><br><span class="line">print(os.getcwd())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行 python test2.py</span></span><br><span class="line">$ python test2.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"test2.py"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line">ImportError: No module named redis</span><br></pre></td></tr></table></figure></p><p>这里的 <code>os</code> 模块并不是是 <code>built-in module</code>，上面已经将 <code>sys.builtin_module_names</code> 内容打印出来了。只是 Python 解释器启动时就加载到了 <code>sys.modules</code>中缓存起来了。所以，即使在同目录下有同名模块，解释器依然是可以找到正确的 <code>os</code> 模块的！如果你在<code>import os</code>之前，先执行<code>del sys.modules[&#39;os&#39;]</code>，那么，标准模块 <code>os</code> 就会被同目录下的 <code>os.py</code> 屏蔽了。</p><p><code>redis</code> 属于第三方模块，默认安装位置是 Python 环境变量中的 <code>site-packages</code>，解释器启动之后，会将此目录加到 <code>sys.path</code>，由于当前目录会在 <code>sys.path</code> 的首位，当前目录的 redis 优先被找到了，<code>site-packages</code> 中的 <code>redis</code> 模块被屏蔽了。</p><p>综上所述，搜索的一个顺序是：<code>sys.modules</code> 缓存 -&gt; <code>sys.path[0]</code> 即当前目录查找 -&gt; <code>sys.path[1:]</code>路径查找。</p><p>同时发现，模块被加载的时候，其中非函数或类的语句，例如 <code>print(&#39;hello&#39;)</code>、<code>name=michael</code>等，是会在 <code>import</code>的时候，默认就执行了。</p><h2 id="交互式执行环境的查找顺序"><a href="#交互式执行环境的查找顺序" class="headerlink" title="交互式执行环境的查找顺序"></a>交互式执行环境的查找顺序</h2><p>交互执行环境，解释器会自动把当前目录加入到<code>sys.path</code>，这一点和直接执行文件是一样的，但是这种方式下，<code>sys.path[0]</code> 是存储的当前目录的相对路径，而不是绝对路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">4</span>]: <span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: sys.path[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">5</span>]: <span class="string">''</span></span><br></pre></td></tr></table></figure><h2 id="模块中的-file-变量"><a href="#模块中的-file-变量" class="headerlink" title="模块中的 __file__ 变量"></a>模块中的 <code>__file__</code> 变量</h2><h3 id="文件中的-file"><a href="#文件中的-file" class="headerlink" title="文件中的 __file__"></a>文件中的 <code>__file__</code></h3><p>当模块以文件的形式出现 <strong>file</strong> 指的是模块文件的路径名，以相对路径执行 <strong>file</strong> 是相对路径，以绝对路径执行 <strong>file</strong> 是绝对路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test3.py</span></span><br><span class="line"><span class="keyword">print</span> __file__</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行 python test.py</span></span><br><span class="line">$ python test3.py</span><br><span class="line">test3.py</span><br><span class="line"></span><br><span class="line">$ python /tmp/module-package/app/test3.py</span><br><span class="line">/tmp/module-package/app/test3.py</span><br></pre></td></tr></table></figure><h3 id="交互式-Shell-中的-file"><a href="#交互式-Shell-中的-file" class="headerlink" title="交互式 Shell 中的 __file__"></a>交互式 Shell 中的 <code>__file__</code></h3><p>前交互式 Shell 的执行并不是以文件的形式加载，所以不存在 <code>__file__</code> 这样的属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">8</span>]: __file__</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">NameError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-8</span><span class="number">-358</span>d5687b810&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 __file__</span><br><span class="line"></span><br><span class="line">NameError: name <span class="string">'__file__'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure><h2 id="sys-argv-0-变量"><a href="#sys-argv-0-变量" class="headerlink" title="sys.argv[0] 变量"></a><code>sys.argv[0]</code> 变量</h2><p><code>sys.argv[0]</code> 是获得入口执行文件路径，<code>__file__</code> 是真实被执行模块的文件路径。比如下面例子中，<code>test2.py</code> 就是入口执行文件，而 <code>test.py</code> 就是在 <code>import</code> 时真实被执行的模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line">print(__file__)</span><br><span class="line">print(sys.argv[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># test2.py</span></span><br><span class="line"><span class="keyword">import</span> test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行 python test2.py</span></span><br><span class="line">/tmp/module-package/app/test.py <span class="comment"># __file__</span></span><br><span class="line">test2.py <span class="comment"># sys.argv[0]</span></span><br></pre></td></tr></table></figure><h2 id="sys-modules-的作用"><a href="#sys-modules-的作用" class="headerlink" title="sys.modules 的作用"></a><code>sys.modules</code> 的作用</h2><p>载入的模块存放在何处？ 答案是 <code>sys.modules</code>。 模块一经载入， Python 会把这个模块加入 <code>sys.modules</code> 中供下次载入使用，这样可以加速模块引入，起到缓存作用。<code>sys.modules</code> 是一个 <code>dict</code> 类型的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">14</span>]: sys.modules[<span class="string">'requests'</span>]</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">KeyError                                  Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-14</span><span class="number">-8</span>aefaef0aed5&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 sys.modules['requests']</span><br><span class="line"></span><br><span class="line">KeyError: <span class="string">'requests'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: <span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: sys.modules[<span class="string">'requests'</span>]</span><br><span class="line">Out[<span class="number">16</span>]: &lt;module <span class="string">'requests'</span> <span class="keyword">from</span> <span class="string">'/usr/lib/python2.7/site-packages/requests/__init__.pyc'</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有预先引入 math，但是 sys.modules 中已经有这个键</span></span><br><span class="line">In [<span class="number">18</span>]: sys.modules[<span class="string">'math'</span>]</span><br><span class="line">Out[<span class="number">18</span>]: &lt;module <span class="string">'math'</span> <span class="keyword">from</span> <span class="string">'/usr/lib64/python2.7/lib-dynload/math.so'</span>&gt;</span><br></pre></td></tr></table></figure><p>需要注意的是， <code>sys.modules[&#39;math&#39;]</code>  尽管可以看到 <code>math</code> 键，但是，要使用它，还是需要显示 <code>import math</code> 之后才能使用的，因为那只是 Python 解释器后台缓存的，你不显示引入，本地空间还是不会去发现它。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Python 通过查找 <code>sys.path</code> 来决定包的导入，Python解释器启动时加载的模块缓存 &gt; 同级目录 &gt; <code>sys.path[1:]</code>。Python 中的特有属性 <code>__file__</code> 以及 <code>sys.argv[0]</code>、<code>sys.argv[0]</code>、<code>sys.modules</code> 可以帮助分析包的查找和导入过程。</p><p>解决这个问题，请教了大牛同事，果然一下子让我明白了。于是，自问自答了在 SegmentFault 上提的问题：</p><ul><li><a href="https://segmentfault.com/q/1010000017357057" target="_blank" rel="noopener">Python 包的引入顺序到底是怎样的？</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://sanyuesha.com/2016/05/28/python-module-path-find/" target="_blank" rel="noopener">三月沙-如何理解 Python 的模块查找原理与方式</a> 本文内容主要参考，但是该文章中提到的<code>os</code>属于<code>built-in moulde</code>的理解是有误的，本文中修正了理解。</li><li><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c10/p01_make_hierarchical_package_of_modules.html" target="_blank" rel="noopener">构建一个模块的层级包</a></li><li><a href="https://docs.python.org/3/library/" target="_blank" rel="noopener">The Python Standard Library</a></li><li><a href="https://medium.com/pyladies-taiwan/python-%E7%9A%84-import-%E9%99%B7%E9%98%B1-3538e74f57e3" target="_blank" rel="noopener">Medium-Python 的 Import 陷阱</a></li><li><a href="https://blog.csdn.net/liang19890820/article/details/76219560" target="_blank" rel="noopener">CSDN-Python 模块搜索路径</a> 提交了 <code>PYTHONPATH</code> 这个环境变量的作用</li><li><a href="http://effbot.org/librarybook/sys.htm" target="_blank" rel="noopener">librarybook-The sys module</a></li><li><a href="https://docs.python.org/3.7/library/sys.html" target="_blank" rel="noopener">官宣-System-specific parameters and functions</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/6d9475f6ly1fy7u3g3083j20hs08w754.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://michael728.github.io/categories/Python/"/>
    
    
  </entry>
  
</feed>
