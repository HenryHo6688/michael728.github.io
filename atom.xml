<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Michael翔</title>
  
  <subtitle>因上努力，果上随缘！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://michael728.github.io/"/>
  <updated>2020-03-05T14:20:44.463Z</updated>
  <id>https://michael728.github.io/</id>
  
  <author>
    <name>Michael翔</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac 10.15 Catalina 开机登录壁纸图片修改</title>
    <link href="https://michael728.github.io/2020/03/04/tools-mac-change-wallpaper-login/"/>
    <id>https://michael728.github.io/2020/03/04/tools-mac-change-wallpaper-login/</id>
    <published>2020-03-04T21:36:50.000Z</published>
    <updated>2020-03-05T14:20:44.463Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/zyu2MS.png" alt="zyu2MS"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了修改 macOS 10.15 Catalina 系统开机时的登录界面的壁纸，折腾了好一会儿才搞定，没想到这么麻烦，记录一贴，方便有需求的小伙伴借鉴 </p><a id="more"></a><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>关闭 SIP：重启 Mac，在开机时立马按住 <code>Command+R</code> 键，直到看到苹果的logo-》选择语言-》选择账户-》下一步进入macOS实用工具的界面，然后点击上方菜单栏的「实用工具」下的「终端」，输入下面的命令：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrutil disable</span><br></pre></td></tr></table></figure><ul><li>将准备好的壁纸下载到「下载」目录下，当然，你也可以放到其他目录下，但是本文以该目录下的壁纸文件作为操作路径。将壁纸重命名为 <code>Catalina.heic</code></li><li>打开访达，在菜单栏上点击「前往 - 前往文件夹」，或者使用快捷键 <code>Command+Shift+G</code> 打开「前往文件夹」，路径地址 <code>/System/Library/Desktop Pictures</code>。默认的登录时的壁纸就位于该文件夹下。使用命令行操作比较简单：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 这个命令是把分区 mount 成可写模式。这个命令在系统重启后失效</span><br><span class="line">sudo mount -uw /</span><br><span class="line"><span class="meta">#</span> 备份原来的默认壁纸</span><br><span class="line">sudo cp /System/Library/Desktop\ Pictures/Catalina.heic ~/Downloads/Catalina.old.heic</span><br><span class="line"><span class="meta">#</span> 将下载后重命名好的壁纸替换掉默认路径下的壁纸</span><br><span class="line">sudo cp -f ~/Downloads/Catalina.heic /System/Library/Desktop\ Pictures/Catalina.heic</span><br><span class="line"><span class="meta">#</span> 执行了下面这行关键操作之后，开机壁纸才最最终生效！查了很多资料都没提到这个</span><br><span class="line">diskutil apfs updatePreboot /</span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li>现在网上很多 Mojave 系统的教程，路径说的是 <code>/Library/Desktop Pictures/</code>，其实已经不适用了。</li><li><code>diskutil apfs updatePreboot /</code> 这个命令执行之后，开机壁纸才最终成功修改成功，很多旧教程中没有提到</li><li>修改完毕之后，建议按照步骤一的方式开启 SIP，命令行是：<code>csrutil enable</code></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/SummerCloudXT/article/details/103753626?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">CSDN——MMac OS 10.15 修改登录壁纸</a></li><li><a href="https://blog.csdn.net/Mr_BJL/article/details/102780325?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">CSDN——MAC：Read-only file system问题</a></li><li><a href="https://sspai.com/post/55066" target="_blank" rel="noopener">少数派——macOS 开启或关闭 SIP</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/michael_xiang/images/raw/master/uPic/zyu2MS.png&quot; alt=&quot;zyu2MS&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;为了修改 macOS 10.15 Catalina 系统开机时的登录界面的壁纸，折腾了好一会儿才搞定，没想到这么麻烦，记录一贴，方便有需求的小伙伴借鉴 &lt;/p&gt;
    
    </summary>
    
      <category term="ToolsDaily" scheme="https://michael728.github.io/categories/ToolsDaily/"/>
    
    
      <category term="Tools" scheme="https://michael728.github.io/tags/Tools/"/>
    
      <category term="Mac" scheme="https://michael728.github.io/tags/Mac/"/>
    
      <category term="壁纸" scheme="https://michael728.github.io/tags/%E5%A3%81%E7%BA%B8/"/>
    
  </entry>
  
  <entry>
    <title>Linux 必备命令利器 —— sed</title>
    <link href="https://michael728.github.io/2020/02/18/linux-command-sed/"/>
    <id>https://michael728.github.io/2020/02/18/linux-command-sed/</id>
    <published>2020-02-18T22:15:28.000Z</published>
    <updated>2020-03-05T14:20:44.459Z</updated>
    
    <content type="html"><![CDATA[<p>虽然之前对常用的 Linux 命令有过一个总结 <a href="https://michael728.github.io/2018/07/05/linux-useful-commands-in-work/">工作中常用的 Linux 命令</a>，但是有一些命令的用法确实值得为她单独写一篇总结。今天我们就来认识一下 sed。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>sed</code> 是一个流编辑器（<code>stream editor</code>，或许，<code>sed</code> 缩写的含义就是这个）。流编辑器用于对输入流（文件或来自管道的输入）执行基本的文本转换。 sed在管道中过滤文本的能力，这使其与其他类型的编辑器特别有区别。</p><h2 id="地址定界符"><a href="#地址定界符" class="headerlink" title="地址定界符"></a>地址定界符</h2><p>今天看到一个 <code>sed</code> 的写法，<code>sed &#39;s#^key##&#39;</code>，一开始没看明白，因为之前都是类似 <code>sed &#39;s/^//&#39;</code> 这样写的。后来查了资料才发现，<code>/、#、@</code> 都是地址定界符，效果是一样的。</p><h2 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@607bac0e5f20 demo]# sed -i '1i demo learn' demo.txt</span><br><span class="line">[root@607bac0e5f20 demo]# cat demo.txt</span><br><span class="line">demo learn</span><br><span class="line">hello michael</span><br><span class="line">hello qq</span><br><span class="line">[root@607bac0e5f20 demo]# sed -i '2a sunny smile' demo.txt</span><br><span class="line">[root@607bac0e5f20 demo]# cat demo.txt</span><br><span class="line">sed demo learn</span><br><span class="line">hello michael</span><br><span class="line">sunny smile</span><br><span class="line">hello qq</span><br><span class="line">[root@607bac0e5f20 demo]# sed '$a end' demo.txt</span><br><span class="line">sed demo learn</span><br><span class="line">hello michael</span><br><span class="line">sunny smile</span><br><span class="line">hello qq</span><br><span class="line">end</span><br><span class="line">[root@607bac0e5f20 demo]# cat demo.txt</span><br><span class="line">sed demo learn</span><br><span class="line">hello michael</span><br><span class="line">sunny smile</span><br><span class="line">hello qq</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>-i</code> 参数加上之后，会去「就地」修改 <code>demo.txt</code> 这个文件，不加的话，<code>demo.txt</code> 的内容不会被修改； </li><li><code>1i</code> 表示文件第1行内容加上内容，<code>i</code> 效果是读取第一行之前增加 <code>include</code> 记录。有点 <code>VIM</code> 的 <code>i</code> 的效果；</li><li><code>2a</code> 表示文件第2行捏偶人后面加上内容，<code>a</code> 效果就是读取此行之后增加 <code>append</code> 记录。优点 <code>VIM</code> 的 <code>a</code> 的效果；</li><li><code>$</code> 表示文件尾，在最后一行增加，则可用 <code>$a</code> 表示；</li></ul><p>如果需要在匹配的地方增加一行，可以：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@607bac0e5f20 demo]# sed -i '/michael/i michael is michael' demo.txt</span><br><span class="line">[root@607bac0e5f20 demo]# cat demo.txt</span><br><span class="line">sed demo learn</span><br><span class="line">michael is michael</span><br><span class="line">hello michael</span><br><span class="line">sunny smile</span><br><span class="line">hello qq</span><br></pre></td></tr></table></figure></p><p>说明：</p><ul><li>上面这里的 <code>/michael/i</code> 这里的 <code>i</code> 当然也可以换成 <code>a</code>，那么，插入的位置会有不同；</li><li>如果插入的行以空格开头，可用 <code>\</code> 来转义这个空格</li><li>如果多行都满足匹配条件，那么就会多出插入内容；</li><li>如果插入的内容要换行，可用 <code>\n</code> 表示换行符，可以实现插入2行的效果</li></ul><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><p>删除和增加差不多，只需要把 <code>i</code> 或 <code>a</code> 替换为 <code>d</code>。</p><p>示例文本内容如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@607bac0e5f20 demo]# cat -n demo.txt</span><br><span class="line">     1sed demo learn</span><br><span class="line">     2michael is michael</span><br><span class="line">     3hello michael</span><br><span class="line">     4sunny smile</span><br><span class="line">     5hello qq</span><br></pre></td></tr></table></figure></p><p>把第1行删除：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@607bac0e5f20 demo]# sed '1d' demo.txt</span><br><span class="line">michael is michael</span><br><span class="line">hello michael</span><br><span class="line">sunny smile</span><br><span class="line">hello qq</span><br></pre></td></tr></table></figure></p><p>将和 <code>michael</code> 匹配的行删除：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@607bac0e5f20 demo]# sed '/michael/d' demo.txt</span><br><span class="line">sed demo learn</span><br><span class="line">sunny smile</span><br><span class="line">hello qq</span><br></pre></td></tr></table></figure></p><p>将 <code>smile</code> 匹配行和其下一行内容删除：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@607bac0e5f20 demo]# sed '/smile/&#123;N;d&#125;' demo.txt</span><br><span class="line">sed demo learn</span><br><span class="line">michael is michael</span><br><span class="line">hello michael</span><br></pre></td></tr></table></figure></p><p>说明：</p><ul><li>这里的 <code>N</code> 表示 <code>next line</code> 的意思。</li></ul><p>如果不想删除 <code>smile</code> 这行，仅仅是删除 <code>smile</code> 匹配行的下一行呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@607bac0e5f20 demo]# sed '/smile/&#123;N;s/\n.*//&#125;' demo.txt</span><br><span class="line">sed demo learn</span><br><span class="line">michael is michael</span><br><span class="line">hello michael</span><br><span class="line">sunny smile</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>s/\n.*//</code> 这里表示匹配了下一行的内容，然后用空字符替换掉了这一行，即实现了删除下一行的效果</li></ul><h2 id="改、替换"><a href="#改、替换" class="headerlink" title="改、替换"></a>改、替换</h2><p>示例文本内容如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@607bac0e5f20 demo]# cat -n demo.txt</span><br><span class="line">     1sed demo learn</span><br><span class="line">     2michael is michael</span><br><span class="line">     3hello michael</span><br><span class="line">     4sunny smile</span><br><span class="line">     5hello wheel</span><br></pre></td></tr></table></figure></p><p>每行开头增加 <code>China,</code> 的内容：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@607bac0e5f20 demo]# sed 's/^/China,/' demo.txt</span><br><span class="line">China,sed demo learn</span><br><span class="line">China,michael is michael</span><br><span class="line">China,hello michael</span><br><span class="line">China,sunny smile</span><br><span class="line">China,hello wheel</span><br></pre></td></tr></table></figure></p><p>说明：</p><ul><li><code>s</code> 表示 <code>substitute</code>，替换的意思；</li><li><code>^</code> 表示一行的开头，行尾用 <code>$</code> 表示，又和 <code>VIM</code> 的操作一样；</li></ul><p>扩展：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\&lt; 表示词首。 如：\&lt;abc 表示以 abc 为首的詞。</span><br><span class="line">\&gt; 表示词尾。 如：abc\&gt; 表示以 abc 結尾的詞。</span><br><span class="line">. 表示任何单个字符。</span><br><span class="line">* 表示某个字符出现了0次或多次。</span><br><span class="line">[ ] 字符集合。 如：[abc] 表示匹配a或b或c，还有 [a-zA-Z] 表示匹配所有的26个字符。如果其中有^表示反，如 [^a] 表示非a的字符</span><br></pre></td></tr></table></figure><p>将所有的 <code>michael</code> 替换为 `Michael：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@607bac0e5f20 demo]# sed 's/michael/Michael/g' demo.txt</span><br><span class="line">sed demo learn</span><br><span class="line">Michael is Michael</span><br><span class="line">hello Michael</span><br><span class="line">sunny smile</span><br><span class="line">hello wheel</span><br></pre></td></tr></table></figure></p><p>说明：</p><ul><li><code>g</code> 代表整行范围内的所有匹配全部替换，如果不加，那么只会匹配每一行第一个匹配的内容，比如，文本第二行，有两个 <code>michael</code>，如果不加 <code>g</code>，那么，第二个 <code>michael</code> 将不会 -&gt; <code>Michael</code>。如果用 <code>2</code> 的话，则表示只替换第 2 个匹配项。还可以用 <code>i</code> 忽略大小写</li></ul><p>如果想让匹配的内容后面加上指定字符呢，比如，上面文本中， <code>el</code> 匹配的后面加上 <code>-dev</code> 的字符：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@607bac0e5f20 demo]# sed 's/el/&amp;-dev/g' demo.txt</span><br><span class="line">sed demo learn</span><br><span class="line">michael-dev is michael-dev</span><br><span class="line">hel-devlo michael-dev</span><br><span class="line">sunny smile</span><br><span class="line">hel-devlo wheel-dev</span><br><span class="line">[root@607bac0e5f20 demo]# sed -r 's/(el)/\1-dev/g' demo.txt</span><br><span class="line">sed demo learn</span><br><span class="line">michael-dev is michael-dev</span><br><span class="line">hel-devlo michael-dev</span><br><span class="line">sunny smile</span><br><span class="line">hel-devlo wheel-dev</span><br></pre></td></tr></table></figure></p><p>说明：</p><ul><li>第一种方法中，<code>&amp;</code> 表示匹配上的内容；</li><li>第二种方法，<code>-r</code> 表示扩展的正则表达式，圆括号表示分组，第一个圆括号是第一组，替换的时候则用 <code>\1</code> 表示，一次类推；</li></ul><p>将2-3行的 <code>michael</code> 替换为 <code>xiang</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@607bac0e5f20 demo]# sed '2,3s/michael/xiang/g' demo.txt</span><br><span class="line">sed demo learn</span><br><span class="line">xiang is xiang</span><br><span class="line">hello xiang</span><br><span class="line">sunny smile</span><br><span class="line">hello wheel</span><br></pre></td></tr></table></figure><p>将第2行的内容替换为 <code>hello mike</code>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@607bac0e5f20 demo]# sed '2s/.*/hello mike/g' demo.txt</span><br><span class="line">sed demo learn</span><br><span class="line">hello mike</span><br><span class="line">hello michael</span><br><span class="line">sunny smile</span><br><span class="line">hello wheel</span><br></pre></td></tr></table></figure></p><p>使用变量的值用于替换的表达式中，需要用<strong>双引号</strong>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@607bac0e5f20 demo]# name=Michael</span><br><span class="line">[root@607bac0e5f20 demo]# echo $name</span><br><span class="line">Michael</span><br><span class="line">[root@607bac0e5f20 demo]# sed "s/wheel/$&#123;name&#125;/g" demo.txt</span><br><span class="line">sed demo learn</span><br><span class="line">michael is michael</span><br><span class="line">hello michael</span><br><span class="line">sunny smile</span><br><span class="line">hello Michael</span><br></pre></td></tr></table></figure></p><p>说明：</p><ul><li>如果不用双引号，那么，文本最后一行将会是这样的 <code>hello ${name}</code>;</li></ul><p>删除所有的符号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@607bac0e5f20 demo]# cat demo.txt</span><br><span class="line">First, sed demo learn</span><br><span class="line">Second, michael is michael</span><br><span class="line">Third, hello michael</span><br><span class="line">Fourth, sunny smile</span><br><span class="line">Fifth, hello wheel</span><br><span class="line">[root@607bac0e5f20 demo]# sed 's/[[:punct:]]//g' demo.txt</span><br><span class="line">First sed demo learn</span><br><span class="line">Second michael is michael</span><br><span class="line">Third hello michael</span><br><span class="line">Fourth sunny smile</span><br><span class="line">Fifth hello wheel</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>[[:punct:]]</code> 是正则表达式中预先定义的子字符类（<code>character classes</code>），代表所有的标点符号。sed 支持的<a href="http://www.gnu.org/software/grep/manual/html_node/Character-Classes-and-Bracket-Expressions.html" target="_blank" rel="noopener">子字符类</a>如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">:alnum:]：[0-9A-Za-z]</span><br><span class="line">[:alpha:]：[A-Za-z]</span><br><span class="line">[:blank:]：空格和TAB</span><br><span class="line">[:cntrl:]：控制字符（Control characters），ASCII码为000~037和177 (DEL)</span><br><span class="line">[:digit:]：[0-9]</span><br><span class="line">[:graph:]：[:alnum:]和[:punct:]</span><br><span class="line">[:lower:]：[a-z]</span><br><span class="line">[:print:]：[:alnum:]、[:punct:]和空格</span><br><span class="line">[:punct:]：符号 ! “ # $ % &amp; ‘ ( ) * + , - . / : ; &lt; = &gt; ? @ [ \ ] ^ _ ` &#123; | &#125; ~</span><br><span class="line">[:space:]：[:blank:]和回车、换行等</span><br><span class="line">[:upper:]：[A-Z]</span><br><span class="line">[:xdigit:]：16进制 [0-9A-Fa-f]</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.gnu.org/software/sed/manual/sed.html" target="_blank" rel="noopener">官宣-sed, a stream editor</a> 权威文档</li><li><a href="https://coolshell.cn/articles/9104.html" target="_blank" rel="noopener">CoolShell-SED 简明教程</a></li><li><a href="http://qinghua.github.io/sed/" target="_blank" rel="noopener">看例子学sed</a></li><li><a href="https://github.com/mylxsw/growing-up/blob/master/doc/%E4%B8%89%E5%8D%81%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9ASED.md" target="_blank" rel="noopener">growing-up/doc/三十分钟学会SED.md</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然之前对常用的 Linux 命令有过一个总结 &lt;a href=&quot;https://michael728.github.io/2018/07/05/linux-useful-commands-in-work/&quot;&gt;工作中常用的 Linux 命令&lt;/a&gt;，但是有一些命令的用法确实值得为她单独写一篇总结。今天我们就来认识一下 sed。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://michael728.github.io/categories/Linux/"/>
    
    
      <category term="command" scheme="https://michael728.github.io/tags/command/"/>
    
      <category term="linux" scheme="https://michael728.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 规划</title>
    <link href="https://michael728.github.io/2020/01/05/plan-2020/"/>
    <id>https://michael728.github.io/2020/01/05/plan-2020/</id>
    <published>2020-01-05T22:00:00.000Z</published>
    <updated>2020-03-05T14:20:44.459Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/michael_xiang/images/raw/master/规划-plan-计划.jpg" alt></p><p><a href="https://docs.python-guide.org/writing/reading/" target="_blank" rel="noopener">Reading Great Code</a> 文章中提到了，要想变成更优秀的程序员，需要去阅读、理解和欣赏优秀的代码。可见，阅读的重要性。</p><a id="more"></a><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>2019 工作上：转型</p><p>2019 年，由部门内的构建小组进入到了部署小组，真是 CICD 全流程体验了。技术栈也由 Python 变为了 Java。『转型』的难点其实往往不是技术的困扰，更多的是业务类型的差异，一切都要从零开始！很庆幸，自己适应过来了……</p><p>2019 生活：今年的国庆和媳妇儿一起去日本关西地区玩了一周。印象深刻，不虚此行。深深地感觉到，国内一二线城市虽然可能硬件设施、基建上面已经追赶上了发达国家，但是素质、职业精神等『看不见』的地方还有很长一条道路要走。</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/道顿堀-章鱼小丸子2.jpeg" alt="大阪-道顿堀"></p><p><img src="https://gitee.com/michael_xiang/images/raw/master/天保山-摩天轮2.jpeg" alt="大阪-天保山摩天轮"></p><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p><img src="https://gitee.com/michael_xiang/images/raw/master/2020 规划.jpg" alt="2020 规划"></p><p>OKR 的核心：制定一个较长期的目标，并且将目标分解成为一些关键的结果</p><ul><li>O：Objective 目标</li><li>KR：Key Result 关键结果</li></ul><p>参考：</p><ul><li><a href="http://blog.devtang.com/2018/11/22/okr-introduction/" target="_blank" rel="noopener">OKR 工作法简介</a></li></ul><p>PS：规划的脑图采用 <a href="https://www.processon.com/i/55ddb6bae4b04fe84c504c5f" target="_blank" rel="noopener">ProcessOn</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/michael_xiang/images/raw/master/规划-plan-计划.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.python-guide.org/writing/reading/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Reading Great Code&lt;/a&gt; 文章中提到了，要想变成更优秀的程序员，需要去阅读、理解和欣赏优秀的代码。可见，阅读的重要性。&lt;/p&gt;
    
    </summary>
    
      <category term="规划" scheme="https://michael728.github.io/categories/%E8%A7%84%E5%88%92/"/>
    
    
      <category term="总结" scheme="https://michael728.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="规划" scheme="https://michael728.github.io/tags/%E8%A7%84%E5%88%92/"/>
    
      <category term="阅读" scheme="https://michael728.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Maven 基础知识</title>
    <link href="https://michael728.github.io/2020/01/05/java-tools-maven/"/>
    <id>https://michael728.github.io/2020/01/05/java-tools-maven/</id>
    <published>2020-01-05T21:49:10.000Z</published>
    <updated>2020-03-05T14:20:44.459Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/michael_xiang/images/raw/master/dLVeb2.jpg" alt="Maven"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Maven是Java项目构建工具，可以用于管理Java依赖，还可以用于编译、打包以及发布Java项目，类似于JavaScript生态系统中的NPM。</p><a id="more"></a><p>构建环节：<code>清理-编译-测试-报告-打包-部署</code></p><ul><li>清理：将编译代码前生成的内容删除</li><li>编译：将源代码编译为字节码</li><li>测试：运行单元测试用例</li><li>报告：测试程序的结果</li><li>打包：将 java 项目打成 java 包；将 Web 项目达成 war 包；</li><li>安装：将 jar 或 war 生成到 Maven 仓库中；</li><li>部署：将 jar 或 war 从 Maven 仓库中部署到 Web 服务器上运行；</li></ul><h2 id="安装maven"><a href="#安装maven" class="headerlink" title="安装maven"></a>安装maven</h2><p><a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">官方安装包</a>，直接下载二进制包，我使用的是 <code>apach-maven-3.6.2-bin.tar.gz</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">weget http://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.2/binaries/apache-maven-3.6.2-bin.tar.gz</span><br><span class="line">tar xvf apache-maven-3.6.2-bin.tar.gz -C ~/opt</span><br><span class="line">echo &quot;export PATH=$PATH:/Users/michael/opt/apache-maven-3.6.2/bin&quot; &gt;&gt; ~/.zshrc</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><p>到此，Mac 环境的 maven 的就已经安装好了，检测：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn --version</span><br></pre></td></tr></table></figure><p>来源 <a href="https://github.com/Michael728/my-config-files/tree/master/maven" target="_blank" rel="noopener">my-config-files/maven/</a></p><h2 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h2><h3 id="settings-xml文件"><a href="#settings-xml文件" class="headerlink" title="settings.xml文件"></a>settings.xml文件</h3><p>可以定义本地仓库的实际路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span><br></pre></td></tr></table></figure><p>Maven 镜像源设置，第一个 mirror 才会生效，其他的只是放这儿，后期可以将某个调整至第一个，使其生效，提高下载速度和稳定性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://blog.csdn.net/sayyy/article/details/80447757 --&gt;</span><br><span class="line">    &lt;mirror&gt;</span><br><span class="line">      &lt;!--This sends everything else to /public --&gt;</span><br><span class="line">      &lt;id&gt;nexus&lt;/id&gt;</span><br><span class="line">      &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span><br><span class="line">      &lt;url&gt;https://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">    &lt;/mirror&gt;</span><br><span class="line">    &lt;mirror&gt;</span><br><span class="line">      &lt;!--This is used to direct the public snapshots repo in the</span><br><span class="line">          profile below over to a different nexus group --&gt;</span><br><span class="line">      &lt;id&gt;nexus-public-snapshots&lt;/id&gt;</span><br><span class="line">      &lt;mirrorOf&gt;public-snapshots&lt;/mirrorOf&gt;</span><br><span class="line">      &lt;url&gt;https://maven.aliyun.com/nexus/content/repositories/snapshots/&lt;/url&gt;</span><br><span class="line">    &lt;/mirror&gt;</span><br><span class="line">&lt;!-- https://mirrors.huaweicloud.com/ --&gt;</span><br><span class="line">&lt;!-- https://bbs.huaweicloud.com/forum/forum.php?mod=viewthread&amp;tid=1779 --&gt;</span><br><span class="line">    &lt;mirror&gt;</span><br><span class="line">        &lt;id&gt;huaweicloud&lt;/id&gt;</span><br><span class="line">        &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span><br><span class="line">        &lt;url&gt;https://mirrors.huaweicloud.com/repository/maven/&lt;/url&gt;</span><br><span class="line">    &lt;/mirror&gt;</span><br></pre></td></tr></table></figure><p>注：<code>&lt; mirrorOf&gt;</code>可以设置为哪个中央仓库做镜像，为名为“central”的中央仓库做镜像，写作<code>&lt; mirrorOf&gt;central&lt; /mirrorOf&gt;</code>;为所有中央仓库做镜像，写作<code>&lt; mirrorOf&gt;*&lt; /mirrorOf&gt;</code>。Maven默认中央仓库的id 为 central。id是唯一的。 </p><p>重要：除非你有把握，否则不建议使用<code>&lt; mirrorOf&gt;*&lt; /mirrorOf&gt;</code>的方式。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fyq48ytbe9j30r8085t9z.jpg" alt></p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fyq49ym1mqj30ls08zdhe.jpg" alt></p><p>参考：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/28133184" target="_blank" rel="noopener">IntellJ IDEA配置Maven以及修改默认Repository</a></li></ul><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><p><code>pom.xml</code>中，<code>&lt;project&gt;&lt;/project&gt;</code>为最外层的标签；</p><p><code>&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</code>定义了所使用的POM版本。这2个标签基本上是不变的。</p><p><code>groupId</code>、<code>artifactId</code> 与 <code>version</code> 一起则定义了模块的坐标( <code>Coordinates</code> )，每个公共模块的坐标应该是唯一的：</p><ul><li><code>groupId</code>：组织名称，通常是把域名反过来，例如 <code>com.fundebug</code></li><li><code>artifactId</code>：模块名称，比如一个微服务的项目名称，例如 <code>fundebug-java</code></li><li><code>version</code>：模块版本，例如 <code>0.2.0</code><ul><li>通常项目版本号分为 3 段，<code>主版本号.次版本号.修订版本号</code></li><li><code>SNAPSHORT</code> 表示开发中的版本；</li><li><code>RELEASE</code> 表示一个正式发布版本，也可能没有任何后缀也表示正式版</li><li><code>M1 M2 ...</code>  M 表示里程碑，即将发布；</li><li><code>RC( Release Candicate)</code> 发布候选</li><li><code>GA(General availability)</code> 基本可用版本</li><li><code>SNAPSHORT&lt;M1&lt;M2&lt;...&lt;RC&lt;GA&lt;RELEASE</code></li></ul></li></ul><p><a href="thttps://start.spring.io/" target="_blank" rel="noopener">SpringBoot Star</a> 中可以看到版本的一个示例：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1g1rwybm9ijj30p40a1aaw.jpg" alt></p><p><code>&lt;dependencies&gt;&lt;/dependencies&gt;</code>定义了当前项目所依赖的模块。Maven 可以根据 <code>&lt;dependency&gt;&lt;/dependency&gt;</code> 中定义的坐标，自动下载所依赖的模块。在 MacBook 上，Maven 将下载的模块缓存在 <code>$HOME/.m2/</code> 目录。</p><p>参考：</p><ul><li><a href="https://blog.fundebug.com/2019/01/07/maven-tutorial/" target="_blank" rel="noopener">fundebug-Maven入门教程</a> 推荐</li></ul><h2 id="Maven-常用命令"><a href="#Maven-常用命令" class="headerlink" title="Maven 常用命令"></a>Maven 常用命令</h2><ul><li><code>mvn compile</code> 编译 Maven 工程，生成一些 <code>class</code> 文件和配置文件；</li><li><code>mvn package</code> 编译并打包，根据 <code>pom.xml</code> 中元素 <code>packaging</code> 是 <code>jar</code> 还是 <code>war</code> 进行打包。</li><li><code>mvn install</code> 打包并安装到本地仓库。比如 <code>env-service</code> 服务可以安装到本地，<code>deploy-service</code> 服务可以通过项目在本地引用到；</li><li><code>mvn deploy</code> 同 <code>install</code>，但打包并安装到远程仓库；</li><li><code>mvn clean</code> 删除 target 目录；</li></ul><p>最近项目中用来打包生成 <code>jar</code> 包的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure><p>会在同目录下生成一个 <code>target</code> 目录，<code>jar</code> 包就在该子目录下；</p><p>同时，另外一个项目是 gradle 写的，类似命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle -x test build</span><br></pre></td></tr></table></figure><p>跳过测试阶段，生成的 jar 包在 build 的子目录中；</p><ul><li><a href="https://www.journaldev.com/8396/gradle-vs-maven" target="_blank" rel="noopener">Gradle vs Maven</a> 推荐</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/michael_xiang/images/raw/master/dLVeb2.jpg&quot; alt=&quot;Maven&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Maven是Java项目构建工具，可以用于管理Java依赖，还可以用于编译、打包以及发布Java项目，类似于JavaScript生态系统中的NPM。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://michael728.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://michael728.github.io/tags/Java/"/>
    
      <category term="Maven" scheme="https://michael728.github.io/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>用英语做 Presentation 的常用词汇和句型</title>
    <link href="https://michael728.github.io/2019/11/24/english-presentation-words/"/>
    <id>https://michael728.github.io/2019/11/24/english-presentation-words/</id>
    <published>2019-11-24T23:30:05.000Z</published>
    <updated>2020-03-05T14:20:44.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开场"><a href="#开场" class="headerlink" title="开场"></a>开场</h2><ul><li><code>hello everyone I&#39;m zhangxiang and I&#39;m very happy to be here</code></li><li><code>It&#39;s an honor to have the opportunity to address such a distinguished audience.</code></li><li><code>Good morning, eyeryone. I appreciate the opportunity to present of making this presentation</code></li><li><code>I&#39;m very glad to have a chance here to make a speech on the subject---Health</code></li></ul><h2 id="引出主题"><a href="#引出主题" class="headerlink" title="引出主题"></a>引出主题</h2><ul><li><code>The subject of my presentation is ……</code></li><li><code>I shall be speaking today about ……</code></li><li><code>My presentaion conserns ……</code></li></ul><h2 id="发言说明"><a href="#发言说明" class="headerlink" title="发言说明"></a>发言说明</h2><ul><li><code>My presentation will last for about ten minutes...</code></li><li><code>I know that time is short, so I intend to keep this brief.</code></li><li><code>Please feel free to interrupt me if you have questions.</code></li><li><code>There will be time for questions at the end of the presentation.</code></li></ul><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ul><li><code>My presentation is divided into three main sections.</code></li><li><code>My presentation is in three parts.</code></li><li><code>Firstly, secondly, thirdly, finally…</code></li></ul><h2 id="主体部分"><a href="#主体部分" class="headerlink" title="主体部分"></a>主体部分</h2><ul><li><code>As I said at the beginning…</code></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>in summary</code></li><li><code>in conclusion, I&#39;d like to…</code></li><li><code>To summarise, I…</code></li><li><code>I hope you have found this useful</code></li><li><code>That brings me to the end of my presentation. I&#39;ve talked about…</code></li></ul><h2 id="观众提问"><a href="#观众提问" class="headerlink" title="观众提问"></a>观众提问</h2><p>重述一下问题是个聪明的办法，可以确认你是否理解了问题，同时，给自己一些时间来思考</p><ul><li><code>That&#39;s an interesting question. How are we going to get voluntary redundancy?</code> </li><li><code>Thank you. So you would like further clarification on our strategy?</code></li></ul><p>回答完毕后，确认提问者是否满意。</p><ul><li><code>Does this answer your question?</code></li><li><code>I hope this explains the situation for you.</code></li></ul><p>如果你不知道如何作答，就说不知道。承认无知总比妄自猜测要好</p><ul><li><code>I&#39;m afraid I&#39;m unable to answer that at the moment. Perhaps I can get back to you later.</code></li><li><code>That&#39;s a very good question. However, we don&#39;t have any figures on that, so I can&#39;t give you an accurate answer.</code></li><li><code>Unfortunately, I&#39;m not the best person to answer that.</code></li></ul><h2 id="各种状况"><a href="#各种状况" class="headerlink" title="各种状况"></a>各种状况</h2><p>观众没听懂？</p><ul><li><code>Let me just say that in another way.</code></li><li><code>Put it another way, this means…</code></li></ul><h2 id="过渡词-transitions"><a href="#过渡词-transitions" class="headerlink" title="过渡词 transitions"></a>过渡词 transitions</h2><h3 id="表递进"><a href="#表递进" class="headerlink" title="表递进"></a>表递进</h3><ul><li><code>moreover</code></li><li><code>besides</code></li><li><code>furthermore</code></li><li><code>what is more</code></li><li><code>in addition</code></li><li><code>in other words</code></li></ul><p>确保观众跟上你的思路，转到下一个话题：</p><ul><li><code>The next topic/point I&#39;d like to talk about is how to ……</code></li><li><code>now we are going to talk about this point</code></li><li><code>OK/Right, I&#39;d now like to move on to…</code></li><li><code>I&#39;d like to turn to…</code> 我要转移到</li></ul><h3 id="表顺序"><a href="#表顺序" class="headerlink" title="表顺序"></a>表顺序</h3><ul><li><code>first, second, third</code></li><li><code>then/next</code></li><li><code>finally</code></li><li><code>to begin with</code></li><li><p><code>first of all</code></p><h3 id="表可能"><a href="#表可能" class="headerlink" title="表可能"></a>表可能</h3></li><li><p><code>probably</code></p></li><li><code>perhaps</code></li></ul><h3 id="展示例子"><a href="#展示例子" class="headerlink" title="展示例子"></a>展示例子</h3><ul><li><code>I&#39;ve prepared a demonstration to show how this work</code></li><li><code>Let&#39;s see a demonstration which applies waht we&#39;ve learned</code></li><li><code>As you can see…</code></li><li><code>This clearly shows …</code></li></ul><h3 id="返回之前的观点"><a href="#返回之前的观点" class="headerlink" title="返回之前的观点"></a>返回之前的观点</h3><ul><li><code>Let&#39;s return</code></li><li><code>Let&#39;s go back to ...</code></li></ul><h3 id="表比较-相似"><a href="#表比较-相似" class="headerlink" title="表比较 相似"></a>表比较 相似</h3><ul><li><code>similarly</code></li><li><code>likewise</code></li><li><code>in the same way</code></li></ul><h3 id="表转折"><a href="#表转折" class="headerlink" title="表转折"></a>表转折</h3><ul><li><code>however</code></li><li><code>on the other side</code></li><li><code>on the other hand</code></li><li><code>on the contrary</code></li></ul><h3 id="因果关系"><a href="#因果关系" class="headerlink" title="因果关系"></a>因果关系</h3><ul><li><code>therefore</code></li><li><code>as a result</code></li><li><code>consequently</code></li><li><code>for that reason</code></li></ul><h3 id="表举例"><a href="#表举例" class="headerlink" title="表举例"></a>表举例</h3><ul><li><code>in a word</code></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://language.chinadaily.com.cn/2016-04/11/content_24431931.htm" target="_blank" rel="noopener">Presentation实用表达总结</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;开场&quot;&gt;&lt;a href=&quot;#开场&quot; class=&quot;headerlink&quot; title=&quot;开场&quot;&gt;&lt;/a&gt;开场&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;hello everyone I&amp;#39;m zhangxiang and I&amp;#39;m very happy t
      
    
    </summary>
    
      <category term="Soft Skills" scheme="https://michael728.github.io/categories/Soft-Skills/"/>
    
    
      <category term="English" scheme="https://michael728.github.io/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>Mac 免费支持 Windows 可用的移动硬盘/U盘</title>
    <link href="https://michael728.github.io/2019/11/17/tools-mac-support-ntfs/"/>
    <id>https://michael728.github.io/2019/11/17/tools-mac-support-ntfs/</id>
    <published>2019-11-17T21:36:50.000Z</published>
    <updated>2020-03-05T14:20:44.463Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/michael_xiang/images/raw/master/dj-4595492_640.jpg" alt></p><blockquote class="blockquote-center"><p><a href="https://pixabay.com/photos/dj-music-turntable-jockey-volume-4595492/" target="_blank" rel="noopener">图片链接</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Windows 上的磁盘格式，默认一般都是 NTFS 格式。Mac 能够直接从 NTFS 格式的磁盘拷贝文件，但是不支持直接从 Mac 上拷贝文件到 NTFS 磁盘。</p><a id="more"></a><div class="note success no-icon">            <p>最早在 OSX 10.5的时候，OSX 其实原生就支持直接写入 NTFS 的盘的，后来由于微软的限制，把这个功能给屏蔽了，我们可以通过命令行手动打开这个选项。</p>          </div><p>这时候一般上网查到的都是推荐去购买软件.</p><ul><li><code>Paragon NTFS for Mac(¥139)</code></li><li><code>Tuxera NTFS for Mac(¥99)</code></li><li>开源免费的 <a href="https://mounty.app/" target="_blank" rel="noopener">mounty</a>-<code>brew cask install mounty</code>，但是這個免費的好像更新不頻繁了，最近一次还是 2018年9月份，现在都是2019年11月份了，最新的系統测试不OK。</li></ul><p>偶然发现有办法可以通过设置，让 Mac 免费支持 NTFS，在最新的系统 <code>macOS Catalina(10.15.1)</code>  测试 OK 🤡 </p><p>这时候有两个场景：</p><p>1.你的移动硬盘或者U盘可以格式化位 <code>ExFAT</code> 格式，因为 Windows 和 Mac 都支持这种格式。</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/0VXNij.png" alt></p><p>2.移动硬盘或者U盘上的内容比较多，不方便转移后，进行格式化，这时候，就需要通过如下的方法进行设置了。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>1.查看磁盘的 Volume Name</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diskutil list</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/michael_xiang/images/raw/master/xEKXmB.png" alt></p><p>可以看到的这个磁盘名叫做 <code>Seagate翔</code>。</p><div class="note warning no-icon">            <p>如果 Volume Name 有空格，用 <code>\040</code> 表示空格。</p>          </div><p>2.更新 <code>/etc/fstab</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/fstab</span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL=Seagate翔 none ntfs rw,auto,nobrowse</span><br></pre></td></tr></table></figure><ul><li><code>rw</code> 表示把这个分区挂载为可读写的 ntfs 格式</li><li><code>nobrowse</code> 这个代表了在 finder 里不显示这个分区，这个选项非常重要，如果不打开的话挂载是不会成功的</li></ul><p>3.将移动硬盘/USB拔出重插，然后在 Finder-&gt;前往-&gt;前往文件夹，输入：<code>/Volumes</code>，这时候可以看到我的移动硬盘，拖动它至Finder的边栏『个人收藏』，后面就可以方便打开和推出。</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/rXEzLY.png" alt></p><p>4.将磁盘快捷方式添加到桌面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /Volumes/Seagate翔 ~/Desktop/Seagate翔</span><br></pre></td></tr></table></figure><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>如果后面有其他便携硬盘设置使用，需要按照上面步骤再操作适配一下。因此，本文需要收藏好，以后还要查阅参考。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/linhai1028/article/details/79418924" target="_blank" rel="noopener">CSDN——Mac OSX 打开原生自带读写NTFS功能</a></li><li><a href="https://chad-it.github.io/2018/06/25/Mac%E5%BC%80%E5%90%AF%E5%8E%9F%E7%94%9FNTFS%E8%AF%BB%E5%86%99%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">chad——Mac开启原生NTFS读写功能</a></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li>本文地址 <a href="https://michael728.github.io/2019/11/14/tools-mac-support-ntfs/">Mac 免费支持 Windows 可用的移动硬盘/U盘</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/michael_xiang/images/raw/master/dj-4595492_640.jpg&quot; alt&gt;&lt;/p&gt;
&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://pixabay.com/photos/dj-music-turntable-jockey-volume-4595492/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图片链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Windows 上的磁盘格式，默认一般都是 NTFS 格式。Mac 能够直接从 NTFS 格式的磁盘拷贝文件，但是不支持直接从 Mac 上拷贝文件到 NTFS 磁盘。&lt;/p&gt;
    
    </summary>
    
      <category term="ToolsDaily" scheme="https://michael728.github.io/categories/ToolsDaily/"/>
    
    
      <category term="Tools" scheme="https://michael728.github.io/tags/Tools/"/>
    
      <category term="Mac" scheme="https://michael728.github.io/tags/Mac/"/>
    
      <category term="NTFS" scheme="https://michael728.github.io/tags/NTFS/"/>
    
  </entry>
  
  <entry>
    <title>neovim 安装及插键配置</title>
    <link href="https://michael728.github.io/2019/11/17/tools-vim-plugin-neovim-plug/"/>
    <id>https://michael728.github.io/2019/11/17/tools-vim-plugin-neovim-plug/</id>
    <published>2019-11-17T16:56:31.000Z</published>
    <updated>2020-03-05T14:20:44.463Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/michael_xiang/images/raw/master/v2-e5494a3e5fcf280a2be79e929b193293_1200x500.jpg" alt="neovim"></p><p>Vim 学习系列：</p><ul><li><a href="https://michael728.github.io/2018/12/02/tools-vim-basic/">Vim 基础</a></li><li><a href="https://michael728.github.io/2018/12/02/tools-vim-plugin-config/">Vim 插件及配置</a></li><li><a href="https://michael728.github.io/2019/11/17/tools-vim-plugin-neovim-plug/">neovim 安装及插键配置</a></li></ul><a id="more"></a><h2 id="安装-NeoVim"><a href="#安装-NeoVim" class="headerlink" title="安装 NeoVim"></a>安装 NeoVim</h2><p>Vim 主要开发目前就一个人，开发效率低，年久失修。为了让 Vim 有一个快速的迭代速度，neovim 应运而生。</p><p><a href="https://github.com/neovim/neovim/wiki/Installing-Neovim" target="_blank" rel="noopener">安装</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install neovim</span><br></pre></td></tr></table></figure><p>neovim 的官方配置文件在 <code>/Users/michael/.config/nvim/init.vim</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># edit ~/.zshrc</span><br><span class="line">alias vim=&apos;nvim&apos;</span><br><span class="line">alias vi=&apos;nvim&apos;</span><br></pre></td></tr></table></figure><p>检查：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvim +checkhealth</span><br></pre></td></tr></table></figure></p><p>支持 Python 语言：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install neovim --upgrade</span><br></pre></td></tr></table></figure><h2 id="插键-vim-plug"><a href="#插键-vim-plug" class="headerlink" title="插键 vim-plug"></a><a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">插键 vim-plug</a></h2><h3 id="安装-vim-plug"><a href="#安装-vim-plug" class="headerlink" title="安装 vim-plug"></a>安装 vim-plug</h3><p>插键没使用 Vundle，而是采用 vim-plug</p><ul><li>Vundle是之前Vim插件管理比较流行的工具。转向使用Vim-Plug，最大的原因还在于相比Vundle，所有的插件更新和安装都是并行的，这样比Vundle效率提升了不是一点半点。</li><li>此外，最令人心动的，是Vim-Plug的杀手级特性：按需加载控件，可以让你根据不同的需求，决定某些插件在什么时机开始加载，从而大大提升Vim/NeoVim的启动速度。</li></ul><p><a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">安装 vim-plug 的脚本</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure><h3 id="配置-vim-plug"><a href="#配置-vim-plug" class="headerlink" title="配置 vim-plug"></a>配置 vim-plug</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 将已有的 Vim 配置，用于 nvim</span><br><span class="line"># .vim 文件夹会存放插键相关内容，比如 vim-plug 的内容</span><br><span class="line">ln -s ~/.vim ~/.config/nvim</span><br><span class="line">ln -s ~/.vimrc ~/.config/nvim/init.vim</span><br></pre></td></tr></table></figure><p>常用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 安装插键</span><br><span class="line">:PlugInstall</span><br><span class="line"># 检查状态</span><br><span class="line">:PlugStatus</span><br><span class="line"># 删除插键（需要先将 ~/.config/nvim/init.vim 中注释掉相关插键）</span><br><span class="line">:PlugClean</span><br><span class="line"># 更新插键</span><br><span class="line">: PlugUpdate</span><br><span class="line"># 升级 vim-plug</span><br><span class="line">:PlugUpgrade</span><br></pre></td></tr></table></figure></p><p>将需要安装的插键写入 <code>~/.vimrc</code> 的如下命令之间，然后执行 <code>:PlugInstall</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call plug#begin()</span><br><span class="line"># 这里写上需要安装的插键</span><br><span class="line">Plug &apos;tpope/vim-sensible&apos;</span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure></p><h2 id="常用插键"><a href="#常用插键" class="headerlink" title="常用插键"></a>常用插键</h2><ul><li><a href="https://github.com/vim-airline/vim-airline" target="_blank" rel="noopener">vim-airline/vim-airline</a> 状态栏插件 vim-airine</li><li><a href="https://github.com/vim-airline/vim-airline-themes" target="_blank" rel="noopener">vim-airline/vim-airline-themes</a> 状态来主题，<a href="https://github.com/vim-airline/vim-airline/wiki/Screenshots" target="_blank" rel="noopener">预览</a></li><li><a href="https://github.com/jiangmiao/auto-pairs" target="_blank" rel="noopener">jiangmiao/auto-pairs</a> 自动引号&amp;括号补全</li></ul><blockquote><p>以引号输入为例，说明如何使用这个插件。按下 “，会自动变成双引号””，此时光标位于双引号的中间，等待插入文本，文本插入结束以后，通常我们希望把光标置于右边引号的后面继续输入，此时，再按一次 “，光标就会跳转到右边引号的后面，等待我们继续输入文本</p></blockquote><ul><li><a href="https://github.com/scrooloose/nerdtree" target="_blank" rel="noopener">scrooloose/nerdtree</a> 文件管理器 nerdtree</li></ul><blockquote><ul><li><code>:NERDTree</code> 即可打开当前编辑文件所在的目录</li><li>按住 Ctrl, 双击 w 可以在两个窗口之间切换</li><li>把光标移动到该文件，然后按 o，即可在右边窗口打开该文件</li><li>在该窗口直接按 q 即可退出</li></ul></blockquote><ul><li><a href="https://github.com/Shougo/deoplete.nvim" target="_blank" rel="noopener">Shougo/deoplete.nvim</a> 自动补全插键</li></ul><p>之前的<a href="https://michael728.github.io/2018/12/02/tools-vim-plugin-config/">文章</a>也写了一些插键的使用。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>放上我的 Vim 配置文件地址：<a href="https://github.com/Michael728/my-config-files/tree/master/vim" target="_blank" rel="noopener">my-config-files/vim/</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://cenalulu.github.io/linux/why-my-backspace-not-work-in-vim/" target="_blank" rel="noopener">Mac的VIM中delete键失效的原因和解决方案</a></li><li><a href="https://michael728.github.io/2018/12/02/tools-vim-plugin-config/">Vim 插键及配置</a></li><li><a href="https://jdhao.github.io/2018/09/05/centos_nvim_install_use_guide/" target="_blank" rel="noopener">jdhao——Linux 下 Neovim 安装与配置 Python 开发环境指南</a></li><li><a href="https://xiaozhou.net/from-vim-to-neovim-2016-05-21.html" target="_blank" rel="noopener">Timothy——从Vim到NeoVim</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/michael_xiang/images/raw/master/v2-e5494a3e5fcf280a2be79e929b193293_1200x500.jpg&quot; alt=&quot;neovim&quot;&gt;&lt;/p&gt;
&lt;p&gt;Vim 学习系列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://michael728.github.io/2018/12/02/tools-vim-basic/&quot;&gt;Vim 基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://michael728.github.io/2018/12/02/tools-vim-plugin-config/&quot;&gt;Vim 插件及配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://michael728.github.io/2019/11/17/tools-vim-plugin-neovim-plug/&quot;&gt;neovim 安装及插键配置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="ToolsDev" scheme="https://michael728.github.io/categories/ToolsDev/"/>
    
    
      <category term="Tools" scheme="https://michael728.github.io/tags/Tools/"/>
    
      <category term="Vim" scheme="https://michael728.github.io/tags/Vim/"/>
    
      <category term="neovim" scheme="https://michael728.github.io/tags/neovim/"/>
    
  </entry>
  
  <entry>
    <title>Git基础 —— Github 使用技巧</title>
    <link href="https://michael728.github.io/2019/11/14/git-github-experiance/"/>
    <id>https://michael728.github.io/2019/11/14/git-github-experiance/</id>
    <published>2019-11-14T21:21:24.000Z</published>
    <updated>2020-03-05T14:20:44.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git-基础学习系列"><a href="#Git-基础学习系列" class="headerlink" title="Git 基础学习系列"></a>Git 基础学习系列</h2><ul><li><a href="https://michael728.github.io/2019/11/14/git-install-config/">Git 基础 —— 安装 配置 别名 对象</a></li><li><a href="https://michael728.github.io/2019/11/14/git-useful-commands/">Git 基础 —— 常用命令</a></li><li><a href="https://michael728.github.io/2019/11/14/git-usage-examples/">Git 基础 —— 常见使用场景</a></li><li><a href="https://michael728.github.io/2019/11/14/git-github-experiance/">Git基础 —— Github 的使用</a></li></ul><h2 id="Github-的利用"><a href="#Github-的利用" class="headerlink" title="Github  的利用"></a>Github  的利用</h2><p><a href="https://github.com/features" target="_blank" rel="noopener">Github feature 官宣</a>，介绍了 Github 的主要特性。</p><h3 id="详细演示下怎么给一个项目发起-Pull-Request-PR"><a href="#详细演示下怎么给一个项目发起-Pull-Request-PR" class="headerlink" title="详细演示下怎么给一个项目发起 Pull Request(PR)"></a>详细演示下怎么给一个项目发起 Pull Request(PR)</h3><ul><li>第一步，找到你想发起 PR 的项目，点击右上角的 Fork 按钮，然后该项目就出现在了你自己账号的 Repository 里。</li><li>第二步，把fork的项目 clone 到本地，然后修改的 bug 也好，想要新增的功能也好，总之把自己做的代码改动开发完，接着，把自己做的代码改动 push 到 你自己的 GitHub 上去。</li><li>第三步，点击你 Fork 过来的项目主页的 Pull requests 页面，点击右上角的New pull request。</li></ul><p>页面自动会比较该项目与原有项目的不同之处，最顶部声明了是源仓库的分支与你fork过来的分支的对比。同样的我写好标题和描述，然后我们点击中间的 Create pull request 按钮，至此我们就成功给该项目提交了一个 PR。</p><p>然后就等着项目原作者 review 你的代码，并且决定会不会接受你的 PR，如果接受，那么恭喜你，你已经是该项目的贡献者之一了。</p><h2 id="发现好用的开源项目"><a href="#发现好用的开源项目" class="headerlink" title="发现好用的开源项目"></a>发现好用的开源项目</h2><p>GitHub 其中一个最重要的作用就是发现全世界最优秀的开源项目，你没事的时候刷刷微博、知乎，人家没事的时候刷刷 GitHub ，看看最近有哪些流行的项目，久而久之，这差距就越来越大，那么如何发现优秀的开源项目呢？</p><ol><li>关注一些活跃的大牛</li><li>Explore菜单下的Trending，看到最近的一些热门开源项目，很多人主动获取开源项目的最好的途径，可以选择“当天热门”，“一周之内热门”和“一月之内热门”来查看，并且，可以分语言来查看。</li><li>Search，按照Most Stars来筛选。</li></ol><p>GitHub 的 Search 还有一些小技巧：</p><ul><li>使用高级搜索的功能，搜索语法见 <a href="https://help.github.com/articles/understanding-the-search-syntax/" target="_blank" rel="noopener">Understanding the search syntax</a>；</li><li>使用 <code>in:readme</code> 可以扩大搜索的范围，否则直接输入输入搜索文字，只在仓库名、描述的内容中去匹配搜索；</li></ul><p>搜索词示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git 最好 学习 资料 in:readme stars:&gt;2000</span><br><span class="line"># 搜仓库里带有 gitlab-ci.yml 的仓库，同时文件里有 after_script + stge:deploy 内容，根据代码内容搜索</span><br><span class="line">&apos;after_script&apos;+&apos;stage: deploy&apos;  filename:.gitlab-ci.yml</span><br></pre></td></tr></table></figure></p><p>除此之外，有些人如果习惯用 Google 进行搜索，那么想搜索 GitHub 上的结果，不妨前面加 GitHub 关键字就ok了，比如我在 google 里输入 GitHub android http ，每个关键字用空格隔开。</p><h2 id="怎么选择团队适合的工作流"><a href="#怎么选择团队适合的工作流" class="headerlink" title="怎么选择团队适合的工作流"></a>怎么选择团队适合的工作流</h2><h3 id="主干开发"><a href="#主干开发" class="headerlink" title="主干开发"></a>主干开发</h3><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fzdcgk1dayj31au0ngk1q.jpg" alt><br>Facebook 采用主干开发模式。如果没有质量保证的话，commit  容易出现错误，要能快速迭代，才能采用主干开发模式。</p><h3 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h3><p>流程太过复杂，互联公司不太常见，和主干开发模式不同，它类似于特性分支模式。<br><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzdh71wtcuj315f0u0h21.jpg" alt><br>Github Flow：<br>特性分支开发测试完毕，回合到主干，既可以立即发布了<br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fzdh98wrzbj31cm0netis.jpg" alt></p><h3 id="Gitlab-Flow-带生产分支"><a href="#Gitlab-Flow-带生产分支" class="headerlink" title="Gitlab Flow 带生产分支"></a>Gitlab Flow 带生产分支</h3><p> master 分支用于持续集成的，特性分支会集成到 master，production 分支用于发布的。<img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzdhaoty4hj314a0so7bk.jpg" alt><br> Gitlab Flow 带环境分支：<br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fzdhd1gnivj31840t0gum.jpg" alt><br>Gitlab Flow 带发布分支：<br>因为硬件有多个版本，为了适配这些硬件，同一个时间点，可能会针对硬件发布多个版本<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzdhefrrshj315b0u0aiv.jpg" alt></p><h2 id="如何挑选合适的分支集成策略"><a href="#如何挑选合适的分支集成策略" class="headerlink" title="如何挑选合适的分支集成策略"></a>如何挑选合适的分支集成策略</h2><p>Github &gt; Insights &gt; Network 可以看到版本演进;</p><p>Settings 中，有一个 <code>Merge Button</code>，可以选择 MR 的方式：<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzdhmkv7nfj31560iaad5.jpg" alt><br>Github 的合并策略：</p><ul><li>allow merge commits：合入主干时，会产生一个 merge commit；</li><li>allow squash merging：相当于把你的提交会先合并成一个 commit，然后再提交，这样的话，你原来的特性分支没有变，主干分支多了一个 commit，主干也是线性演进；</li><li>allow rebase merging：主干是一个线性演进，看着很舒服，实质上就是特性分支的一个个 cherry pick  到主干上，比如特性分支上有3个 commit，那么执行之后，主干也就产生3个 commit 了，原特性分支没有变化；<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzdhzsv3llj30q50oiqex.jpg" alt><br>上面，仅仅是 Github 的 MR 策略，与 Gitlab 的策略也是有所区别的。</li></ul><blockquote><p>可以根据软件包发布时是从什么分支上发布的，分为主干开发和分支开发，从主干分支上出包发布，就叫主干开发，从特性分支上出包的，就叫分支开发。</p></blockquote><h2 id="启用-issue-跟踪需求和任务"><a href="#启用-issue-跟踪需求和任务" class="headerlink" title="启用 issue 跟踪需求和任务"></a>启用 issue 跟踪需求和任务</h2><p>仓库的 settings 页面，有启用 issue 的按钮，默认是勾选的，可以 <code>set up template</code>，可以选择预设的模板。模板文件是放在仓库的 .github 文件夹中，可以参考 <a href="https://github.com/vuejs/vue/tree/dev/.github" target="_blank" rel="noopener">vue 项目的模板</a></p><h2 id="如何用-project-管理-issue？"><a href="#如何用-project-管理-issue？" class="headerlink" title="如何用 project 管理 issue？"></a>如何用 project 管理 issue？</h2><p>在仓库的 projects 页面可以创建 project，也是有 template 的。以后添加 issue 时，就可以选择对应的 project。</p><p>晨会过进度的时候，还是很方便直观的。后期可以通过项目看板帮我们有序的管理任务和推进。<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzekk461k7j31do0gijte.jpg" alt></p><h2 id="项目团队怎么实施-code-review"><a href="#项目团队怎么实施-code-review" class="headerlink" title="项目团队怎么实施 code review?"></a>项目团队怎么实施 code review?</h2><p>在仓库 settings branches 中添加规则，支持 <code>release*</code> 这样的规则，通配符，还可以指定 review 的其他规则，比如审核人要几个等。</p><p>通过 pull request 发起 review 的申请。</p><h2 id="福利"><a href="#福利" class="headerlink" title="福利"></a>福利</h2><p>GitHub 上影响力很大，同时又对你们很有用的项目：</p><ul><li><a href="https://github.com/EbookFoundation/free-programming-books" target="_blank" rel="noopener">free-programming-books</a>:  这个项目整理了所有跟编程相关的免费书籍，而且全球多国语言版的都有，中文版的在这里 <a href="https://github.com/EbookFoundation/free-programming-books/blob/master/free-programm" target="_blank" rel="noopener">free-programming-books-zh</a></li><li><a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">ob-my-zsh</a>:  俗话说，不会用 shell 的程序员不是真正的程序员。oh-my-zsh 毫无疑问就是目前最流行，最酷炫的 shell</li><li><a href="https://michael728.github.io/2018/03/11/tools-zsh-tutorial/">zsh+on-my-zsh配置教程指南（程序员必备）</a></li><li><a href="https://github.com/sindresorhus/awesome" target="_blank" rel="noopener">awesome</a>:  GitHub 上有各种 awesome 系列，简单来说就是这个系列搜罗整理了 GitHub 上各领域的资源大汇总，比如有 awesome-android, awesome-ios, awesome-java, awesome-python 等等等，就不截图了，你们自行去感受。</li><li><a href="https://github.com/tiimgreen/github-cheat-sheet/" target="_blank" rel="noopener">github-cheat-sheet</a>: GitHub 的使用有各种技巧，只不过基本的就够我们用了，但是如果你对 GitHub 超级感兴趣，想更多的了解 GitHub 的使用技巧，那么这个项目就刚好是你需要的，每个 GitHub 粉都应该知道这个项目。</li><li><a href="https://github.com/francistao/LearningNotes" target="_blank" rel="noopener">LearningNotes</a>：这是一份非常详细的面试资料，涉及 Android、Java、设计模式、算法等等等，你能想到的，你不能想到的基本都包含了，可以说是适应于任何准备面试的 Android 开发者，看完这个之后别说你还不知道怎么面试！</li></ul><h2 id="补充-Gitlab"><a href="#补充-Gitlab" class="headerlink" title="补充-Gitlab"></a>补充-Gitlab</h2><ul><li><a href="https://about.gitlab.com/devops-tools/" target="_blank" rel="noopener">DevOps-Tools</a></li><li><a href="https://about.gitlab.com/stages-devops-lifecycle/" target="_blank" rel="noopener">DevOps-lifecycle</a></li><li><a href="https://gitlab.com/gitlab-org/gitlab-ee/boards/338779" target="_blank" rel="noopener">Gitlab-ee/boards</a> Gitlab 的看板示例，本身企业版的开发讨论；</li><li><a href="https://gitlab.com/gitlab-org/gitlab-ee/pipelines" target="_blank" rel="noopener">Gitlab 代码集成 流水线</a> 保证集成的质量，要想跑 CI，需要在 CI/CD 中注册 Runner。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git-基础学习系列&quot;&gt;&lt;a href=&quot;#Git-基础学习系列&quot; class=&quot;headerlink&quot; title=&quot;Git 基础学习系列&quot;&gt;&lt;/a&gt;Git 基础学习系列&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://michael728.gith
      
    
    </summary>
    
      <category term="ToolsDev" scheme="https://michael728.github.io/categories/ToolsDev/"/>
    
    
      <category term="ss" scheme="https://michael728.github.io/tags/ss/"/>
    
      <category term="vps" scheme="https://michael728.github.io/tags/vps/"/>
    
  </entry>
  
  <entry>
    <title>Git 基础 —— 常见使用场景</title>
    <link href="https://michael728.github.io/2019/11/14/git-usage-examples/"/>
    <id>https://michael728.github.io/2019/11/14/git-usage-examples/</id>
    <published>2019-11-14T20:21:24.000Z</published>
    <updated>2020-03-05T14:20:44.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git-基础学习系列"><a href="#Git-基础学习系列" class="headerlink" title="Git 基础学习系列"></a>Git 基础学习系列</h2><ul><li><a href="https://michael728.github.io/2019/11/14/git-install-config/">Git 基础 —— 安装 配置 别名 对象</a></li><li><a href="https://michael728.github.io/2019/11/14/git-useful-commands/">Git 基础 —— 常用命令</a></li><li><a href="https://michael728.github.io/2019/11/14/git-usage-examples/">Git 基础 —— 常见使用场景</a></li><li><a href="https://michael728.github.io/2019/11/14/git-github-experiance/">Git基础 —— Github 的使用</a></li></ul><h2 id="突然插入-Bugifx-工作，回退工作目录"><a href="#突然插入-Bugifx-工作，回退工作目录" class="headerlink" title="突然插入 Bugifx 工作，回退工作目录"></a>突然插入 Bugifx 工作，回退工作目录</h2><ul><li><code>git stash</code> 保存所有工作内容，放到一个特殊的区域，为了避免遗忘，可以 <code>git stash save [message]</code> 保存一点提示信息；</li><li><code>git stash list</code> 查看保存列表，如 <code>stash@{2}</code> 和 <code>stash@{1}</code>，序号中数字大的代表的是较早的 stash；</li><li><code>git stash show stash@{0} -v</code> 比较当前工作目录和 stash 的内容做比较；</li><li><code>git stash clear</code> 可以清除刚刚所有保存的信息；</li></ul><p>解决完 bug，又要切回之前的状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop|apply [stash]</span><br></pre></td></tr></table></figure></p><ul><li><code>apply</code> 作用，恢复之前存放的内容，stash 列表中的内容还在；</li><li><code>pop</code> 恢复之前内容后，stash 列表中的内容就不存在了；</li></ul><p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash pop stash@&#123;2&#125;</span><br><span class="line">git stash pop = git stash pop stash@&#123;0&#125;</span><br></pre></td></tr></table></figure></p><p>我们 pop 的时候可以加具体的序号，不加序号的（缺省情况下）为 <code>stash@{0}</code>。</p><p>stash 回来是有可能发生冲突的，需要解决冲突</p><h2 id="多人单分支协作"><a href="#多人单分支协作" class="headerlink" title="多人单分支协作"></a>多人单分支协作</h2><p>有个新特性需要开发，在远端仓库新建了特性分支 <code>feature/add_gitcommand</code>，现在，团队中的多人需要基于这个分支进行协作开发。</p><h3 id="本地拉取特性分支进行开发"><a href="#本地拉取特性分支进行开发" class="headerlink" title="本地拉取特性分支进行开发"></a>本地拉取特性分支进行开发</h3><p>如果远端这个分支已有同事提交了代码，而本地还没有这个分支，需要先 fetch 远端分支到本地（本地裸仓库中会增加相关 commit 信息），才能在 <code>git branch -av</code> 中看到这个远端分支信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch github</span><br></pre></td></tr></table></figure></p><p>注意，因为我本地仓库添加了多个远端主机，此处的 <code>github</code> 是我当时 <code>git remote add</code>  时给远端主机起的别名，一般会叫 <code>origin</code>。</p><p>接着，在本地创建并切换到远端特性分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 拉取远端分支时，会自动将本地的这个分支和其关联</span><br><span class="line">git checkout -b feature/add_gitcommand github/feature/add_gitcommand</span><br></pre></td></tr></table></figure></p><p>如果直接 push 的话，往往会遇到错误。因为在你提交之前，远端分支又有了新的提交，有时候内容和你修改的地方一样，还会有冲突。只要你的提交落后了，那么不管有没有冲突，推送时都会报错：<br><img src="https://ws1.sinaimg.cn/mw690/6d9475f6ly1fzcxmhkaeqj211c09atai.jpg" alt></p><p>为了避免上面的问题，在本地开发提交之后，执行推送操作之前需要拉取远端在进行合并：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull github</span><br><span class="line">#  pull 等价于下面两个操作</span><br><span class="line">git fetch github</span><br><span class="line">git merge github/feature/add_gitcommand</span><br></pre></td></tr></table></figure></p><p><img src="https://ws1.sinaimg.cn/mw690/6d9475f6ly1fzcxqgwc5yj20to044aak.jpg" alt></p><p>发生了冲突，需要我们在推送之前先本地解决一下冲突：</p><p>查看有冲突的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">we are on feature/add__gitcommand</span><br><span class="line">we are on michael728</span><br><span class="line">=======</span><br><span class="line">we are on feature/add__gitcommand 123</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; c6fc3bc57c65f099a45b1c98b6ce2782a2c072f9</span><br></pre></td></tr></table></figure></p><p>HEAD 和 <code>=====</code> 之间的内容就是发生冲突的地方，这之间的内容是我们本地提交的内容，<code>====</code> 和 <code>&gt;&gt;&gt;&gt;&gt;</code> 之间的是远端的内容。</p><p>删除这些标记行，然后重新 <code>add</code>、<code>commit</code>，最终 <code>git push github</code>即可推送到远端特性分支了，如果只关联了一个远端仓库，那么直接<code>git push</code>即可。</p><p>什么时候会有冲突呢？<br>远端修改的地方，比如修改了第一行，而本地也修改了第一行，这时候 merge 的时候，就会发生冲突。</p><h3 id="同时变更了文件名"><a href="#同时变更了文件名" class="headerlink" title="同时变更了文件名"></a>同时变更了文件名</h3><p>某同事在他提交时，通过 <code>git mv</code> 命令重命名了一个文件，<code>index.html to index.htm</code>，并且推送到了远端仓库中。</p><p>这时候我在本地修改了 <code>index.html</code> 内容，并进行了提交，准备推送到远端。因为远端又比本地多了提交记录，所以会 <code>rejected</code>，这时候执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></p><p>执行完之后，发现本地 Git 自动帮我们也对文件进行了重命名并进行了内容的合并。</p><p>前面讲 Git 的文件存储时，说 Git 存放 blob 文件时是以文件内容来区分的，并不以文件名来区分；此处的变更文件名操作和变更文件内容的操作能够自动被 Git 处理，原因就在于 blob 文件并没有发生修改的冲突。</p><p>如果其中一个人既变更了文件名又修改了文件，同时另一个人也修改了该文件的同一位置的内容，就会被 Git 识别为冲突，而不能自动进行处理了，处理方法和下面一种情况类似，都需要手动来处理了。</p><h3 id="把同一文件修改为了不同的文件名"><a href="#把同一文件修改为了不同的文件名" class="headerlink" title="把同一文件修改为了不同的文件名"></a>把同一文件修改为了不同的文件名</h3><p>A修改了文件的文件名并进行了提交推送到了远端，B也修改了文件名，这时候也准备推送。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzd5am0p7uj31380na7ac.jpg" alt></p><p><code>diff index1.html index2.html</code> 发现两个文件内容一致，通过 <code>git status</code> 查看状态，需要自己手动进行处理。</p><h2 id="Git-集成的禁忌"><a href="#Git-集成的禁忌" class="headerlink" title="Git 集成的禁忌"></a>Git 集成的禁忌</h2><ul><li>禁止向集成分支执行 <code>git push -f</code> 操作，集成分支会丢失 commit 的；</li><li>禁止向集成分支执行变更历史的操作，公共的分支严禁拉到本地，进行 rebase 操作的，因为这也会造成丢失 commit；</li></ul><h2 id="想知道某行代码谁修改的"><a href="#想知道某行代码谁修改的" class="headerlink" title="想知道某行代码谁修改的"></a>想知道某行代码谁修改的</h2><p>阅读代码时，想知道某行代码是谁修改的？</p><ul><li><p>找到对应 <code>commit id</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame src/xxx.c</span><br></pre></td></tr></table></figure></li><li><p>查看具体提交的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show &lt;commit id&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="回退到历史版本"><a href="#回退到历史版本" class="headerlink" title="回退到历史版本"></a>回退到历史版本</h2><ul><li>查找commit id<br>通过<code>git log</code>查找想要会退到的历史版本的<code>commit id</code></li><li>本地执行回退</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 这会让工作区和暂存区都回退到这个 commit id 对应的时间点的状态</span><br><span class="line">git reset --hard [commit id]</span><br></pre></td></tr></table></figure><ul><li>强制推送<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure></li></ul><p>参考：<a href="https://www.cnblogs.com/chenfulin5/p/6732036.html" target="_blank" rel="noopener">git 远程仓库版本的回退以及git reset 几种常用方式记录</a></p><h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h2><p>将某一提交点的修改拿到当前分支上：<br><code>git cherry-pick &lt;commit id&gt;</code></p><p>这会将那次的提交与当前内容进行合并，然后生成一个新的 commit。</p><h2 id="查找-Git-仓库的活跃贡献者"><a href="#查找-Git-仓库的活跃贡献者" class="headerlink" title="查找 Git 仓库的活跃贡献者"></a>查找 Git 仓库的活跃贡献者</h2><p>输出git repo中前十位最活跃的提交者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git shortlog -s | sort -rn | head</span><br></pre></td></tr></table></figure></p><h2 id="如何将-Git-仓库备份到本地"><a href="#如何将-Git-仓库备份到本地" class="headerlink" title="如何将 Git 仓库备份到本地"></a>如何将 Git 仓库备份到本地</h2><p>常用的传输协议：<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzcai93n6yj30sh0ftwh6.jpg" alt></p><ul><li>直观区别：哑协议传输进度不可⻅；智能协议传输可⻅。</li><li>传输速度：智能协议⽐哑协议传输速度快。</li></ul><p>创建用作备份的裸仓库，通常位于远端</p><ul><li><p>哑协议克隆一个不带工作区的（bare）裸仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --bare /Users/michael/Code/Git-Geek/git_learning</span><br></pre></td></tr></table></figure></li><li><p>智能协议克隆一个裸仓库并重命名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># /Users/michael/Code/Git-Geek/666-backup/zhineng.git</span><br><span class="line">git clone --bare file:///Users/michael/Code/Git-Geek/git_learning/.git zhineng.git</span><br></pre></td></tr></table></figure></li></ul><p>为了将本地工作仓库备份到远端仓库，下面，切到之前的工作仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># /Users/michael/Code/Git-Geek/git_learning</span><br><span class="line">git remote -v # 发现没有关联的远端仓库</span><br><span class="line">git remote add zhineng file:///Users/michael/Code/Git-Geek/666-backup/zhineng.git # 发生关联了</span><br><span class="line">git push zhineng</span><br></pre></td></tr></table></figure></p><p><code>file:///Users/michael/Code/Git-Geek/666-backup/zhineng.git</code> 就是表示的远端备份仓库地址。</p><p>从远端备份仓库克隆：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone file:///Users/michael/Code/Git-Geek/666-backup/zhineng.git git_learnging_2019</span><br></pre></td></tr></table></figure></p><h2 id="从一个-Git-仓库搬迁到另外一个-Git-仓库中"><a href="#从一个-Git-仓库搬迁到另外一个-Git-仓库中" class="headerlink" title="从一个 Git 仓库搬迁到另外一个 Git 仓库中"></a>从一个 Git 仓库搬迁到另外一个 Git 仓库中</h2><ol><li>新建一个空仓库B，注意，不要勾选生成 <code>README.md</code> 文件；</li><li><code>git  clone --bare A仓库</code></li><li><code>git push  --mirror B仓库</code></li></ol><p>这种方式最方便，一次性把分支、tag、commit 记录都同步过去了</p><p>参考：</p><ul><li><a href="https://blog.csdn.net/samxx8/article/details/72329002" target="_blank" rel="noopener">从一个git仓库迁移到另外一个git仓库</a></li></ul><h2 id="本地代码库关联到另外的一个代码库"><a href="#本地代码库关联到另外的一个代码库" class="headerlink" title="本地代码库关联到另外的一个代码库"></a>本地代码库关联到另外的一个代码库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd existing_repo</span><br><span class="line">git remote rename origin old-origin</span><br><span class="line">git remote add origin ssh://git@github.com:2222/Michael/my-config-files.git</span><br><span class="line">git push -u origin --all</span><br><span class="line">git push -u origin --tags</span><br></pre></td></tr></table></figure><h2 id="仓库设置多个远端仓库"><a href="#仓库设置多个远端仓库" class="headerlink" title="仓库设置多个远端仓库"></a>仓库设置多个远端仓库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote add github git@github.com:Michael728/awesome-books-for-me.git</span><br><span class="line">git push -u github master</span><br><span class="line">git remote add gitee git@gitee.com:michael_xiang/awesome-books-for-me.git</span><br><span class="line">git push -u gitee master</span><br></pre></td></tr></table></figure><h2 id="Git-lfs-管理大文件"><a href="#Git-lfs-管理大文件" class="headerlink" title="Git lfs 管理大文件"></a>Git lfs 管理大文件</h2><p>Git LFS（Large File Storage, 大文件存储）是 Github 开发的一个 Git 的扩展，用于实现 Git 对大文件的支持。</p><p>Git LFS可以把音乐、图片、视频等指定的任意文件存在 Git 仓库之外，而在 Git 仓库中用一个占用空间 1KB 不到的文本指针来代替文件的存在。</p><p>通过把大文件存储在 Git 仓库之外，可以减小 Git 仓库本身的体积，使克隆 Git 仓库的速度加快，也使得 Git 不会因为仓库中充满大文件而损失性能。</p><p>使用细节，可以看码云的介绍：<a href="https://gitee.com/help/articles/4235#article-header0" target="_blank" rel="noopener">Git LFS 操作指南</a></p><p>常用命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 使用 Git LFS 管理指定的文件</span><br><span class="line">git lfs track "*.psd"</span><br><span class="line"><span class="meta">#</span> 查看当前使用 Git LFS 管理的匹配列表</span><br><span class="line">git lfs track</span><br><span class="line"><span class="meta">#</span> 不再使用 Git LFS 管理指定的文件</span><br><span class="line">git lfs untrack "*.psd"</span><br><span class="line"><span class="meta">#</span> 类似 git status，查看当前 Git LFS 对象的状态</span><br><span class="line">git lfs status</span><br><span class="line"><span class="meta">#</span> 枚举目前所有被 Git LFS 管理的具体文件</span><br><span class="line">git lfs ls-files</span><br></pre></td></tr></table></figure></p><h2 id="Git-FAQ"><a href="#Git-FAQ" class="headerlink" title="Git FAQ"></a>Git FAQ</h2><h3 id="git-merge和git-rebase的区别"><a href="#git-merge和git-rebase的区别" class="headerlink" title="git merge和git rebase的区别"></a>git merge和git rebase的区别</h3><p>rebase 跟 merge 的区别你们可以理解成有两个书架，你需要把两个书架的书整理到一起去，第一种做法是 merge ，比较粗鲁暴力，就直接腾出一块地方把另一个书架的书全部放进去，虽然暴力，但是这种做法你可以知道哪些书是来自另一个书架的；第二种做法就是rebase ，他会把两个书架的书先进行比较，按照购书的时间来给他重新排序，然后重新放置好，这样做的好处就是合并之后的书架看起来很有逻辑，但是你很难清晰的知道哪些书来自哪个书架的。</p><p>只能说各有好处的，不同的团队根据不同的需要以及不同的习惯来选择就好。</p><p>rebase 和 merge 的另一个区别是rebase 的冲突是一个一个解决，如果有十个冲突，先解决第一个，然后用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add -u</span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><p>继续后才会出现第二个冲突，直到所有冲突解决完，而merge 是所有的冲突都会显示出来。</p><p>另外如果rebase过程中，你想中途退出，恢复 rebase 前的代码则可以用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure><p>关于<code>git rebase</code>还有很多知识点：</p><ul><li><a href="https://www.cnblogs.com/wangiqngpei557/p/5989292.html" target="_blank" rel="noopener">聊下git rebase -i</a></li><li><a href="https://blog.csdn.net/wh_19910525/article/details/7554489" target="_blank" rel="noopener">git merge 和 git rebase 小结</a></li><li><a href="http://gitbook.liuhui998.com/4_2.html" target="_blank" rel="noopener">Git Community Book 中文版-rebase</a></li><li><a href="https://www.cnblogs.com/wangdaijun/p/5956129.html" target="_blank" rel="noopener">压缩多个Commit</a></li><li><a href="https://www.jianshu.com/p/964de879904a" target="_blank" rel="noopener">合并多个 Commit</a></li></ul><h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><ul><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-git-and-github-4/index.html?ca=drs-" target="_blank" rel="noopener">IBM-Git 进阶：比较、回滚、撤销、分支合并和冲突解决</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git-基础学习系列&quot;&gt;&lt;a href=&quot;#Git-基础学习系列&quot; class=&quot;headerlink&quot; title=&quot;Git 基础学习系列&quot;&gt;&lt;/a&gt;Git 基础学习系列&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://michael728.gith
      
    
    </summary>
    
      <category term="ToolsDev" scheme="https://michael728.github.io/categories/ToolsDev/"/>
    
    
      <category term="ss" scheme="https://michael728.github.io/tags/ss/"/>
    
      <category term="vps" scheme="https://michael728.github.io/tags/vps/"/>
    
  </entry>
  
  <entry>
    <title>Git 基础 —— 常用命令</title>
    <link href="https://michael728.github.io/2019/11/14/git-useful-commands/"/>
    <id>https://michael728.github.io/2019/11/14/git-useful-commands/</id>
    <published>2019-11-14T19:21:24.000Z</published>
    <updated>2020-03-05T14:20:44.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git-基础学习系列"><a href="#Git-基础学习系列" class="headerlink" title="Git 基础学习系列"></a>Git 基础学习系列</h2><ul><li><a href="https://michael728.github.io/2019/11/14/git-install-config/">Git 基础 —— 安装 配置 别名 对象</a></li><li><a href="https://michael728.github.io/2019/11/14/git-useful-commands/">Git 基础 —— 常用命令</a></li><li><a href="https://michael728.github.io/2019/11/14/git-usage-examples/">Git 基础 —— 常见使用场景</a></li><li><a href="https://michael728.github.io/2019/11/14/git-github-experiance/">Git基础 —— Github 的使用</a></li></ul><h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><p>创建 Git 本地仓库</p><h3 id="远端无仓库，本地无仓库，本地新建一个仓库"><a href="#远端无仓库，本地无仓库，本地新建一个仓库" class="headerlink" title="远端无仓库，本地无仓库，本地新建一个仓库"></a>远端无仓库，本地无仓库，本地新建一个仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init git_learning</span><br></pre></td></tr></table></figure><h3 id="远端有仓库，本地无仓库，拉取远端仓库到本地"><a href="#远端有仓库，本地无仓库，拉取远端仓库到本地" class="headerlink" title="远端有仓库，本地无仓库，拉取远端仓库到本地"></a>远端有仓库，本地无仓库，拉取远端仓库到本地</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:Michael728/michael-git.git</span><br><span class="line">cd michael-git</span><br><span class="line"># 提交一个 readme 文件</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;add README&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h3 id="远端有空仓库，本地已有项目文件，关联远端仓库"><a href="#远端有空仓库，本地已有项目文件，关联远端仓库" class="headerlink" title="远端有空仓库，本地已有项目文件，关联远端仓库"></a>远端有空仓库，本地已有项目文件，关联远端仓库</h3><p>查看我们当前项目有哪些远程仓库可以执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></p><p>如果发现没有关联远端仓库，可以这么做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd micahel-git</span><br><span class="line">git init #  如果本地已经是一个 Git 仓库，这行就跳过</span><br><span class="line">git remote add origin git@github.com:Michael728/michael-git.git # 添加一个远端主机，并命名为 origin</span><br><span class="line">git push -u origin --all # --all 表示 push all branches，-u 选项指定了一个默认主机</span><br><span class="line">git push -u origin --tags # --tags All refs under refs/tags are pushed</span><br></pre></td></tr></table></figure></p><p>将本地的<code>master</code>分支推送到<code>origin</code>主机，同时指定<code>origin</code>为默认主机，后面就可以不要再指定远端主机名 <code>origin</code> 了，直接使用<code>git push</code>。</p><p>远端主机名可以定义为其他，比如 <code>github</code>。通过 <code>git remote add</code> 命令，一个仓库其实可以与多个远端仓库发生关联的，这时候只要远端主机名取不一样的即可区别。为什么要给远程仓库取名字？因为我们可能一个项目有多个远程仓库，比如，Github一个，比如公司一个，这样的话，提交的时候可以提交到不同的远程仓库就需要指定不同的仓库名字了。</p><p>参考：</p><ul><li><a href="https://www.zhihu.com/question/20019419" target="_blank" rel="noopener">git push 的 -u 参数具体适合含义？</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="noopener">Git远程操作详解</a></li></ul><h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p>下载一个远程仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone [-b br_name] &lt;git@github.com:Michael728/michael-git.git&gt; [本地仓库名]</span><br></pre></td></tr></table></figure></p><p>克隆的时候，可以指定下载远端的分支、自定义本地仓库的名字。如果不加分支名参数，<code>git clone</code> 命令会默认自动设置本地 <code>master</code> 分支跟踪克隆的远程仓库的 <code>master</code> 分支（其实是仓库的默认分支，大部分仓库默认分支是 master）。同时，默认远端主机设置别名为 <code>origin</code>。</p><h2 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h2><p>文件重命名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv &lt;old filename&gt; &lt;new filename&gt;</span><br></pre></td></tr></table></figure></p><h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h2><ul><li><code>git branch -r</code> 只显示远端分支，</li><li><code>git branch -a</code> 显示本地分支和远程分支</li></ul><h3 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h3><p>新建 develop 分支，并切换到 develop 分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch develop</span><br><span class="line">git checkout develop</span><br><span class="line"># 新建并切换分支</span><br><span class="line">git checkout -b develop</span><br></pre></td></tr></table></figure></p><h3 id="本地分支推送到远端仓库"><a href="#本地分支推送到远端仓库" class="headerlink" title="本地分支推送到远端仓库"></a>本地分支推送到远端仓库</h3><p>本地分支推送到远程服务器时，远程分支自动创建，推送本地分支到远程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream &lt;remote_host_name&gt; &lt;local_branch_name&gt;:&lt;remote_branch_name&gt;</span><br></pre></td></tr></table></figure></p><ul><li><code>&lt;remote_host_name&gt;</code>：远程 Git 服务器名称，一般为<code>origin</code></li><li><code>&lt;local_branch_name&gt;</code>：本地分支名称</li><li><code>&lt;remote_branch_name&gt;</code>：远程分支名称</li><li><code>--set-upstream</code>参数用来关联本地分支和远程分支</li></ul><p>一般情况下，本地分支和远程分支名称相同，所以可简化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream &lt;remote_host_name&gt; &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://majing.io/questions/718" target="_blank" rel="noopener">Git创建远程分支</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="noopener">阮一峰–Git远程操作详解</a></li></ul><h3 id="查看本地分支："><a href="#查看本地分支：" class="headerlink" title="查看本地分支："></a>查看本地分支：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch # 查看本地分支</span><br><span class="line">git branch -r # 查看远端分支</span><br><span class="line">git branh -av # 查看所有分支，信息详细点</span><br></pre></td></tr></table></figure><h3 id="删除分支："><a href="#删除分支：" class="headerlink" title="删除分支："></a>删除分支：</h3><p>删除本地分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -d develop</span><br><span class="line">git branch -D develop # 强制删除</span><br></pre></td></tr></table></figure></p><p>删除远程分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin :&lt;remote_branch_name&gt;</span><br><span class="line"># 和如下命令等同</span><br><span class="line">git push origin --delete &lt;remote_branch_name&gt;</span><br></pre></td></tr></table></figure></p><h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p>多个场景会用到这个命令:</p><ul><li>可以用它开始跟踪新文件</li><li>把已跟踪的文件放到暂存区</li><li>还能用于合并时把有冲突的文件标记为已解决状态，这个是在解决冲突时会用到的功能</li></ul><p>常用命令：</p><ul><li><code>git add -u</code>：将文件的修改、文件的删除，添加到暂存区，用<code>-u</code>有个好处，避免把工作区没准备好的新文件直接加到暂存区了，用的较多；</li><li><code>git add .</code>：将文件的修改，文件的新建，添加到暂存区，慎用；</li><li><code>git add -A/--all</code>：将文件的修改，文件的删除，文件的新建，添加到暂存区，慎用；</li></ul><p><code>git add -A</code>相对于<code>git add -u</code>命令的优点 ： 可以提交所有被删除、被替换、被修改和新增的文件到数据暂存区，而<code>git add -u</code>只能操作跟踪过的文件。</p><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><h3 id="比较工作区和暂存区的差异"><a href="#比较工作区和暂存区的差异" class="headerlink" title="比较工作区和暂存区的差异"></a>比较工作区和暂存区的差异</h3><p>将工作区和暂存区所有文件进行比较：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure></p><p>只对某些文件和暂存区进行比较：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff -- README.md [filename ...]</span><br></pre></td></tr></table></figure></p><h3 id="比较暂存区和-HEAD-之间的差异"><a href="#比较暂存区和-HEAD-之间的差异" class="headerlink" title="比较暂存区和 HEAD 之间的差异"></a>比较暂存区和 HEAD 之间的差异</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br><span class="line"># 或者</span><br><span class="line">git diff --staged</span><br></pre></td></tr></table></figure><h3 id="比较的是工作区和HEAD之间的差异"><a href="#比较的是工作区和HEAD之间的差异" class="headerlink" title="比较的是工作区和HEAD之间的差异"></a>比较的是工作区和HEAD之间的差异</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure><h3 id="比较两个分支的差异"><a href="#比较两个分支的差异" class="headerlink" title="比较两个分支的差异"></a>比较两个分支的差异</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff master temp</span><br></pre></td></tr></table></figure><p>只关心这两个分支中某个文件的差异：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff master temp -- index.html</span><br></pre></td></tr></table></figure></p><p>其实，分支名就是一个指针，就是一种引用，可以直接使用 commit id 比较：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff 622a8 7e7a -- index.html</span><br></pre></td></tr></table></figure></p><p>注意了：<code>git diff A B</code> 比较的结果可以看做是 <code>B-A</code> 的差集，调换 <code>A B</code> 顺序，正负号会有变化的。</p><h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><h3 id="暂存区文件的恢复"><a href="#暂存区文件的恢复" class="headerlink" title="暂存区文件的恢复"></a>暂存区文件的恢复</h3><p>暂存区全部文件恢复成和 HEAD 一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD</span><br></pre></td></tr></table></figure></p><ul><li>reset 命令不加 –hard，则暂存区的内容恢复成HEAD对应的内容，工作区的变更继续保留；</li><li>如果加了 –hard，则不管工作区还是暂存区，内容都变回HEAD对应的内容，危险的命令，会让你在工作区的修改丢失；</li></ul><p><code>git reset</code> 有三个参数：</p><ul><li><code>--soft</code> 这个只是把 HEAD 指向的 commit 恢复到你指定的 commit，暂存区 工作区不变</li><li><code>--hard</code> 这个是 把 HEAD， 暂存区， 工作区 都修改为 你指定的 commit 的时候的文件状态</li><li><code>--mixed</code> 这个是不加时候的默认参数，把 HEAD，暂存区 修改为 你指定的 commit 的时候的文件状态，工作区保持不变</li></ul><p>怎样取消暂存区部分文件的修改？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD style.css</span><br></pre></td></tr></table></figure></p><h3 id="将工作区和暂存区保持一致"><a href="#将工作区和暂存区保持一致" class="headerlink" title="将工作区和暂存区保持一致"></a>将工作区和暂存区保持一致</h3><p>有时候修改了文件，已经保存到暂存区，之后又在工作区进行了修改，此时，发现工作的效果不如暂存区的效果好，想要将工作区和暂存区保持一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;...</span><br></pre></td></tr></table></figure><p>其实，<code>git status</code> 都有友好的提示的：<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzc741ckucj30yc0c8771.jpg" alt></p><ul><li>如果想要变更工作区的内容，那么要想到和 <code>checkout</code> 命令相关；</li><li>如果想要变更暂存区的内容，那么要想到和<code>reset</code> 命令相关；</li></ul><h3 id="消除最近的几次提交"><a href="#消除最近的几次提交" class="headerlink" title="消除最近的几次提交"></a>消除最近的几次提交</h3><p>丢弃一些 commit，直接HEAD 指向了你指定的某个 commit，同时，暂存区和工作区也恢复到哪个 commit 时的状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;commitid&gt;</span><br></pre></td></tr></table></figure></p><p>有些 commit 会丢失，是条危险的命令，要慎用。但是当你明确了你的需求，需要将工作区暂存区提交记录明确恢复到某个 commit 状态时，可以执行这个命令。</p><h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p>「提交」操作。当你前面采用 <code>add</code> 命令将文件添加到暂存区跟踪后，需要通过<code>commit</code>将暂存区的内容提交到当前分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;test&quot;</span><br></pre></td></tr></table></figure></p><p>当一些已被追踪的文件修改后，常常需要<code>git add file</code>，然后再<code>git commit -m &quot;xxxx&quot;</code>，其实这两个步骤可以合二为一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -am &quot;test&quot;</span><br></pre></td></tr></table></figure></p><p>这么写个人觉得挺好，可以有效避免有些懒人<code>git add .</code>的方式，将一切文件都添加到了暂存区，导致最后多余文件提交入库。</p><h3 id="amend"><a href="#amend" class="headerlink" title="amend"></a>amend</h3><p>修改最近一次 commit 的 message：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure></p><p>修改完 message 信息之后，保存退出即可</p><p><code>git commit --amend</code>命令本质上是用新的 commit 应该是替代了上一次的提交，不只是修改 message。比如上一次提交时有几个文件没有 add 以及 commit，可以重新进行 add 之后再 <code>commit --amend</code> 提交。但这次提交之后，在分支的 git log 中，不会增加一次新的 commit（因为被替换了嘛），看着效果相当于在父 commit 的基础上进行的修改。</p><h3 id="修改历史提交的-message-信息："><a href="#修改历史提交的-message-信息：" class="headerlink" title="修改历史提交的 message 信息："></a>修改历史提交的 message 信息：</h3><p><img src="https://ws1.sinaimg.cn/mw690/6d9475f6ly1fzbz3iinr0j20pg0hwdhz.jpg" alt><br>如图，想要修改 be4c 这次提交的 message 信息，那么可以使用 <code>git rebase</code> 命令，因为 <code>be4c</code> 这次提交会被新的提交替换掉，所以，「变基」操作的「基」要选择它的父提交，<code>85807</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i 8580</span><br></pre></td></tr></table></figure></p><ul><li><code>-i</code> 会进入交互模式，有一系列指令操作对应的 commit，不要用 <code>pick</code> 命令，而是使用 <code>reword</code> 命令操作 <code>add ref</code> 那次 commit，然后保存，就进入修改 message 的窗口，修改完再保存，最后就会 OK 了。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i 8580</span><br><span class="line">[detached HEAD b2b5486] Add ref project</span><br><span class="line"> Date: Mon Jan 14 23:56:14 2019 +0800</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line">Successfully rebased and updated refs/heads/master.</span><br></pre></td></tr></table></figure><p> <code>git log -3</code> 查看最近的3次提交，变为这样了，会发现，倒数第二次的 message 信息修改 OK 了，最新一次的 message 虽然没变，但其实，<code>commit id</code> 都发生了变化，「替换」的概念要记得。<br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fzbzb6tgbxj30wu0hqdin.jpg" alt><br>git rebase 工作的过程中，就是用了「分离头指针」。rebase 意味着基于新 base 的 commit 来变更部分 commits。它处理的时候，把 HEAD 指向base 的 commit，此时如果该 commit 没有对应branch，就处于分离头指针的状态，然后重新一个一个生成新的 commit，当rebase 创建完最后一个 commit 后，结束分离头状态，Git 让变完基的分支名指向 HEAD</p><p>PS：对于团队中公用的分支，例如发布分支等，禁用 rebase，因为这样会破坏历史的 commit  信息的，将来要溯源、基于构建历史拉取补丁分支等就会带来极大不便。</p><h3 id="连续多个-commit-合并"><a href="#连续多个-commit-合并" class="headerlink" title="连续多个 commit  合并"></a>连续多个 commit  合并</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzbzitp4n0j30q407cdha.jpg" alt><br>目前 commit 还在本地，没有 push 到团队分支上，想要将网页相关的 commit 合并成一个，就是从图中 <code>55a9</code> 开始的6个 commit 合成一个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i 7e7a</span><br></pre></td></tr></table></figure></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzbzrbwrd3j30yg0n643u.jpg" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i 7e7a</span><br><span class="line">[detached HEAD 1c102e6] Create a complete web page</span><br><span class="line"> Date: Mon Jan 14 23:46:26 2019 +0800</span><br><span class="line"> 5 files changed, 20 insertions(+)</span><br><span class="line"> create mode 100644 index.html</span><br><span class="line"> create mode 100644 js/a.js</span><br><span class="line"> create mode 100644 style.css</span><br><span class="line"> create mode 100644 styles/a.css</span><br><span class="line"> create mode 100755 大嘴猴-头像-logo.jpg</span><br><span class="line">Successfully rebased and updated refs/heads/master.</span><br></pre></td></tr></table></figure></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzbztd0xd7j30ru046mxz.jpg" alt></p><p>变基过程中有可能会遇到冲突的，只要解决冲突即可，解决冲突的时候，只需要先修改有冲突的文件的内容，然后执行 <code>git add &lt;file_with_conflict&gt;</code>即可，不要再 <code>git commit</code>，否则多出来 commit 的，然后接着 <code>git base --continue</code>即可，参考<a href="https://www.jianshu.com/p/4c30eb30323a" target="_blank" rel="noopener">简书-git rebase解决合并冲突</a></p><h3 id="历史中不连续的-commit-合并"><a href="#历史中不连续的-commit-合并" class="headerlink" title="历史中不连续的 commit  合并"></a>历史中不连续的 commit  合并</h3><p>将历史中和 readme 相关的 commit 合并，就是下图中52af 7e7a 03be 这三个 commit。<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzbztd0xd7j30ru046mxz.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i 52af # 因为52af 是首个，没有父亲，因此需要补充一下</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzc05snpqgj30se07q40c.jpg" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">interactive rebase in progress; onto 52af14b</span><br><span class="line">Last command done (1 command done):</span><br><span class="line">   pick 52af14b</span><br><span class="line">Next commands to do (3 remaining commands):</span><br><span class="line">   squash 7e7a518 modify readme</span><br><span class="line">   squash 03bef1e Modify readme to README file</span><br><span class="line">  (use &quot;git rebase --edit-todo&quot; to view and edit)</span><br><span class="line">You are currently rebasing branch &apos;master&apos; on &apos;52af14b&apos;.</span><br><span class="line">  (all conflicts fixed: run &quot;git rebase --continue&quot;)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line"># michael @ Michael-MBP in ~/Code/Git-Geek/git_learning on git:52af14b o [17:08:05]</span><br><span class="line">$ git rebase --continue</span><br><span class="line">[detached HEAD fe08624] Add readme.md</span><br><span class="line"> Author: Michael728 &lt;michael@163.com&gt;</span><br><span class="line"> Date: Mon Jan 14 23:35:44 2019 +0800</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 README.md</span><br><span class="line">Successfully rebased and updated refs/heads/master.</span><br></pre></td></tr></table></figure></p><p>最终整理成了两个 commit：<br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fzc0bfti81j30p802a74n.jpg" alt><br>有意思的发现，有两个 commit 是没有祖先的：<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzc0d7cbf2j30j004oaag.jpg" alt><br>如果将 temp 分支、js01 tag 删掉，Git 会清理掉下面那个树。</p><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><p>git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure></p><p>比如，取回 origin 主机的 next 分支，与本地的master分支合并：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin next:master</span><br></pre></td></tr></table></figure></p><p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull origin next</span><br><span class="line"># 等价于下面两个命令</span><br><span class="line">git fetch origin</span><br><span class="line">git merge origin/next</span><br></pre></td></tr></table></figure></p><p>参考：</p><ul><li><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="noopener">阮一峰-Git远程操作详解</a></li></ul><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p><code>git push</code>命令用于将本地分支的更新，推送到远程主机：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure></p><p>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></p><p>上面命令表示，将本地的 master 分支推送到 origin 主机的 master 分支。如果后者不存在，则会被新建。</p><p>不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用 <code>--all</code> 选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push --all origin</span><br></pre></td></tr></table></figure></p><p><code>git push</code> 不会推送标签（<code>tag</code>），除非使用 <code>--tags</code> 选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br></pre></td></tr></table></figure></p><p>可能会遇到 <code>rejected</code> 的 error，因为远端包含了一些本地是没有的变更，比如，创建远端仓库时，在远端仓库的 master 分支上新建了文件，比如 License，而本地是没有这次提交的：<br><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzcu3d1mg1j311608o40c.jpg" alt><br>把远端拉取下来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch github master</span><br></pre></td></tr></table></figure></p><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;远端主机名&gt; &lt;远端分支名&gt;</span><br></pre></td></tr></table></figure></p><p><code>non-fast-forward</code> 表示，你本地 master 分支的演进不是基于远端 master 分支进行的，二者是割裂的，经过 fetch 之后，通过 <code>gitk --all</code> 可以看到：<br><img src="https://ws1.sinaimg.cn/mw690/6d9475f6ly1fzcu7h3riij20nw062q47.jpg" alt><br>解决这个问题，可以通过 rebase 或者 merge 的方式解决，现在先采用 merge 的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 切到本地 master 分支</span><br><span class="line">$ git merge github/master</span><br><span class="line">fatal: refusing to merge unrelated histories</span><br><span class="line">$ git merge github/master --allow-unrelated-histories</span><br><span class="line">Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line"> LICENSE | 21 +++++++++++++++++++++</span><br><span class="line"> 1 file changed, 21 insertions(+)</span><br><span class="line"> create mode 100644 LICENSE</span><br></pre></td></tr></table></figure><p>上面 fetch 和 merge 方式，和如下 pull 命令等效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull github master --allow-unrelated-histories</span><br></pre></td></tr></table></figure></p><p>现在合并之后，分支演进如下：<br><img src="https://ws1.sinaimg.cn/mw690/6d9475f6ly1fzcundxvl5j20qg0jc418.jpg" alt><br>可以看到merge 这种方式新生成的 commit 有两个父亲。</p><p>现在重新启动将本地的 master 分支 push 到远端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push github master</span><br></pre></td></tr></table></figure></p><h2 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h2><p>从 Git 中移除某个文件，就必须从已跟踪的文件清单中删除（从暂存区域移除文件），然后提交。可以使用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，以后这个文件就不会出现在 Git 库中了。</p><p>当我们先把某文件从 Git 库中删除（亦即从暂存区移除），但仍然希望保留在当前工作目录中。比如当你忘记在<code>.gitignore</code>文件中将一些文件忽略，但是却不小心把大的日志文件添加到暂存区域时，这一做法很有用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># --cached 将 README 文件从暂存区移除，但是工作区目录仍然保留</span><br><span class="line">git rm --cached README</span><br></pre></td></tr></table></figure><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><p>基于某分支创建新分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;new_branch_name&gt; &lt;base_branch_name&gt;</span><br></pre></td></tr></table></figure></p><p>这里的 <code>base_branch_name</code> 是指创建分支时的「基」。</p><ul><li><p>当省略时，就是基于当前分支创建；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;new_branch_name&gt;</span><br></pre></td></tr></table></figure></li><li><p>当这个「基」是远端分支名时，就实现了在本地基于远端分支创建分支。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -av # 查看本地+远程分支列表</span><br><span class="line">git checkout -b dev  origin/dev</span><br></pre></td></tr></table></figure><p>还可以可以在<code>checkout</code>命令中使用 Hash 值作为起点创建分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;name_of_branch&gt; &lt;commit id&gt;</span><br></pre></td></tr></table></figure></p><p>除了有“切换”的意思，<code>checkout</code>还有一个撤销的作用。</p><p>举个例子，假设我们在一个分支开发一个小功能，刚写完一半，这时候需求变了，而且是大变化，之前写的代码完全用不了，好在你刚写，甚至都没有 <code>git add</code> 进暂存区，这个时候很简单的一个操作就直接把原文件还原：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;filename&gt;</span><br></pre></td></tr></table></figure></p><p>参考：<a href="https://www.cnblogs.com/crazyacking/p/5620635.html" target="_blank" rel="noopener">在git中checkout历史版本</a></p><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p>查看版本演变历史：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline # 检查提交日志，都在一行：&lt;commit id&gt; &lt;message&gt;</span><br><span class="line">git log --oneline # 与上面命令等价</span><br></pre></td></tr></table></figure></p><p>查看某人的提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author=michael</span><br></pre></td></tr></table></figure></p><ul><li>一个常用的选项是<code>-p</code>，用来显示每次提交的内容差异;</li><li>可以加上<code>-2</code>或者<code>-n2</code>来仅显示最近两次提交：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git log -n2 # 查看最近的2次提交</span><br><span class="line">git log -p -2</span><br><span class="line">git log -n1 --format=format:%h # 查看当前分支最新的 commit id 缩略值</span><br></pre></td></tr></table></figure><p>列出最近两周内的提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --since=2.weeks</span><br></pre></td></tr></table></figure></p><p>图形化查看分支演变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 加了 --all 表示查看所有分支的历史，否则只能看到当前分支的演变历史</span><br><span class="line">git log --all --graph</span><br><span class="line"># 只查看指定分支的演变历史，比如 temp 分支，此时就不能使用参数 --all</span><br><span class="line">git log --oneline --graph temp</span><br></pre></td></tr></table></figure></p><ul><li><a href="http://www.cnblogs.com/bellkosmos/p/5923439.html" target="_blank" rel="noopener">git log命令全解析，打log还能这么随心所欲！</a></li><li><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2" target="_blank" rel="noopener">git-scm 2.3 Git 基础 - 查看提交历史</a></li></ul><h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>如果想查看远程仓库更多的信息，可以使用<code>git remote show &lt;remote-name&gt;</code>命令。</p><p>远程仓库的移除与重命名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote rename  &lt;old-remote-name&gt; &lt;new-remote-name&gt;</span><br><span class="line">git remote rename pb paul</span><br></pre></td></tr></table></figure></p><p>如果因为一些原因要移除一个远程仓库，可以使用<code>git remote rm &lt;remote-name&gt;</code>。</p><h3 id="添加一个新的远程-Git-仓库，同时指定一个可以轻松引用的简写："><a href="#添加一个新的远程-Git-仓库，同时指定一个可以轻松引用的简写：" class="headerlink" title="添加一个新的远程 Git 仓库，同时指定一个可以轻松引用的简写："></a>添加一个新的远程 Git 仓库，同时指定一个可以轻松引用的简写：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;remote_host_name&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure><p>这里的<code>remote_host_name</code>常常取名为<code>origin</code>。所以，常见的<code>origin</code>其实是一个你 Git 仓库跟踪的远程仓库的简写。</p><h3 id="拉取远端仓库有但你本地没有的信息："><a href="#拉取远端仓库有但你本地没有的信息：" class="headerlink" title="拉取远端仓库有但你本地没有的信息："></a>拉取远端仓库有但你本地没有的信息：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;remote_host_name&gt;</span><br></pre></td></tr></table></figure><p>如果你使用<code>clone</code>命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以<code>origin</code>为缩写。</p><h2 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h2><h3 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag # 列出所有标签</span><br><span class="line">git tag -l &apos;v1.8*&apos; # 列出以 v1.8 开头的所有标签</span><br></pre></td></tr></table></figure><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>Git使用两种主要类型的标签：</p><ul><li>附注（annotated）标签</li><li>轻量（ightweight）标签</li></ul><p>前者会包括一些注释信息，来进一步解释这个 tag 的作用，而后者就仅仅只是一个 tag 的名字</p><h4 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.4 -m &apos;my version 1.4&apos;</span><br></pre></td></tr></table></figure><p>通过<code>git show &lt;tag-name&gt;</code>命令可以看到标签信息</p><h4 id="轻量标签"><a href="#轻量标签" class="headerlink" title="轻量标签"></a>轻量标签</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.4</span><br></pre></td></tr></table></figure><p>没用<code>-a</code>、<code>-m</code>的参数，只需要提供标签名字</p><h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d &lt;tagname&gt;</span><br></pre></td></tr></table></figure><h3 id="补打标签"><a href="#补打标签" class="headerlink" title="补打标签"></a>补打标签</h3><h4 id="假设忘记给项目打标签，可以在之后加上："><a href="#假设忘记给项目打标签，可以在之后加上：" class="headerlink" title="假设忘记给项目打标签，可以在之后加上："></a>假设忘记给项目打标签，可以在之后加上：</h4><p>基于某历史节点的<code>commit id</code>补打<code>Tag</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.2 &lt;commit id&gt;</span><br></pre></td></tr></table></figure></p><h4 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h4><p>默认情况下，<code>git push</code>命令并不会传送标签到远程服务器上。在创建完标签后你必须显示地推送标签到共享服务器上。这个过程就像共享远程分支一样，可以运行<code>git push origin [tagname]</code></p><p>如果想要一次性推送很多标签，也可以使用<code>--tags</code>选项的<code>git push</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure></p><h4 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;new_br&gt; &lt;tag_name&gt;</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://thoamsy.github.io/blogs/git/" target="_blank" rel="noopener">The Junior Git</a></li><li><a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener">6 Git 基础 - 打标签</a></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li><a href="https://michael728.github.io/2018/11/24/git-advance/">Git使用教程笔记</a></li><li><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Pro Git 中文</a></li><li><a href="https://foofish.net/git-command.html" target="_blank" rel="noopener">Git常用命令备忘</a></li><li><a href="https://juejin.im/post/5c22056551882518fc5fe294" target="_blank" rel="noopener">掘金-今年下半年，中日合拍的《Git游记》即将正式开机，我将…（上集）</a></li><li><a href="http://sexywp.com/git-staging-area-index-cache.htm?f=http://blogread.cn/" target="_blank" rel="noopener">git术语解释staging，index，cache</a></li><li><a href="https://github.com/pcottle/learnGitBranching" target="_blank" rel="noopener">pcottle/learnGitBranching</a> 分支演示网站</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git-基础学习系列&quot;&gt;&lt;a href=&quot;#Git-基础学习系列&quot; class=&quot;headerlink&quot; title=&quot;Git 基础学习系列&quot;&gt;&lt;/a&gt;Git 基础学习系列&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://michael728.gith
      
    
    </summary>
    
      <category term="ToolsDev" scheme="https://michael728.github.io/categories/ToolsDev/"/>
    
    
      <category term="ss" scheme="https://michael728.github.io/tags/ss/"/>
    
      <category term="vps" scheme="https://michael728.github.io/tags/vps/"/>
    
  </entry>
  
  <entry>
    <title>Git 基础 —— 安装 配置 别名 对象</title>
    <link href="https://michael728.github.io/2019/11/14/git-install-config/"/>
    <id>https://michael728.github.io/2019/11/14/git-install-config/</id>
    <published>2019-11-14T18:21:24.000Z</published>
    <updated>2020-03-05T14:20:44.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git-基础学习系列"><a href="#Git-基础学习系列" class="headerlink" title="Git 基础学习系列"></a>Git 基础学习系列</h2><ul><li><a href="https://michael728.github.io/2019/11/14/git-install-config/">Git 基础 —— 安装 配置 别名 对象</a></li><li><a href="https://michael728.github.io/2019/11/14/git-useful-commands/">Git 基础 —— 常用命令</a></li><li><a href="https://michael728.github.io/2019/11/14/git-usage-examples/">Git 基础 —— 常见使用场景</a></li><li><a href="https://michael728.github.io/2019/11/14/git-github-experiance/">Git基础 —— Github 的使用</a></li></ul><h2 id="Git-安装"><a href="#Git-安装" class="headerlink" title="Git 安装"></a>Git 安装</h2><p><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git下载地址</a></p><p>Windows 安装时需要注意在<code>Configuring the line ending conversions</code>界面，选择<code>Checkout as-is,commit as -s</code>，避免Windows的换行符问题。如果忘记设置，可以使用如下命令后期设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf false</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://github.com/cssmagic/blog/issues/22" target="_blank" rel="noopener">GitHub 第一坑：换行符自动转换 </a></li></ul><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><p>可以通过  查看配置：</p><ul><li><code>git config -l/--list</code></li><li><code>git config --list [--local | --global | --system]</code></li></ul><p>说明：</p><ul><li><code>system</code> 不常用</li><li><code>local</code> 需要在一个 Git 仓库下使用，它的配置，优先级是最高的，代表仅针对单仓库的配置</li></ul><h3 id="设置-Git-账号"><a href="#设置-Git-账号" class="headerlink" title="设置 Git 账号"></a>设置 Git 账号</h3><p>配置 user 信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;michael728&quot;</span><br><span class="line">git config --global user.email &quot;649168982@qq.com&quot;</span><br></pre></td></tr></table></figure></p><ul><li><code>--local</code>：区域为本仓库</li><li><code>--global</code>: 当前用户的所有仓库</li><li><code>--system</code>: 本系统的所有用户</li></ul><p>运行 <code>git config --help</code> 可以看到帮助文档，比如，配置错误了，可以删除：<code>git config --unset usr.name</code> 将 <code>usr.name</code> 删除，应该是 <code>user.name</code>。</p><h3 id="生成-SSH-Key"><a href="#生成-SSH-Key" class="headerlink" title="生成 SSH Key"></a>生成 SSH Key</h3><p>1.先查看有没有 SSH Key，<code>ls -al ~/.ssh</code>，如果没有，采用如下方法生成。<br>2.生成 ssh 公钥，不要重命名生成的文件，否则会导致 ssh 方式下载 Git 代码库失败：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;649168982@qq.com&quot;</span><br></pre></td></tr></table></figure></p><p>参数说明：</p><ul><li><code>-t</code> 用来指定加密算法为 <code>rsa</code>；</li><li><code>-C</code> 后面是个注释信息，并不一定要和你 Git 账户的邮箱或者 Git 账户名保持一致，只是常常是和你账户邮箱保持一致，这样设置，就能知道这个公钥被绑定在哪个 Git 账户上了。</li></ul><p>3.生成公钥之后，拷贝公钥的内容，粘贴到你 <a href="https://github.com/settings/keys" target="_blank" rel="noopener">Github  账户的 SSH Key 设置</a>中；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pbcopy &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></p><p>如果没有 <code>pbcopy</code> 命令，就直接打开 <code>id_rsa.pub</code> 内容，复制即可；</p><p>关于公钥私钥的一些探究：</p><ul><li>一个 ssh key 只能绑定在一个 Git 账户上，而一个 Git 账户可以绑定多个 ssh key；</li><li>公钥就相当于一个 <code>fingerprint</code> ，公钥和唯一一个 Git 账户绑定，那么凡是机器上有这个公钥对应的私钥，机器就有绑定账户的权限去操作相关的代码库，即在 A 机器上生成的私钥发送到 B 机器上，那么，B 机器也会有权限下载了；</li></ul><p>参考：</p><ul><li><a href="https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/" target="_blank" rel="noopener">Github Add SSH Key 文档</a></li><li><a href="https://www.jianshu.com/p/33461b619d53" target="_blank" rel="noopener">简书-图解SSH原理</a></li><li><a href="https://www.jianshu.com/p/1246cfdbe460" target="_blank" rel="noopener">简书-SSH key的介绍与在Git中的使用</a></li><li><a href="https://wiki.archlinux.org/index.php/SSH_keys_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">archlinux-SSH keys (简体中文)</a>)</li></ul><h3 id="Git-配置别名"><a href="#Git-配置别名" class="headerlink" title="Git 配置别名"></a>Git 配置别名</h3><p><code>git config</code>命令可以轻松为每一个命令设置别名。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure></p><p>演示将git visual定义为 gitk 的别名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.visual &apos;!gitk&apos;</span><br></pre></td></tr></table></figure></p><p>设置命令的别名，可以提高操作效率。查看<code>.gitconfig</code>文件<code>vim ~/.gitconfig</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">name = xxx</span><br><span class="line">email = xxx</span><br><span class="line">[i18n]</span><br><span class="line">commitencoding = utf-8</span><br><span class="line">logoutputencoding = utf-8</span><br><span class="line">[core]</span><br><span class="line">quotepath = false</span><br><span class="line">[filter &quot;lfs&quot;]</span><br><span class="line">clean = git-lfs clean -- %f</span><br><span class="line">smudge = git-lfs smudge -- %f</span><br><span class="line">process = git-lfs filter-process</span><br><span class="line">required = true</span><br><span class="line">[alias]</span><br><span class="line">co = checkout</span><br><span class="line">br = branch</span><br><span class="line">c = commit</span><br><span class="line">s = status</span><br><span class="line">unstage = reset HEAD --</span><br><span class="line">last = log -1 HEAD</span><br><span class="line">lg = log --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit --date=relative</span><br><span class="line"></span><br><span class="line">[color]</span><br><span class="line">ui = true</span><br></pre></td></tr></table></figure></p><p>我们可以体验一个 <code>log</code> 的别名命令设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lg = log --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit --date=relative</span><br></pre></td></tr></table></figure></p><p>这是超厉害的别名缩写命令，试试现在的 <code>git lg</code> 有多酷炫吧！</p><h2 id="探秘-git-目录"><a href="#探秘-git-目录" class="headerlink" title="探秘 .git 目录"></a>探秘 .git 目录</h2><p><code>.git</code> 裸仓库文件夹，反映了 Git 良好的文件存储机制。</p><ul><li><code>HEAD</code> 文件，指向<strong>当前所在的分支</strong>，类似一个活动的指针，表示一个「引用」。例如当前在 <code>develop</code> 分支，HEAD 内容就是 <code>ref: refs/heads/develop</code></li><li><code>config</code> 文件，是本地仓库的配置文件，<code>git config --local --list</code></li><li><code>refs</code> 文件夹，包含了 <code>heads</code> 和 <code>tags</code> 文件夹。<code>heads</code> 归档的分支，<code>tags</code> 归档的标签，也叫做「里程碑」。<ul><li><code>heads</code> 文件夹下有多个文件，每个文件和仓库本地存在的分支名一致，文件内容是 commit id。文件当中存放的其实是这个分支的指针指向的 commit id。<code>git branch -av</code> 可以看到分支信息和 commit id。它是个 <code>commit</code> 类型的对象。</li><li><code>tags</code> 中也有多个文件，文件名和存在 <code>tag</code> 名一致，内容也是 commit id。它也是个 <code>commit</code> 类型的对象。</li></ul></li><li>objects 文件夹（核心），存放所有的 git 对象，对象哈希值前 2 位作为文件夹名称，后 38 位作为对象文件名, 可通过 <code>git cat-file -p &lt;2位+38位&gt;</code> 命令查看文件内容。<code>git cat-file -t &lt;2位+38位&gt;</code> 查看对象类型，这是一个 <code>tree</code> 类型的对象。内容本身是一个 <code>blob</code> 对象。任何文件的内容相同，在 Git 眼里，它就是唯一的一个 <code>blob</code> 对象。</li></ul><p>还有一些暂可以不了解的文件：</p><ul><li><code>COMMIT_EDITMSG</code> 文件</li><li><code>ORIG_HEAD</code> 文件，好像是上一次的 commit id</li><li><code>description</code> 文件，仓库的描述信息文件</li><li><code>index</code> 文件</li><li><code>hooks</code> 文件夹</li><li><code>info</code> 文件夹</li><li><code>logs</code> 文件夹</li></ul><h3 id="知道了一个-sha1-值，如何查看它的对象类型、对象内容、对象大小？"><a href="#知道了一个-sha1-值，如何查看它的对象类型、对象内容、对象大小？" class="headerlink" title="知道了一个 sha1 值，如何查看它的对象类型、对象内容、对象大小？"></a>知道了一个 sha1 值，如何查看它的对象类型、对象内容、对象大小？</h3><ul><li><code>git cat-file -t</code> 命令 ， 查看 git 对象的类型</li><li><code>git cat-file -p</code> 命令， 查看 git 对象的内容</li><li><code>git cat-file -s</code> 命令， 查看 git 对象的大小</li></ul><h3 id="Git-对象彼此关系"><a href="#Git-对象彼此关系" class="headerlink" title="Git 对象彼此关系"></a>Git 对象彼此关系</h3><p><code>commit</code> <code>tree</code> <code>blob</code> 三个对象之间的关系：<br><img src="https://ws1.sinaimg.cn/mw690/6d9475f6ly1fzb6eybuywj212t0my435.jpg" alt><br>一次 commit id 对应一棵树（<code>tree</code>），一次快照，整个项目的快照，包含了哪些文件夹（<code>tree</code>）、哪些文件（<code>blob</code>）。<code>blob</code> 可以看做是一个文件，但是和文件名是没关系的，不管文件名是什么，只要文件内容相同，就是一个 <code>blob</code>，这种设计大大节约了存储空间。</p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>新建一个 git 仓库，创建一个 doc 文件夹，在 doc 文件夹中创建 readme 文件</p><ul><li>在单纯创建 doc 文件夹时， git 不会理会；</li><li>创建 readme 文件之后，会提示有文件可以添加跟踪；</li><li>这时候执行 <code>find .git/objects --type f</code>， 没有发现有对象生成；</li><li><p>接着执行 <code>git add doc</code> 将文件添加到暂存区，这时候有文件对象生成了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects -type f</span><br><span class="line">.git/objects/27/e826dc62c8a3616e7c15d45a3d77cd8e7966c0</span><br><span class="line">$ git cat-file -t 27e8</span><br><span class="line">blob</span><br></pre></td></tr></table></figure></li><li><p>接着创建 commit，<code>git commit -m &quot;add readme&quot;</code>，这时候文件对象内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.git/objects/27/e826dc62c8a3616e7c15d45a3d77cd8e7966c0</span><br><span class="line">.git/objects/87/0af27bedac0cf42d9a7637709e455fa7de7a7e</span><br><span class="line">.git/objects/a0/3d66adf115035c521bc08509f54d867590a458</span><br><span class="line">.git/objects/e6/b633ca37bf3532f87e833c8f765e07ea50cfe8</span><br></pre></td></tr></table></figure></li></ul><p>1 个 commit  对象，2 个 tree 对象，1 个 blob 对象。</p><p>为何会有2个 tree 对象呢，其中，整个工作目录是一个 tree 对象，工作目录下的 doc 文件夹对应了一个 tree 对象。</p><p>扩充：我又将之前 doc 文件夹的 readme 文件复制在仓库的根目录下，此时在 <code>git add readme</code> 之后，文件对象仍然无变化；但是，当 commit 之后，文件对象变多了，多了 1 个 commit，1个 tree 对象。这个多出来的 tree 对象，就是因为工作目录变化了，那么就多出来了一个 tree 对象。</p><h2 id="HEAD-与-branch"><a href="#HEAD-与-branch" class="headerlink" title="HEAD 与 branch"></a>HEAD 与 branch</h2><h3 id="分离头指针"><a href="#分离头指针" class="headerlink" title="分离头指针"></a>分离头指针</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout 20824e0</span><br><span class="line">Note: checking out &apos;20824e0&apos;.</span><br><span class="line"></span><br><span class="line">You are in &apos;detached HEAD&apos; state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line">state without impacting any branches by performing another checkout.</span><br></pre></td></tr></table></figure><p><code>detached HEAD</code>就表示你当前处于「分离头指针」的状态。,其实，「分离头指针」就是表示正工作在一个没有分支的情况下，没有与分支进行挂钩, HEAD 没有指向任何分支。 处于「分离头指针」状态进行提交后，当你切换到其他分支，例如 <code>git checkout master</code> ，之前产生的 commit 可能会被 Git 当为垃圾清除掉。</p><h3 id="分离头指针的应用场景"><a href="#分离头指针的应用场景" class="headerlink" title="分离头指针的应用场景"></a>分离头指针的应用场景</h3><p>在处于分支头指针状态时，你产生了一次 commit <code>0635f24</code>，当你切换到其他分支后，有可能就找不到刚刚的提交了，你用 <code>gitk --all</code> 之后，看不到刚刚的提交的。</p><p>如果想保存刚刚的提交，需要使用如下命令将其与分支挂钩：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;new-branch-name&gt; 0635f24</span><br></pre></td></tr></table></figure></p><p>如果临时想基于某个 commit 做变更，试试新方案是否可行，就可以采用分离头指针的方式。测试后发现新方案不成熟，直接 reset 回其他分支即可，省却了建、删分支的麻烦。</p><h3 id="进一步理解-HEAD-和-branch"><a href="#进一步理解-HEAD-和-branch" class="headerlink" title="进一步理解 HEAD 和 branch"></a>进一步理解 HEAD 和 branch</h3><p>HEAD 既可以指向当前分支的最新 commit，也可以指向历史中的某一次 commit (「分离头指针」的情况)。归根结底，HEAD 指向的就是一次 commit。</p><p>当我们做分支切换时，HEAD 会跟着切换。</p><p>例如比较最近两次提交的差异，可以用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 下面三个命令等效</span><br><span class="line">git diff xxx1 xxx2</span><br><span class="line">git diff HEAD HEAD^</span><br><span class="line">Git diff HEAD HEAD~1</span><br></pre></td></tr></table></figure></p><ul><li><code>HEAD^1</code> 表示 HEAD 的父亲，<code>HEAD^^</code> 表示 HEAD 父亲的父亲。</li><li><code>HEAD^^</code> 和 <code>HEAD~2</code>等效。</li></ul><h2 id="Git-小技巧"><a href="#Git-小技巧" class="headerlink" title="Git 小技巧"></a>Git 小技巧</h2><h3 id="Git-帮助文档"><a href="#Git-帮助文档" class="headerlink" title="Git 帮助文档"></a>Git 帮助文档</h3><p>授人以鱼不如授人以渔，先知道怎么通过帮助文档查看常用命令的说明吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git help</span><br><span class="line">git help &lt;cmd&gt; # 与 git &lt;cmd&gt; --help 等价</span><br><span class="line">git help &lt;cmd&gt; --web # 使用浏览器页面打开</span><br><span class="line">git &lt;cmd&gt; -h # 显示简略的命令帮助</span><br></pre></td></tr></table></figure><h3 id="gitk-图形界面"><a href="#gitk-图形界面" class="headerlink" title="gitk 图形界面"></a>gitk 图形界面</h3><p>gitk 后面可以跟上文件的路径， 这样能看单个文件的修改历史的具体内容。</p><ul><li><code>Patch</code> 表示的是「变更集」，某一次 commit 修改的文件集合；</li><li><code>Author</code> 作者</li><li><code>Commiter</code> 提交人</li><li><code>Cherry</code> 挑选一个 commit，放到另一个分支上，这时候，Author 和 Commiter 就有可能不是一个人了，因为你挑选的那个 commit  作者可能是 A，你 cherry pick 过来之后提交，提交人是你，但是作者信息还是 A，版权考虑。</li><li><code>Parent</code> 上一次的 commit id</li><li><code>Child</code> 下一次的 commit id </li><li>菜单 View ，选择 <code>All refs</code> 可以看到所有的分支演变图</li></ul><h3 id="gitignore-指定不需要-Git-管理的文件"><a href="#gitignore-指定不需要-Git-管理的文件" class="headerlink" title="gitignore 指定不需要 Git 管理的文件"></a>gitignore 指定不需要 Git 管理的文件</h3><p><code>.gitignore</code> 指定哪些文件不需要纳入版本管理的。</p><ul><li><code>*.d</code> 任何 <code>.d</code> 结尾的文件都不需要；</li><li><code>*.dSYN/</code> 任何以 <code>.dSYM</code> 结尾的文件夹下的文件都不要；</li></ul><p>加不加 <code>/</code> 作用是不一样的，很微妙。比如，有一个文件夹叫 <code>doc</code>，那么，<code>.gitignore</code> 中写 <code>doc</code>， Git 既会忽略 doc 文件夹，也会忽略 <code>doc</code> 文件！只有 <code>doc/</code> 这么写，才会只忽略 <code>doc</code> 文件夹而不忽略 <code>doc</code> 文件，作用才很明确。</p><p>所以，如果要忽略的是文件夹，那么就显示的加上 <code>/</code> 吧。</p><p>Github 现在创建仓库时，可以选择生成什么 <code>.gitignore</code> ，附上链接作为参考：</p><ul><li><a href="https://github.com/github/gitignore/blob/master/Maven.gitignore" target="_blank" rel="noopener">github/gitignore/maven</a></li><li><a href="https://github.com/github/gitignore/blob/master/Java.gitignore" target="_blank" rel="noopener">github/gitignore/java</a></li></ul><p>这里有一个<a href="https://github.com/intellij-rust/intellij-rust/issues/1570" target="_blank" rel="noopener">帖子</a>讨论了为何 <code>.idea</code> 文件夹没有加入到 <code>.gitignore</code> 中，这是因为每个开发者的编辑器不一样，大部分习惯是将编辑器产生的文件夹添加到全局的忽略配置中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># file: ~/.gitignore_global</span><br><span class="line">.DS_Store</span><br><span class="line">.idea</span><br></pre></td></tr></table></figure></p><p>此外，还要配置指定全局的忽略文件配置在哪儿：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.excludesfile /Users/michael/.gitignore_global</span><br></pre></td></tr></table></figure></p><p>或者编辑全局配置文件 <code>~/.gitconfig</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">    excludesfile=/Users/michael/.gitignore_global</span><br></pre></td></tr></table></figure></p><p>参考：</p><ul><li><a href="https://www.jianshu.com/p/8c0d262e49a6" target="_blank" rel="noopener">Git中全局忽略.DS_Store文件</a></li></ul><h2 id="解决冲突的工具"><a href="#解决冲突的工具" class="headerlink" title="解决冲突的工具"></a>解决冲突的工具</h2><p><a href="https://sourcegear.com/diffmerge/downloads.php" target="_blank" rel="noopener">diffmerge</a>是一个可以用来文件对比软件。相较于 <code>git mergetool</code> 使用的自带的界面，diffmerge 提供了一个可交互的编辑窗口，大大提高了效率。我们可以通过简单的配置，在使用 <code>git difftool</code> <code>git mergetool</code> 时，默认使用 diffmerge 工具来进行展示差异。当然，你要是有钱，也可以选择 Beyond Compare 来作为对比软件。</p><p>选择 OS X 10.6+ Installer (Intel)    版本，安装好之后进行配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global diff.tool diffmerge</span><br><span class="line">$ git config --global difftool.diffmerge.cmd &quot;/usr/local/bin/diffmerge \&quot;\$LOCAL\&quot; \&quot;\$REMOTE\&quot;&quot;</span><br><span class="line"></span><br><span class="line">$ git config --global merge.tool diffmerge</span><br><span class="line">$ git config --global mergetool.diffmerge.trustExitCode true</span><br><span class="line">$ git config --global mergetool.diffmerge.cmd &quot;/usr/local/bin/diffmerge --merge --result=\&quot;\$MERGED\&quot;</span><br><span class="line">        \&quot;\$LOCAL\&quot; \&quot;\$BASE\&quot; \&quot;\$REMOTE\&quot;&quot;</span><br></pre></td></tr></table></figure></p><p>为了避免每次运行git difftool都有提示信息，可以输入如下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global difftool.prompt false</span><br></pre></td></tr></table></figure></p><p>为了能够支持显示中文，需要对编码进行设置：<br><img src="https://ws1.sinaimg.cn/mw690/6d9475f6ly1fzd371zsdzj21280p67cl.jpg" alt></p><p>diffmerge 的使用：</p><ul><li><code>git difftool [fileName]</code></li><li><code>git mergetool [fileName]</code></li></ul><p>使用 <code>git mergetool</code> 合并分支时，默认会生成以 <code>*.orig</code> 为扩展名的备份文件，每次都要手动删除。可以修改 Git 配置，禁止产生备份文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global mergetool.keepBackup false</span><br></pre></td></tr></table></figure></p><p>参考：</p><ul><li><a href="https://www.youtube.com/watch?v=wxh-AOxPX_A" target="_blank" rel="noopener">油管-git mergetool explained</a> 对自带的 <code>git mergetool</code> 命令的使用介绍</li><li><a href="https://www.youtube.com/watch?v=iCGrKFH2oeo" target="_blank" rel="noopener">油管-Git Tutorial: Diff and Merge Tools</a></li><li><a href="https://sourcegear.com/diffmerge/downloads.php" target="_blank" rel="noopener">diffmerge 下载</a> 选择 OS X 10.6+ Installer (Intel)    版本</li><li><a href="http://www.sourcegear.com/diffmerge/webhelp/sec__git__mac.html" target="_blank" rel="noopener">diffmerge 帮助文档</a></li><li><a href="https://www.cnblogs.com/happyflyingpig/p/7850420.html" target="_blank" rel="noopener">博客园-DiffMerge安装配置使用</a> 讲了如何配置 UTF-8</li><li><a href="https://www.zhihu.com/question/21215715" target="_blank" rel="noopener">对于解决 Git 的 Merge Conflict 你有哪些经验和技巧</a></li><li><a href="https://stackoverflow.com/questions/161813/how-to-resolve-merge-conflicts-in-git" target="_blank" rel="noopener">SOF-How to resolve merge conflicts in Git</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git-基础学习系列&quot;&gt;&lt;a href=&quot;#Git-基础学习系列&quot; class=&quot;headerlink&quot; title=&quot;Git 基础学习系列&quot;&gt;&lt;/a&gt;Git 基础学习系列&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://michael728.gith
      
    
    </summary>
    
      <category term="ToolsDev" scheme="https://michael728.github.io/categories/ToolsDev/"/>
    
    
      <category term="ss" scheme="https://michael728.github.io/tags/ss/"/>
    
      <category term="vps" scheme="https://michael728.github.io/tags/vps/"/>
    
  </entry>
  
  <entry>
    <title>Mac 环境对 Github Homebrew 等终端工具的加速设置</title>
    <link href="https://michael728.github.io/2019/11/13/tools-tips-mac-accelerate/"/>
    <id>https://michael728.github.io/2019/11/13/tools-tips-mac-accelerate/</id>
    <published>2019-11-13T20:29:13.000Z</published>
    <updated>2020-03-05T14:20:44.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近 Mac 升级系统之后，导致软件都得重装。发现 Homebrew 安装软件很多都是去 Github 上下载，怎么加速呢？简要做个备忘吧。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>首先，我是有一个 VPS 代理的，如何配置，可以看我之前的总结<a href="https://michael728.github.io/2019/04/27/tools-ss-vps/">ss+vps+mac</a> PS：记得用我的链接注册呀！我们都会有返利！</p><p>在将 SS 软件打开全局模式下，速度依然很慢，这时候你需要设置终端的代理才会加速。终端代理分为：</p><ul><li>http_proxy</li><li>https_proxy</li><li>all_proxy 这个是针对终端所有的连接都走代理</li></ul><p>SS 软件，支持 socks5 协议，也支持 http 协议，打开 偏好设置 –&gt; 高级 选项，可以看到 socks5 协议的 ip 以及端口，在 http 选项卡，可以看到 http 代理的信息。</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/Jietu20191114-230908.jpg" alt></p><p>我是这么配置的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export all_proxy=&quot;socks5://127.0.0.1:1086&quot;</span><br><span class="line"># or</span><br><span class="line">export all_proxy=&quot;http://127.0.0.1:1087&quot;</span><br></pre></td></tr></table></figure></p><p>上面的端口号 <code>1086</code> 取决于你 SS 软件中配置的端口号。除了 <code>socks5</code> 协议之外，你也可以配置 <code>http</code> 代理。</p><p>如果为了避免每次都要执行设置代理，可以将上面的配置加到你的终端配置文件中，比如我是 <code>~/.zshrc</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export all_proxy=&quot;socks5://127.0.0.1:1086&quot; &gt;&gt; ~/.zshrc</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><p>这时候，homebrew 安装就不会太慢了。</p><p>设置好代理以后，可以使用 <code>curl cip.cc</code> 查看当前自己的 ip 信息，确认代理是否设置成功。</p><p>为了加速 Git 下载，我在 <code>~/.gitconfig</code> 中加入了如下的设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[https]</span><br><span class="line">    proxy = http://127.0.0.1:1087</span><br><span class="line">    sslVerify = false</span><br><span class="line">[http]</span><br><span class="line">    proxy = http://127.0.0.1:1087</span><br><span class="line">    sslVerify = false</span><br></pre></td></tr></table></figure><p>还有一种方法，只给部分域名配置代理，这样可以避免克隆国内仓库时，速度不会受到影响：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.https://github.com.proxy socks5://127.0.0.1:1087</span><br><span class="line">git config --global https.https://github.com.proxy socks5://127.0.0.1:1087</span><br></pre></td></tr></table></figure><p>取消 Git 代理设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://jdhao.github.io/2019/10/10/mac_proxy_in_terminal/" target="_blank" rel="noopener">使用代理加速 Mac 终端下载速度</a></li><li><a href="https://blog.gobyte.cn/post/1a22163b.html" target="_blank" rel="noopener">GitHub克隆clone太慢添加代理加速访问</a></li></ul><p><a href="https://www.vultr.com/?ref=7488919" target="_blank" rel="noopener"><img src="https://www.vultr.com/media/banners/banner_728x90.png" width="728" height="90"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近 Mac 升级系统之后，导致软件都得重装。发现 Homebrew 安装软件很多都是去 Github 上下载，怎么加速呢？简要做个备忘吧。
      
    
    </summary>
    
      <category term="ToolsDev" scheme="https://michael728.github.io/categories/ToolsDev/"/>
    
    
      <category term="Tools" scheme="https://michael728.github.io/tags/Tools/"/>
    
      <category term="Mac" scheme="https://michael728.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>工作总结/思考</title>
    <link href="https://michael728.github.io/2019/10/14/summary-work/"/>
    <id>https://michael728.github.io/2019/10/14/summary-work/</id>
    <published>2019-10-14T23:10:57.000Z</published>
    <updated>2020-03-05T14:20:44.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>担心时间久了，人也懒了，用本文记载一下主要的工作经历吧。</p><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p>201706 ~ 201805</p><h3 id="思维方式"><a href="#思维方式" class="headerlink" title="思维方式"></a>思维方式</h3><ul><li>不要有边界思维，主人翁意识</li><li>保持改进意识，多思考</li><li>多总结、多分享</li><li>思路不清晰时，先梳理清楚思路，按照思路执行计划</li><li>凡是要么不做，要做就要做好</li><li>周边业务的沟通能力</li></ul><h3 id="工作内容"><a href="#工作内容" class="headerlink" title="工作内容"></a>工作内容</h3><ul><li>代码库管理<ul><li>E2E 端到端可溯 二进制可追溯 代码入库可追溯 变更/发布可追溯</li><li>度量</li><li>分支</li></ul></li><li>权限管理</li><li>开发环境标准自动化</li><li>开源及第三方软件<ul><li>开源扫描</li></ul></li><li>版本配套表</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;担心时间久了，人也懒了，用本文记载一下主要的工作经历吧。&lt;/p&gt;
&lt;h2 id=&quot;配置管理&quot;&gt;&lt;a href=&quot;#配置管理&quot; class=&quot;
      
    
    </summary>
    
      <category term="DevOps" scheme="https://michael728.github.io/categories/DevOps/"/>
    
    
      <category term="总结" scheme="https://michael728.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="工作" scheme="https://michael728.github.io/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="思考" scheme="https://michael728.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Python 代码片段收藏</title>
    <link href="https://michael728.github.io/2019/09/07/python-useful-snippets/"/>
    <id>https://michael728.github.io/2019/09/07/python-useful-snippets/</id>
    <published>2019-09-07T11:10:57.000Z</published>
    <updated>2020-03-05T14:20:44.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="list-列表相关"><a href="#list-列表相关" class="headerlink" title="list 列表相关"></a>list 列表相关</h1><h2 id="list-中最小值、最大值"><a href="#list-中最小值、最大值" class="headerlink" title="list 中最小值、最大值"></a>list 中最小值、最大值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">min_index, min_value = min(enumerate(values), key=operator.itemgetter(<span class="number">1</span>))</span><br><span class="line">max_index, max_value = max(enumerate(values), key=operator.itemgetter(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">print(<span class="string">'min_index:'</span>, min_index, <span class="string">'min_value:'</span>, min_value)</span><br><span class="line">print(<span class="string">'max_index:'</span>, max_index, <span class="string">'max_value:'</span>, max_value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Out</span></span><br><span class="line">min_index: <span class="number">0</span> min_value: <span class="number">1</span></span><br><span class="line">max_index: <span class="number">4</span> max_value: <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="list-中连续元素之间的差"><a href="#list-中连续元素之间的差" class="headerlink" title="list 中连续元素之间的差"></a>list 中连续元素之间的差</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</span><br><span class="line">ls = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>]</span><br><span class="line">diff = [j-i <span class="keyword">for</span> i,j <span class="keyword">in</span> zip(ls, islice(ls, <span class="number">1</span>, <span class="literal">None</span>))]</span><br><span class="line">print(diff)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Out</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h2 id="删除列表中的重复元素"><a href="#删除列表中的重复元素" class="headerlink" title="删除列表中的重复元素"></a>删除列表中的重复元素</h2><p>下面这种方法不能维持顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">8</span>]</span><br><span class="line">list(set(x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Out</span></span><br><span class="line">[<span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>下面的方法，可以维持顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line">x = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">8</span>]</span><br><span class="line">list(OrderedDict.fromkeys(x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Out</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><h2 id="并行遍历2个列表"><a href="#并行遍历2个列表" class="headerlink" title="并行遍历2个列表"></a>并行遍历2个列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (a_val, b_val) <span class="keyword">in</span> zip(a, b):</span><br><span class="line">    print(a_val, b_val)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Out</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="合并列表值"><a href="#合并列表值" class="headerlink" title="合并列表值"></a>合并列表值</h2><p>输入的两个数组，输出一个是数组&amp;值相加或者相乘：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># input</span></span><br><span class="line">first = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">second = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line">three = [<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The zip function is useful here, used with a list comprehension.</span></span><br><span class="line"><span class="comment"># add</span></span><br><span class="line">[x + y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(first, second)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># other</span></span><br><span class="line">[x*y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(first, second)]</span><br><span class="line">[max(x,y) <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(first, second)]</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="http://blog.ourren.com/2015/07/19/pythonzhong-de-chang-yong-dai-ma/" target="_blank" rel="noopener">Python中的常用代码</a></li></ul><h1 id="字典处理"><a href="#字典处理" class="headerlink" title="字典处理"></a>字典处理</h1><h2 id="字典做交、差、并"><a href="#字典做交、差、并" class="headerlink" title="字典做交、差、并"></a>字典做交、差、并</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=&#123;<span class="string">'name'</span>:<span class="string">'michael'</span>,<span class="string">'age'</span>:<span class="string">"27"</span>,<span class="string">'sex'</span>:<span class="string">'male'</span>&#125;</span><br><span class="line">b=&#123;<span class="string">'name'</span>:<span class="string">'hqh'</span>,<span class="string">'age'</span>:<span class="string">'27'</span>&#125;</span><br><span class="line">&#123;k:a[k] <span class="keyword">for</span> k <span class="keyword">in</span> a.keys()-b.keys()&#125;</span><br><span class="line">out: &#123;<span class="string">'sex'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line">dict(a.items()-b.items())</span><br><span class="line">out: &#123;<span class="string">'name'</span>: <span class="string">'michael'</span>, <span class="string">'sex'</span>: <span class="string">'male'</span>&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，当字典的值有字典时，<code>a.items()-b.items()</code> 这种方式会报错 <code>TypeError: unhashable type: &#39;dict&#39;</code>；</p><p>参考：</p><ul><li><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p09_find_commonalities_in_dicts.html" target="_blank" rel="noopener">cookbook-查找两字典的相同点</a></li><li><a href="https://www.jianshu.com/p/65f4bebc1061" target="_blank" rel="noopener">简书-Python 字典操作进阶</a></li></ul><h2 id="字典的Key与Value对调"><a href="#字典的Key与Value对调" class="headerlink" title="字典的Key与Value对调"></a>字典的Key与Value对调</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m = &#123;<span class="string">'A'</span>: <span class="number">1</span>, <span class="string">'B'</span>: <span class="number">2</span>, <span class="string">'C'</span>: <span class="number">3</span>&#125;</span><br><span class="line">invert_map_key_value = <span class="keyword">lambda</span> m: dict(zip(m.values(), m.keys()))</span><br><span class="line">invert_map_key_value(m)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output: &#123;1: 'A', 2: 'B', 3: 'C'&#125;</span></span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/33069486" target="_blank" rel="noopener">2gua-几个Python代码片段</a></li></ul><h2 id="合并字典值"><a href="#合并字典值" class="headerlink" title="合并字典值"></a>合并字典值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = Counter(&#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>:<span class="number">3</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B = Counter(&#123;<span class="string">'b'</span>:<span class="number">3</span>, <span class="string">'c'</span>:<span class="number">4</span>, <span class="string">'d'</span>:<span class="number">5</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A + B</span><br><span class="line">Counter(&#123;<span class="string">'c'</span>: <span class="number">7</span>, <span class="string">'b'</span>: <span class="number">5</span>, <span class="string">'d'</span>: <span class="number">5</span>, <span class="string">'a'</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="字典的增加"><a href="#字典的增加" class="headerlink" title="字典的增加"></a>字典的增加</h2><p>用 <code>update</code> 方法往已有字典中增加键值对：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">deploy_info=dict()</span><br><span class="line"><span class="keyword">for</span> idx, row <span class="keyword">in</span> raw_data.iterrows():</span><br><span class="line">    temp=dict()</span><br><span class="line">    version = row[<span class="string">'version'</span>]</span><br><span class="line">    app_comp_name = row[<span class="string">'app_comp_name'</span>]</span><br><span class="line">    pkg_name = <span class="string">"&#123;&#125;_&#123;&#125;.tar.gz"</span>.format(app_comp_name, version)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    data = get_verify_value(api_url,pkg_name)</span><br><span class="line">    temp = &#123;</span><br><span class="line">        deploy_history_id:&#123;</span><br><span class="line">            <span class="string">'app_comp_name'</span>:app_comp_name,</span><br><span class="line">            <span class="string">'version'</span>:version,</span><br><span class="line">            <span class="string">'pkg_name'</span>:pkg_name,</span><br><span class="line">            <span class="string">'data'</span>:data</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    deploy_info.update(temp)</span><br></pre></td></tr></table></figure><h1 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tag=<span class="string">'hx/mitaka_compute/12.0.0'</span></span><br><span class="line">[m.start() <span class="keyword">for</span> m <span class="keyword">in</span> re.finditer(<span class="string">'/'</span>,tag)]</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://codeday.me/bug/20170404/7720.html" target="_blank" rel="noopener">在Python中查找所有出现的子字符串</a></li></ul><h2 id="将百分号的百分比字符串转为数字"><a href="#将百分号的百分比字符串转为数字" class="headerlink" title="将百分号的百分比字符串转为数字"></a>将百分号的百分比字符串转为数字</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p=<span class="string">"75%"</span></span><br><span class="line">float(p.strip(<span class="string">'%'</span>))/<span class="number">100</span></span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://www.kaggle.com/grfiv4/convert-to-numeric-python" target="_blank" rel="noopener">Convert to numeric Python</a></li></ul><h2 id="剔除分隔符"><a href="#剔除分隔符" class="headerlink" title="剔除分隔符"></a>剔除分隔符</h2><p>通常做法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span>.join(<span class="string">'A|B|C|D|E|F|G'</span>.split(<span class="string">'|'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># output: 'ABCDEFG'</span></span><br></pre></td></tr></table></figure><p>用 <code>itertools.islice</code>，因为可以节选字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="string">''</span>.join(itertools.islice(<span class="string">'A|B|C|D|E|F|G'</span>, <span class="number">6</span>, <span class="literal">None</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># output: 'DEFG'</span></span><br><span class="line"></span><br><span class="line"><span class="string">''</span>.join(itertools.islice(<span class="string">'A|B|C|D|E|F|G'</span>, <span class="number">0</span>, <span class="literal">None</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># output: ''ABCDEFG'</span></span><br></pre></td></tr></table></figure><h2 id="美观打印"><a href="#美观打印" class="headerlink" title="美观打印"></a>美观打印</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pprint <span class="keyword">as</span> pp</span><br><span class="line">animals = [&#123;<span class="string">'animal'</span>: <span class="string">'dog'</span>, <span class="string">'legs'</span>: <span class="number">4</span>, <span class="string">'breeds'</span>: [<span class="string">'Border Collie'</span>, <span class="string">'Pit Bull'</span>, <span class="string">'Huskie'</span>]&#125;, &#123;<span class="string">'animal'</span>: <span class="string">'cat'</span>, <span class="string">'legs'</span>: <span class="number">4</span>, <span class="string">'breeds'</span>: [<span class="string">'Siamese'</span>, <span class="string">'Persian'</span>, <span class="string">'Sphynx'</span>]&#125;]</span><br><span class="line">pp.pprint(animals, width=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Out</span></span><br><span class="line">[&#123;<span class="string">'animal'</span>: <span class="string">'dog'</span>,</span><br><span class="line">  <span class="string">'breeds'</span>: [<span class="string">'Border '</span></span><br><span class="line">             <span class="string">'Collie'</span>,</span><br><span class="line">             <span class="string">'Pit '</span></span><br><span class="line">             <span class="string">'Bull'</span>,</span><br><span class="line">             <span class="string">'Huskie'</span>],</span><br><span class="line">  <span class="string">'legs'</span>: <span class="number">4</span>&#125;,</span><br><span class="line"> &#123;<span class="string">'animal'</span>: <span class="string">'cat'</span>,</span><br><span class="line">  <span class="string">'breeds'</span>: [<span class="string">'Siamese'</span>,</span><br><span class="line">             <span class="string">'Persian'</span>,</span><br><span class="line">             <span class="string">'Sphynx'</span>],</span><br><span class="line">  <span class="string">'legs'</span>: <span class="number">4</span>&#125;]</span><br></pre></td></tr></table></figure><p>width参数指定一行上最大的字符数。设置width为1确保字典打印在单独的行</p><h1 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h1><h2 id="基本文件读-txt"><a href="#基本文件读-txt" class="headerlink" title="基本文件读 txt"></a>基本文件读 txt</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">Note:</span> rb opens file in binary mode to avoid issues with Windows systems</span></span><br><span class="line"><span class="comment"># where 'rn' is used instead of 'n' as newline character(s).</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># A) Reading in Byte chunks</span></span><br><span class="line">reader_a = open(<span class="string">"file.txt"</span>, <span class="string">"rb"</span>)</span><br><span class="line">chunks = []</span><br><span class="line">data = reader_a.read(<span class="number">64</span>)  <span class="comment"># reads first 64 bytes</span></span><br><span class="line"><span class="keyword">while</span> data != <span class="string">""</span>:</span><br><span class="line">    chunks.append(data)</span><br><span class="line">    data = reader_a.read(<span class="number">64</span>)</span><br><span class="line"><span class="keyword">if</span> data:</span><br><span class="line">    chunks.append(data)</span><br><span class="line">print(len(chunks))</span><br><span class="line">reader_a.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># B) Reading whole file at once into a list of lines</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"file.txt"</span>, <span class="string">"rb"</span>) <span class="keyword">as</span> reader_b:   <span class="comment"># recommended syntax, auto closes</span></span><br><span class="line">    data = reader_b.readlines() <span class="comment"># data is assigned a list of lines</span></span><br><span class="line">print(len(data))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># C) Reading whole file at once into a string</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"file.txt"</span>, <span class="string">"rb"</span>) <span class="keyword">as</span> reader_c:</span><br><span class="line">    data = reader_c.read() <span class="comment"># data is assigned a list of lines</span></span><br><span class="line">print(len(data))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># D) Reading line by line into a list</span></span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"file.txt"</span>, <span class="string">"rb"</span>) <span class="keyword">as</span> reader_d:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> reader_d:</span><br><span class="line">        data.append(line)</span><br><span class="line">print(len(data))</span><br></pre></td></tr></table></figure><h2 id="json-读写json文件"><a href="#json-读写json文件" class="headerlink" title="json 读写json文件"></a>json 读写json文件</h2><ul><li>json.loads()是将str转化成dict格式，json.dumps()是将dict转化成str格式。</li><li>json.load()和json.dump()也是类似的功能，只是与文件操作结合起来了。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解码</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'build_info.json'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    array = json.load(f)</span><br><span class="line">print(array)</span><br></pre></td></tr></table></figure><p>在编码JSON的时候，还有一些选项很有用。 如果你想获得漂亮的格式化字符串后输出，可以使用 <code>json.dumps()</code> 的<code>indent</code>参数。 它会使得输出和pprint() 函数效果类似：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(data))</span><br><span class="line">&#123;<span class="string">"price"</span>: <span class="number">542.23</span>, <span class="string">"name"</span>: <span class="string">"ACME"</span>, <span class="string">"shares"</span>: <span class="number">100</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(data, indent=<span class="number">4</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"price"</span>: <span class="number">542.23</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"ACME"</span>,</span><br><span class="line">    <span class="string">"shares"</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>保存为 json 文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编码</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">a = &#123;<span class="string">"name"</span>:<span class="string">"michael"</span>&#125;</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"demo.json"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">json.dump(a, f, indent=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><ul><li><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c06/p02_read-write_json_data.html?highlight=json" target="_blank" rel="noopener">CookBook-6.2 读写JSON数据</a></li><li><a href="https://www.jianshu.com/p/e29611244810" target="_blank" rel="noopener">简书-Python: json模块实例详解</a></li><li><a href="https://docs.python.org/3.6/library/json.html" target="_blank" rel="noopener">官宣-json — JSON encoder and decoder</a></li><li><a href="https://stackoverflow.com/questions/38644480/reading-json-file-with-python-3" target="_blank" rel="noopener">Reading JSON file with Python 3</a></li><li><a href="https://stackoverflow.com/questions/39719689/what-is-the-difference-between-json-load-and-json-loads-functions-in-python" target="_blank" rel="noopener">What is the difference between json.load() and json.loads() functions in Python?</a></li></ul><h1 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h1><h2 id="基本时间（time）和日期（date）"><a href="#基本时间（time）和日期（date）" class="headerlink" title="基本时间（time）和日期（date）"></a>基本时间（time）和日期（date）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># print time HOURS:MINUTES:SECONDS</span></span><br><span class="line"><span class="comment"># e.g., '10:50:58'</span></span><br><span class="line">print(time.strftime(<span class="string">"%H:%M:%S"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># print current date DAY:MONTH:YEAR</span></span><br><span class="line"><span class="comment"># e.g., '05/01/2019'</span></span><br><span class="line">print(time.strftime(<span class="string">"%d/%m/%Y"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Out</span></span><br><span class="line"><span class="number">15</span>:<span class="number">18</span>:<span class="number">03</span></span><br><span class="line"><span class="number">05</span>/<span class="number">01</span>/<span class="number">2019</span></span><br></pre></td></tr></table></figure><h2 id="字符串和日期的相互转换"><a href="#字符串和日期的相互转换" class="headerlink" title="字符串和日期的相互转换"></a>字符串和日期的相互转换</h2><p>strptime 是将字符串转换为 datetime，其实这个方法的全称是 “string parse time”，叫做字符串解析成时间，重点在解析（parse）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">date_obj = datetime.strptime(<span class="string">'2018-10-15 20:59:29'</span>, <span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class="line">print(type(date_obj),date_obj)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Out</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">datetime</span>.<span class="title">datetime</span>'&gt; 2018-10-15 20:</span><span class="number">59</span>:<span class="number">29</span></span><br></pre></td></tr></table></figure><p>strftime 是将 datetime 转换为字符串，全称是 “string format time”，翻译过来就是将字符串的形式来格式化时间，重点在格式化（format），使之以一种可读的字符串形式返回：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">date_obj = datetime.now()</span><br><span class="line">date_string = datetime.now().strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line">print(type(date_string),date_string)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Out</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt; 2019-01-05 18:</span><span class="number">41</span>:<span class="number">04</span></span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5MzgyODQxMQ==&amp;mid=2650369197&amp;idx=1&amp;sn=0057a786cb28f9d264e8bdd5ed0a0d15&amp;chksm=be9cd7f989eb5eefa012a502def9c071ac790e70162ec525c8dc43b087c961648ee1a9bb6264&amp;mpshare=1&amp;scene=1&amp;srcid=1115C4UhHFYie2bJLm4K8erU#rd" target="_blank" rel="noopener">3分钟学会一个小技巧</a></li></ul><h1 id="编码相关"><a href="#编码相关" class="headerlink" title="编码相关"></a>编码相关</h1><h2 id="Python-Requests-编码问题"><a href="#Python-Requests-编码问题" class="headerlink" title="Python Requests 编码问题"></a>Python Requests 编码问题</h2><ul><li><a href="https://github.com/requests/requests/issues/1604" target="_blank" rel="noopener">requests github issue</a></li></ul><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><h2 id="Python下载文件"><a href="#Python下载文件" class="headerlink" title="Python下载文件"></a>Python下载文件</h2><ul><li><a href="https://blog.csdn.net/fengzhizi76506/article/details/59229846" target="_blank" rel="noopener">urlretrieve</a></li></ul><h2 id="Python根据url下载目录或者文件"><a href="#Python根据url下载目录或者文件" class="headerlink" title="Python根据url下载目录或者文件"></a>Python根据url下载目录或者文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_package</span><span class="params">(self, package_url)</span>:</span></span><br><span class="line">    print(<span class="string">"start download_build_result"</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> package_url.endswith(<span class="string">"/"</span>):</span><br><span class="line">        package_url += <span class="string">'/'</span></span><br><span class="line">    cmd = <span class="string">"wget -c -r -nd -np -P %s %s"</span> % (<span class="string">"output"</span>, package_url)</span><br><span class="line">    print(cmd)</span><br><span class="line">    os.system(cmd)</span><br><span class="line">    print(os.getcwd())</span><br><span class="line">    print(<span class="string">"finish download_build_result"</span>)</span><br></pre></td></tr></table></figure><h1 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h1><h2 id="Python-Pandas处理Excel数据"><a href="#Python-Pandas处理Excel数据" class="headerlink" title="Python Pandas处理Excel数据"></a>Python Pandas处理Excel数据</h2><h3 id="逐行处理数据-iterrows"><a href="#逐行处理数据-iterrows" class="headerlink" title="逐行处理数据 iterrows"></a>逐行处理数据 iterrows</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> idx, row <span class="keyword">in</span> data.iterrows():</span><br><span class="line">    project_name=row[<span class="string">'projectName'</span>]</span><br><span class="line">    tag_name=row[<span class="string">'tagName'</span>]</span><br></pre></td></tr></table></figure><h3 id="Pandas追加模式写入csv文件"><a href="#Pandas追加模式写入csv文件" class="headerlink" title="Pandas追加模式写入csv文件"></a>Pandas追加模式写入csv文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = pd.DataFrame([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]])</span><br><span class="line">csv_headers=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>]</span><br><span class="line">data.to_csv(<span class="string">'./Marvel3_yingpping.csv'</span>, header=csv_headers, index=<span class="literal">False</span>, mode=<span class="string">'a+'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">data = pd.DataFrame([[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">data.to_csv(<span class="string">'./Marvel3_yingpping.csv'</span>, header=<span class="literal">False</span>, index=<span class="literal">False</span>, mode=<span class="string">'a+'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">data = pd.DataFrame([[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line">data.to_csv(<span class="string">'./Marvel3_yingpping.csv'</span>, header=<span class="literal">False</span>, index=<span class="literal">False</span>, mode=<span class="string">'a+'</span>, encoding=<span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure><h2 id="Python-CSV-Excel"><a href="#Python-CSV-Excel" class="headerlink" title="Python-CSV-Excel"></a>Python-CSV-Excel</h2><ul><li><a href="https://stackoverflow.com/questions/28310409/python-pandas-iterrows-method" target="_blank" rel="noopener">Python Pandas iterrows method</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> idx, row <span class="keyword">in</span> data.iterrows():</span><br><span class="line">    project_name=row[<span class="string">'projectName'</span>]</span><br><span class="line">    tag_name=row[<span class="string">'tagName'</span>]</span><br></pre></td></tr></table></figure><h2 id="to-csv表格中文乱码"><a href="#to-csv表格中文乱码" class="headerlink" title="to_csv表格中文乱码"></a>to_csv表格中文乱码</h2><p>ipython中直接打印df，中文没有乱码，但是<code>to_csv</code>方法存储时，中文有乱码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.to_csv(<span class="string">'file.csv'</span>,encoding=<span class="string">'utf-8-sig'</span>)</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://stackoverflow.com/questions/25788037/pandas-df-to-csvfile-csv-encode-utf-8-still-gives-trash-characters-for-min" target="_blank" rel="noopener">Pandas df.to_csv(“file.csv” encode=“utf-8”) still gives trash characters for minus sign</a></li><li><a href="https://blog.csdn.net/weixin_39461443/article/details/75303072" target="_blank" rel="noopener">关于pandas中,to_csv函数输出的utf8数据用Excel打开是乱码</a></li></ul><h2 id="itero"><a href="#itero" class="headerlink" title="itero"></a>itero</h2><p>看题目：</p><ul><li><a href="https://segmentfault.com/q/1010000006624056?_ea=1081758" target="_blank" rel="noopener">python数据处理，字典生成的一个问题</a>答案中有位前辈用这个用的炉火纯青啊！</li></ul><h1 id="Shell-Linux-操作相关"><a href="#Shell-Linux-操作相关" class="headerlink" title="Shell/Linux 操作相关"></a>Shell/Linux 操作相关</h1><h2 id="Python运行shell命令的函数："><a href="#Python运行shell命令的函数：" class="headerlink" title="Python运行shell命令的函数："></a>Python运行shell命令的函数：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(cmd_str, fatal=True)</span>:</span></span><br><span class="line">    <span class="comment"># this is not a good implement</span></span><br><span class="line">    log.command(log.term.cmd(cmd_str))</span><br><span class="line">    ret = os.system(cmd_str)</span><br><span class="line">    <span class="keyword">if</span> ret <span class="keyword">is</span> <span class="keyword">not</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> fatal:</span><br><span class="line">            log.error(<span class="string">'[ERROR] run cmd: %s failed'</span>, cmd_str)</span><br><span class="line">            os._exit(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            log.info(<span class="string">'[INFO] %s is not fatal'</span> % cmd_str)</span><br></pre></td></tr></table></figure><h2 id="调用外部的命令"><a href="#调用外部的命令" class="headerlink" title="调用外部的命令"></a>调用外部的命令</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">subprocess.call([<span class="string">'mkdir'</span>, <span class="string">'empty_folder'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行一条命令并输出得到的结果</span></span><br><span class="line">output = subprocess.check_output([<span class="string">'ls'</span>, <span class="string">'-l'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的调用是阻塞的</span></span><br><span class="line"><span class="comment"># 如果运行shell中内置的命令，如cd或者dir，需要指定标记shell=True</span></span><br><span class="line">output = subprocess.call([<span class="string">'cd'</span>, <span class="string">'/'</span>], shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于更高级的用例，可以使用 Popen constructor。</span></span><br></pre></td></tr></table></figure><p>Python 3.5引进了一个新的run函数，它的行为与call和check_output很相似。如果你使用的是3.5版本或更高版本，看一看run的文档，里面有一些有用的例子。否则，如果你使用的是Python 3.5以前的版本或者你想保持向后兼容性，上面的call和check_output代码片段是你最安全和最简单的选择</p><p>参考：</p><ul><li><a href="https://python.freelycode.com/contribution/detail/53" target="_blank" rel="noopener"></a></li></ul><h2 id="计算文件的校验值"><a href="#计算文件的校验值" class="headerlink" title="计算文件的校验值"></a>计算文件的校验值</h2><p>可以计算文件的 <code>md5</code>、<code>sha256</code> 等值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://pymotw.com/3/hashlib/index.html#module-hashlib</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_verify_value</span><span class="params">(file_path, verify_type)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    计算指定文件的校验值</span></span><br><span class="line"><span class="string">    :param file_path: 文件路径</span></span><br><span class="line"><span class="string">    :param verify_type: 校验值类型，md5 sha256 等等</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    h = hashlib.new(verify_type)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> file_path:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">with</span> open(file_path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> block <span class="keyword">in</span> iter(<span class="keyword">lambda</span>: f.read(<span class="number">4096</span>), <span class="string">b""</span>):</span><br><span class="line">            h.update(block)</span><br><span class="line">    <span class="keyword">return</span> h.hexdigest()</span><br></pre></td></tr></table></figure><h1 id="性能相关"><a href="#性能相关" class="headerlink" title="性能相关"></a>性能相关</h1><h2 id="脚本的运行时间"><a href="#脚本的运行时间" class="headerlink" title="脚本的运行时间"></a>脚本的运行时间</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">start_time = time.clock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">elapsed_time = time.clock() - start_time</span><br><span class="line">print(<span class="string">"Time elapsed: &#123;&#125; seconds"</span>.format(elapsed_time))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Out</span></span><br><span class="line">Time elapsed: <span class="number">0.30121700000000007</span> seconds</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line">elapsed_time = timeit.timeit(<span class="string">'for i in range(10000000): pass'</span>, number=<span class="number">1</span>)</span><br><span class="line">print(<span class="string">"Time elapsed: &#123;&#125; seconds"</span>.format(elapsed_time))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Out</span></span><br><span class="line">Time elapsed: <span class="number">0.2051873060000844</span> seconds</span><br></pre></td></tr></table></figure><h2 id="计算运行时间"><a href="#计算运行时间" class="headerlink" title="计算运行时间"></a>计算运行时间</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.error = <span class="literal">None</span></span><br><span class="line">        self.start = time.time()</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, type, value, tb)</span>:</span></span><br><span class="line">        self.finish = time.time()</span><br><span class="line">        <span class="keyword">if</span> type:</span><br><span class="line">            self.error = (type, value, tb)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duration</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.finish - self.start</span><br><span class="line"><span class="keyword">with</span> Timer() <span class="keyword">as</span> timer:</span><br><span class="line">    func()</span><br><span class="line">timer.duration()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Out</span></span><br><span class="line"><span class="number">0.29994797706604004</span></span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://blog.csdn.net/u010571844/article/details/50731541" target="_blank" rel="noopener">CSDN- python代码片段</a></li></ul><h1 id="目录、路径相关"><a href="#目录、路径相关" class="headerlink" title="目录、路径相关"></a>目录、路径相关</h1><h2 id="基本目录文件操作"><a href="#基本目录文件操作" class="headerlink" title="基本目录文件操作"></a>基本目录文件操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># working directory</span></span><br><span class="line">c_dir = os.getcwd()                 <span class="comment"># show current working directory</span></span><br><span class="line">os.listdir(c_dir)                   <span class="comment"># shows all files in the working directory</span></span><br><span class="line">os.chdir(<span class="string">'~/Data'</span>)                  <span class="comment"># change working directory</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># get all files in a directory</span></span><br><span class="line">glob.glob(<span class="string">'/Users/sebastian/Desktop/*'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># e.g.,  ['/Users/sebastian/Desktop/untitled folder', '/Users/sebastian/Desktop/Untitled.txt']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># walk</span></span><br><span class="line">tree = os.walk(c_dir)</span><br><span class="line"><span class="comment"># moves through sub directories and creates a 'generator' object of tuples</span></span><br><span class="line"><span class="comment"># ('dir', [file1, file2, ...] [subdirectory1, subdirectory2, ...]),</span></span><br><span class="line"><span class="comment">#    (...), ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#check files: returns either True or False</span></span><br><span class="line">os.exists(<span class="string">'../rel_path'</span>)</span><br><span class="line">os.exists(<span class="string">'/home/abs_path'</span>)</span><br><span class="line">os.isfile(<span class="string">'./file.txt'</span>)</span><br><span class="line">os.isdir(<span class="string">'./subdir'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># file permission (True or False</span></span><br><span class="line">os.access(<span class="string">'./some_file'</span>, os.F_OK) <span class="comment"># File exists? Python 2.7</span></span><br><span class="line">os.access(<span class="string">'./some_file'</span>, os.R_OK) <span class="comment"># Ok to read? Python 2.7</span></span><br><span class="line">os.access(<span class="string">'./some_file'</span>, os.W_OK) <span class="comment"># Ok to write? Python 2.7</span></span><br><span class="line">os.access(<span class="string">'./some_file'</span>, os.X_OK) <span class="comment"># Ok to execute? Python 2.7</span></span><br><span class="line">os.access(<span class="string">'./some_file'</span>, os.X_OK | os.W_OK) <span class="comment"># Ok to execute or write? Python 2.7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># join (creates operating system dependent paths)</span></span><br><span class="line">os.path.join(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br><span class="line"><span class="comment"># 'a/b/c' on Unix/Linux</span></span><br><span class="line"><span class="comment"># 'a\b\c' on Windows</span></span><br><span class="line">os.path.normpath(<span class="string">'a/b/c'</span>) <span class="comment"># converts file separators</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># os.path: direcory and file names</span></span><br><span class="line">os.path.samefile(<span class="string">'./some_file'</span>, <span class="string">'/home/some_file'</span>)  <span class="comment"># True if those are the same</span></span><br><span class="line">os.path.dirname(<span class="string">'./some_file'</span>)  <span class="comment"># returns '.' (everythin but last component)</span></span><br><span class="line">os.path.basename(<span class="string">'./some_file'</span>) <span class="comment"># returns 'some_file' (only last component</span></span><br><span class="line">os.path.split(<span class="string">'./some_file'</span>) <span class="comment"># returns (dirname, basename) or ('.', 'some_file)</span></span><br><span class="line">os.path.splitext(<span class="string">'./some_file.txt'</span>) <span class="comment"># returns ('./some_file', '.txt')</span></span><br><span class="line">os.path.splitdrive(<span class="string">'./some_file.txt'</span>) <span class="comment"># returns ('', './some_file.txt')</span></span><br><span class="line">os.path.isabs(<span class="string">'./some_file.txt'</span>) <span class="comment"># returns False (not an absolute path)</span></span><br><span class="line">os.path.abspath(<span class="string">'./some_file.txt'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># create and delete files and directories</span></span><br><span class="line">os.mkdir(<span class="string">'./test'</span>)  <span class="comment"># create a new direcotory</span></span><br><span class="line">os.rmdir(<span class="string">'./test'</span>)  <span class="comment"># removes an empty direcotory</span></span><br><span class="line">os.removedirs(<span class="string">'./test'</span>) <span class="comment"># removes nested empty directories</span></span><br><span class="line">os.remove(<span class="string">'file.txt'</span>)   <span class="comment"># removes an individual file</span></span><br><span class="line">shutil.rmtree(<span class="string">'./test'</span>) <span class="comment"># removes directory (empty or not empty)</span></span><br><span class="line"></span><br><span class="line">os.rename(<span class="string">'./dir_before'</span>, <span class="string">'./renamed'</span>) <span class="comment"># renames directory if destination doesn't exist</span></span><br><span class="line">shutil.move(<span class="string">'./dir_before'</span>, <span class="string">'./renamed'</span>) <span class="comment"># renames directory always</span></span><br><span class="line"></span><br><span class="line">shutil.copytree(<span class="string">'./orig'</span>, <span class="string">'./copy'</span>) <span class="comment"># copies a directory recursively</span></span><br><span class="line">shutil.copyfile(<span class="string">'file'</span>, <span class="string">'copy'</span>)     <span class="comment"># copies a file</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Getting files of particular type from directory</span></span><br><span class="line">files = [f <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(s_pdb_dir) <span class="keyword">if</span> f.endswith(<span class="string">".txt"</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy and move</span></span><br><span class="line">shutil.copyfile(<span class="string">"/path/to/file"</span>, <span class="string">"/path/to/new/file"</span>)</span><br><span class="line">shutil.copy(<span class="string">"/path/to/file"</span>, <span class="string">"/path/to/directory"</span>)</span><br><span class="line">shutil.move(<span class="string">"/path/to/file"</span>,<span class="string">"/path/to/directory"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check if file or directory exists</span></span><br><span class="line">os.path.exists(<span class="string">"file or directory"</span>)</span><br><span class="line">os.path.isfile(<span class="string">"file"</span>)</span><br><span class="line">os.path.isdir(<span class="string">"directory"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Working directory and absolute path to files</span></span><br><span class="line">os.getcwd()</span><br><span class="line">os.path.abspath(<span class="string">"file"</span>)</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="http://blog.topspeedsnail.com/archives/883" target="_blank" rel="noopener">斗大的熊猫-收集的有用的 Python 代码片段</a></li></ul><h2 id="Python-删除文件夹"><a href="#Python-删除文件夹" class="headerlink" title="Python 删除文件夹"></a>Python 删除文件夹</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onerror</span><span class="params">(func, path, exc_info)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Error handler for ``shutil.rmtree``.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If the error is due to an access error (read only file)</span></span><br><span class="line"><span class="string">    it attempts to add write permission and then retries.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If the error is for another reason it re-raises the error.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Usage : ``shutil.rmtree(path, onerror=onerror)``</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">import</span> stat</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.access(path, os.W_OK):</span><br><span class="line">        <span class="comment"># Is the error an access error ?</span></span><br><span class="line">        os.chmod(path, stat.S_IWUSR)</span><br><span class="line">        func(path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span></span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://stackoverflow.com/questions/2656322/shutil-rmtree-fails-on-windows-with-access-is-denied" target="_blank" rel="noopener">shutil.rmtree fails on Windows with ‘Access is denied’</a></li></ul><h2 id="Python-切换目录"><a href="#Python-切换目录" class="headerlink" title="Python 切换目录"></a>Python 切换目录</h2><p>执行完，返回之前目录<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cdir</span><span class="params">(path)</span>:</span></span><br><span class="line">    prev_cwd = os.getcwd()</span><br><span class="line">    os.chdir(path)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        os.chdir(prev_cwd)</span><br></pre></td></tr></table></figure></p><p>用法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> cdir(path):</span><br><span class="line">    func()</span><br></pre></td></tr></table></figure></p><h2 id="搜索指定目录下的文件"><a href="#搜索指定目录下的文件" class="headerlink" title="搜索指定目录下的文件"></a>搜索指定目录下的文件</h2><p>将指定目录及其子目录下的文件搜索出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_file</span><span class="params">(start_path, name)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    search the files of name from the dir start_path，存放的是搜索文件的路径</span></span><br><span class="line"><span class="string">    :param start_path: the search scope of dir</span></span><br><span class="line"><span class="string">    :param name: the name of search file</span></span><br><span class="line"><span class="string">    :return: set of files path</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    files_path = set()</span><br><span class="line">    <span class="keyword">for</span> rel_path, dirs, files <span class="keyword">in</span> os.walk(start_path):</span><br><span class="line">        <span class="comment"># if name in files:</span></span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">in</span> f:</span><br><span class="line">                full_path = os.path.join(start_path, rel_path, f)</span><br><span class="line">                path = os.path.normpath(os.path.abspath(full_path))</span><br><span class="line">                files_path.add(path)</span><br><span class="line">    <span class="keyword">return</span> files_path</span><br></pre></td></tr></table></figure><h2 id="只列出文件夹下的文件夹"><a href="#只列出文件夹下的文件夹" class="headerlink" title="只列出文件夹下的文件夹"></a>只列出文件夹下的文件夹</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ name for name in os.listdir(thedir) if os.path.isdir(os.path.join(thedir, name)) ]</span><br><span class="line"></span><br><span class="line">filter(os.path.isdir, os.listdir(os.getcwd()))</span><br></pre></td></tr></table></figure><ul><li><a href="https://stackoverflow.com/questions/141291/how-to-list-only-top-level-directories-in-python" target="_blank" rel="noopener">How to list only top level directories in Python?</a></li></ul><h2 id="Python-Path相关问题"><a href="#Python-Path相关问题" class="headerlink" title="Python Path相关问题"></a>Python Path相关问题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.path.split(<span class="string">r"C:\foo\bar\file_name.txt"</span>)</span><br></pre></td></tr></table></figure><ul><li><a href="http://stackoverflow.org.cn/front/ask/view?ask_id=811828" target="_blank" rel="noopener">格式化文件路径</a></li></ul><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="MySQL-数据库"><a href="#MySQL-数据库" class="headerlink" title="MySQL 数据库"></a>MySQL 数据库</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db = MySQLdb.connect(<span class="string">"localhost"</span>,<span class="string">"your_username"</span>,<span class="string">"your_password"</span>,<span class="string">"your_dbname"</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line">sql = <span class="string">"select Column1,Column2 from Table1"</span></span><br><span class="line">cursor.execute(sql)</span><br><span class="line">results = cursor.fetchall()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> results:</span><br><span class="line">    <span class="keyword">print</span> row[<span class="number">0</span>]+row[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="http://blog.topspeedsnail.com/archives/3918" target="_blank" rel="noopener">斗大的熊猫-最常用的Python代码片段</a></li></ul><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uri=<span class="string">"mongodb://admin:admin@xxx.xxx.xxx.xxx:27017,xxx.xxx.xxx.xxx:27018,xxx.xxx.xxx.xxx:27019/test"</span></span><br><span class="line">client=pymongo.MongoClient(uri,replicaSet=<span class="string">'noah-cluster'</span>,readPreference=<span class="string">'primaryPreferred'</span>)</span><br><span class="line">db=client.get_default_database()</span><br><span class="line">decouple_history=db.rpm_decouple_release_history_info</span><br><span class="line">pprint(decouple_history.find_one(&#123;<span class="string">'service_name'</span>:<span class="string">'test'</span>&#125;))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;list-列表相关&quot;&gt;&lt;a href=&quot;#list-列表相关&quot; class=&quot;headerlink&quot; title=&quot;list 列表相关&quot;&gt;&lt;/a&gt;list 列表相关&lt;/h1&gt;&lt;h2 id=&quot;list-中最小值、最大值&quot;&gt;&lt;a href=&quot;#list-中最小值、最大
      
    
    </summary>
    
      <category term="Python" scheme="https://michael728.github.io/categories/Python/"/>
    
    
      <category term="Snippet" scheme="https://michael728.github.io/tags/Snippet/"/>
    
  </entry>
  
  <entry>
    <title>Python 实用技巧总结</title>
    <link href="https://michael728.github.io/2019/09/07/python-effective-tips/"/>
    <id>https://michael728.github.io/2019/09/07/python-effective-tips/</id>
    <published>2019-09-07T10:10:57.000Z</published>
    <updated>2020-03-05T14:20:44.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模块相关"><a href="#模块相关" class="headerlink" title="模块相关"></a>模块相关</h2><ol><li>导入模块时，可以通过模块的 <code>__file__</code> 属性查看模块所在磁盘的路径位置，参考：<a href="https://foofish.net/package-module-tips.html" target="_blank" rel="noopener">关于Python包和模块的10个知识清单</a></li></ol><h2 id="Pip"><a href="#Pip" class="headerlink" title="Pip"></a>Pip</h2><h3 id="安装Pip"><a href="#安装Pip" class="headerlink" title="安装Pip"></a>安装Pip</h3><p>方法一：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get purge python-pip python3-pip # Ubuntu卸载</span><br><span class="line">wget https://bootstrap.pypa.io/get-pip.py</span><br><span class="line">sudo python3 get-pip.py # 安装py3对应的pip</span><br><span class="line">sudo python get-pip.py # 安装py2对应的pip</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span># centos yum方式</span><br><span class="line">yum install -y python-setuptools</span><br><span class="line">easy_install pip</span><br></pre></td></tr></table></figure><h3 id="Pip命令"><a href="#Pip命令" class="headerlink" title="Pip命令"></a>Pip命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install -U pip #升级pip：</span><br><span class="line">pip list --outdate #查看哪些包有更新：</span><br><span class="line">pip install --upgrade requests  // mac,linux,unix 在命令前加 sudo -H  升级一个包：</span><br><span class="line">pip install -U setuptools    #</span><br><span class="line">conda update setuptools  #</span><br><span class="line">pip freeze --local | grep -v '^\-e' | cut -d = -f 1  | xargs pip install -U # 升级所有包</span><br><span class="line">pip show requests # 查看 package 所在的位置等信息</span><br></pre></td></tr></table></figure><p>pip的配置文件中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[list]                                                # pip list命令接口的展示方式设置</span><br><span class="line">format=columns</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="http://shadow000902.space/2018/03/06/Python%E5%B0%8F%E6%8A%80%E5%B7%A7/" target="_blank" rel="noopener">Python小技巧</a></li><li><a href="https://www.jianshu.com/p/81b648b1d572" target="_blank" rel="noopener">在Linux上安装Python 3</a></li><li><a href="http://www.cnblogs.com/chenzehe/archive/2010/10/20/1856437.html" target="_blank" rel="noopener">linux下python开发环境之一——安装python</a></li><li><a href="http://www.suohi.cc/posts/578ee7ff1f6d1303e9f04a5d" target="_blank" rel="noopener">关于pip安装时提示pkg_resources.DistributionNotFound 错误问题</a></li></ul><h3 id="Pip源"><a href="#Pip源" class="headerlink" title="Pip源"></a>Pip源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.pydistutils.cfg  # 配置distutils的源，easy_install 命令会走这里配置的 pip 源</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="http://everet.org/python-pypi-source.html" target="_blank" rel="noopener">修改pip/setup.py的源</a></li></ul><h2 id="实用"><a href="#实用" class="headerlink" title="实用"></a>实用</h2><h3 id="Python一键搭建Http服务器"><a href="#Python一键搭建Http服务器" class="headerlink" title="Python一键搭建Http服务器"></a>Python一键搭建Http服务器</h3><p>你如果想快速且简单地共享一个目录中的文件，你只需在终端执行下面对应版本的指令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server <span class="number">8000</span> <span class="comment"># Py3</span></span><br><span class="line">python -m SimpleHTTPServer <span class="number">8000</span> <span class="comment"># Py2</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://www.vimiix.com/python_tricks/#4" target="_blank" rel="noopener">Python 技巧</a></li></ul><h3 id="virtualenv创建虚拟环境"><a href="#virtualenv创建虚拟环境" class="headerlink" title="virtualenv创建虚拟环境"></a>virtualenv创建虚拟环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtualenv env</span><br></pre></td></tr></table></figure><p>运行带 <code>--no-site-packages</code> 选项的 virtualenv 将不会包括全局安装的包。 这可用于保持包列表干净，以防以后需要访问它。（<strong>这在 virtualenv 1.7及之后是默认行为</strong>）</p><div class="note warning no-icon">            <p>–no-site-packages    DEPRECATED. Retained only for backward compatibility.<br>                     Not having access to global site-packages is now the<br>                    default behavior.</p>          </div><p>参考：<a href="https://pythonguidecn.readthedocs.io/zh/latest/dev/virtualenvs.html" target="_blank" rel="noopener">Pipenv &amp; 虚拟环境</a></p><h2 id="ipyhon"><a href="#ipyhon" class="headerlink" title="ipyhon"></a>ipyhon</h2><p><code>hist</code> 显示之前的代码，不显示行号，方便复制</p><h2 id="jupyter-notebook"><a href="#jupyter-notebook" class="headerlink" title="jupyter notebook"></a>jupyter notebook</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyter_contrib_nbextensions &amp;&amp; jupyter contrib nbextension install</span><br></pre></td></tr></table></figure><p>安装好 jupyter notebook 插键之后，可以在 <code>Nbextensions</code> 菜单选项卡中勾选启用相关扩展功能，下面是比较好用的扩展：</p><ul><li>Table of Contents：更容易导航</li><li>Autopep8：轻轻一击就能获得简洁代码</li><li>variable inspector：跟踪你的工作空间</li><li>ExecuteTime：显示单元格的运行时间和耗时</li><li>隐藏代码输入：隐藏过程，展示结果</li></ul><p>参考：<a href="https://www.jiqizhixin.com/articles/2018-12-20-12" target="_blank" rel="noopener">机器之心——我知道你会用Jupyter Notebook，但这些插件你都会了吗？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模块相关&quot;&gt;&lt;a href=&quot;#模块相关&quot; class=&quot;headerlink&quot; title=&quot;模块相关&quot;&gt;&lt;/a&gt;模块相关&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;导入模块时，可以通过模块的 &lt;code&gt;__file__&lt;/code&gt; 属性查看模块所在磁盘的路径位置，参考：&lt;
      
    
    </summary>
    
      <category term="Python" scheme="https://michael728.github.io/categories/Python/"/>
    
    
      <category term="Tips" scheme="https://michael728.github.io/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>那些年我剁手的极客时间课程</title>
    <link href="https://michael728.github.io/2019/09/01/resource-it-geektime/"/>
    <id>https://michael728.github.io/2019/09/01/resource-it-geektime/</id>
    <published>2019-09-01T23:55:08.000Z</published>
    <updated>2020-03-05T14:20:44.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天看了看在「极客时间」里构建的课程，发现已经挺多的了，认真看多的却挺少，下面是我觉得值得一看的课程，老师讲的都挺认真、内容不水！今年下半年目标就把他们消化消化就足够了~</p><p>PS：此外，有需要的小伙伴也可以扫码购买，目前极客时间的返利规则已由原来的购买者和我都获得返利变为仅仅我能收到返利。所以，如果你是通过扫下面的码购买课程，可以保存下截图，加我微信，我会返利一半给你，这样也能给你带去优惠 🤓</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/微信二维码-翔.jpeg" alt="wechat"></p><h2 id="趣谈-Linux-操作系统"><a href="#趣谈-Linux-操作系统" class="headerlink" title="趣谈 Linux 操作系统"></a>趣谈 Linux 操作系统</h2><p><img src="https://gitee.com/michael_xiang/images/raw/master/趣谈Linux操作系统.jpeg" alt="趣谈 Linux 操作系统"></p><h2 id="趣谈网络协议"><a href="#趣谈网络协议" class="headerlink" title="趣谈网络协议"></a>趣谈网络协议</h2><p><img src="https://gitee.com/michael_xiang/images/raw/master/趣谈网络协议.jpeg" alt="趣谈网络协议"></p><h2 id="算法面试通过40讲"><a href="#算法面试通过40讲" class="headerlink" title="算法面试通过40讲"></a>算法面试通过40讲</h2><p><img src="https://gitee.com/michael_xiang/images/raw/master/算法面试通过40讲.jpeg" alt="算法面试通过40讲"></p><h2 id="玩转Git三剑客"><a href="#玩转Git三剑客" class="headerlink" title="玩转Git三剑客"></a>玩转Git三剑客</h2><p><img src="https://gitee.com/michael_xiang/images/raw/master/玩转Git三剑客.jpeg" alt="玩转Git三剑客"></p><h2 id="左耳朵耗子"><a href="#左耳朵耗子" class="headerlink" title="左耳朵耗子"></a>左耳朵耗子</h2><p><img src="https://gitee.com/michael_xiang/images/raw/master/左耳朵耗子.jpeg" alt="左耳朵耗子"></p><h2 id="MySQL实战45讲"><a href="#MySQL实战45讲" class="headerlink" title="MySQL实战45讲"></a>MySQL实战45讲</h2><p><img src="https://gitee.com/michael_xiang/images/raw/master/MySQL实战45讲.jpeg" alt="MySQL实战45讲"></p><h2 id="Nginx核心知识100讲"><a href="#Nginx核心知识100讲" class="headerlink" title="Nginx核心知识100讲"></a>Nginx核心知识100讲</h2><p><img src="https://gitee.com/michael_xiang/images/raw/master/Nginx核心知识100讲.jpeg" alt="Nginx核心知识100讲"></p><h2 id="Web协议详解与抓包实战"><a href="#Web协议详解与抓包实战" class="headerlink" title="Web协议详解与抓包实战"></a>Web协议详解与抓包实战</h2><p><img src="https://gitee.com/michael_xiang/images/raw/master/Web协议详解与抓包实战.jpeg" alt="Web协议详解与抓包实战"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天看了看在「极客时间」里构建的课程，发现已经挺多的了，认真看多的却挺少，下面是我觉得值得一看的课程，老师讲的都挺认真、内容不水！今年下半年
      
    
    </summary>
    
      <category term="阅读" scheme="https://michael728.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="资源" scheme="https://michael728.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
      <category term="返利" scheme="https://michael728.github.io/tags/%E8%BF%94%E5%88%A9/"/>
    
      <category term="课程" scheme="https://michael728.github.io/tags/%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>IT 基础 —— 开源协议</title>
    <link href="https://michael728.github.io/2019/08/25/it-basic-open-source-protocol/"/>
    <id>https://michael728.github.io/2019/08/25/it-basic-open-source-protocol/</id>
    <published>2019-08-25T22:49:10.000Z</published>
    <updated>2020-03-05T14:20:44.459Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/michael_xiang/images/raw/master/osi_keyhole_300X300_90ppi.png" alt="OSI Logo"></p><h2 id="什么是开源"><a href="#什么是开源" class="headerlink" title="什么是开源"></a>什么是开源</h2><p>发展史</p><ul><li>1969 年，贝尔实验室将 Unix 代码共享给社区，为开源奠定了重要基础。</li><li>1984 年，Richard Stallman 离开 MIT，发起 GUN 项目，希望使用自由代码构建一个类 Unix 的操作系统。此后，Stallman 创立自由软件基金会（FSF），发起 GNU 通用公共协议证书（GNU General Public License, GNU GPL），开发了 GCC、Emacs 等一系列重要产品。</li><li>1991 年，Linus Torvalds 在 GPL 协议下发布了 Linux 操作系统内核。</li><li>1995 年，Apache 诞生，随即占据 Web 服务器大部分市场份额。</li><li>2000 年，开源延伸至移动和云领域，由 Google 等大企业驱动，影响技术发展路线和市场格局。</li><li>2008 年，Github 等代码托管平台，采用 pull/request 等方式协同合作，将开源推向了新高度。</li><li>2014 年，Google 开源 Kubernetes，获得极大关注。经过几年发展，Kubernetes 成为事实上的分布式架构平台。</li></ul><a id="more"></a><h2 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h2><p>软件的开源协议授予所有用户使用，修改以及共享的权限，并明确表示了哪些行为是准许的，哪些行为是禁止的。不同的开源协议，也有不同的侧重点。</p><h3 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h3><p>我们很熟悉的 Linux 是采用了 GPL。GPL 协议和 BSD、 MIT 等鼓励代码重用的许可很不一样。GPL 要求修改后的代码或者衍生品，也要采用 GPL 协议，既修改后的代码或者衍生品，必须也是开源和免费的。</p><h3 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h3><p>是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。</p><h3 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h3><p>MIT 与 BSD 类似，但是比 BSD 协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。</p><div class="note warning">            <p>因此，一些公司往往需要小心 GPL（GPL、AGPL、SSPL）的使用</p>          </div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>放两张关于开源协议的总结，非常简洁易懂：</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/free_software_licenses.png" alt="如何选择开源许可证"></p><p>上图来自：<a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html" target="_blank" rel="noopener">阮一峰-如何选择开源许可证？</a></p><p><img src="https://gitee.com/michael_xiang/images/raw/master/pudhS6.png" alt="选择一个开源软件协议"></p><p>上图来自：<a href="http://choosealicense.online/" target="_blank" rel="noopener">选择一个开源软件协议</a> 对应英文网址<a href="https://choosealicense.com" target="_blank" rel="noopener">Choose an open source license</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.kenzhishi.com/1731.html" target="_blank" rel="noopener">开源软件是什么意思？闭源呢？</a> 一个 UP 主的博客</li><li><a href="https://opensource.org/licenses" target="_blank" rel="noopener">About Open Source Licenses</a></li><li><a href="https://www.chenshaowen.com/blog/open-source-is-refactoring-the-business-model.html" target="_blank" rel="noopener">陈少文-开源正在重构商业模式</a></li><li><a href="https://opensource.org/node/442" target="_blank" rel="noopener">opensource-logo</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/michael_xiang/images/raw/master/osi_keyhole_300X300_90ppi.png&quot; alt=&quot;OSI Logo&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是开源&quot;&gt;&lt;a href=&quot;#什么是开源&quot; class=&quot;headerlink&quot; title=&quot;什么是开源&quot;&gt;&lt;/a&gt;什么是开源&lt;/h2&gt;&lt;p&gt;发展史&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1969 年，贝尔实验室将 Unix 代码共享给社区，为开源奠定了重要基础。&lt;/li&gt;
&lt;li&gt;1984 年，Richard Stallman 离开 MIT，发起 GUN 项目，希望使用自由代码构建一个类 Unix 的操作系统。此后，Stallman 创立自由软件基金会（FSF），发起 GNU 通用公共协议证书（GNU General Public License, GNU GPL），开发了 GCC、Emacs 等一系列重要产品。&lt;/li&gt;
&lt;li&gt;1991 年，Linus Torvalds 在 GPL 协议下发布了 Linux 操作系统内核。&lt;/li&gt;
&lt;li&gt;1995 年，Apache 诞生，随即占据 Web 服务器大部分市场份额。&lt;/li&gt;
&lt;li&gt;2000 年，开源延伸至移动和云领域，由 Google 等大企业驱动，影响技术发展路线和市场格局。&lt;/li&gt;
&lt;li&gt;2008 年，Github 等代码托管平台，采用 pull/request 等方式协同合作，将开源推向了新高度。&lt;/li&gt;
&lt;li&gt;2014 年，Google 开源 Kubernetes，获得极大关注。经过几年发展，Kubernetes 成为事实上的分布式架构平台。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="IT 基础" scheme="https://michael728.github.io/categories/IT-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="开源" scheme="https://michael728.github.io/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="基础" scheme="https://michael728.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>DevOps 之 ELK 基础设施搭建</title>
    <link href="https://michael728.github.io/2019/08/14/cicd-elk-install/"/>
    <id>https://michael728.github.io/2019/08/14/cicd-elk-install/</id>
    <published>2019-08-14T22:10:57.000Z</published>
    <updated>2020-03-05T14:20:44.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="https://gitee.com/michael_xiang/images/raw/master/201909078-elk.png" alt="ELK"></p><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><p>官方的<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" target="_blank" rel="noopener">Elasticsearch Reference</a> 文档是相当全面了，而且，不同版本都可以切换，真是赞！如果英文的不想看，还提供了中文版的 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html" target="_blank" rel="noopener">Elasticsearch: 权威指南</a>，虽然可能版本不是最新的，但是了解基本概念也是有帮助的。</p><p>Elasticsearch 包里自包含了 OpenJDK 的包，在 Elacticsearch 目录下的 <code>jdk</code> 目录中。如果你想要使用你自己配置好的 Java 版本，需要设置 <code>JAVA_HOME</code> 环境变量。</p><p>官方文档的 <code>Set up Elasticsearch</code> 下面有安装的指导，具体页面 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/install-elasticsearch.html" target="_blank" rel="noopener">Installing Elasticsearch</a> 中提供了多种安装包对应的指导链接！本文就先选择 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/targz.html" target="_blank" rel="noopener">tar 包</a>的方式安装。</p><p>由于本地机器有限，我们在同一台机器上模拟出 3 个节点，安装 ES 集群。</p><h3 id="下载-ES-安装包"><a href="#下载-ES-安装包" class="headerlink" title="下载 ES 安装包"></a>下载 ES 安装包</h3><p>官网的下载地址简直是龟速，发现我司的<a href="https://mirrors.huaweicloud.com/elasticsearch/" target="_blank" rel="noopener">镜像站</a>上提供了安装包，试用后安利，速度不错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.huaweicloud.com/elasticsearch/7.3.0/</span><br><span class="line">wget https://mirrors.huaweicloud.com/elasticsearch/7.3.0/elasticsearch-7.3.0-linux-x86_64.tar.gz.sha512</span><br><span class="line"><span class="meta">#</span> 验证安装包的完整性，如果没问题，会输出 OK</span><br><span class="line">shasum -a 512 -c elasticsearch-7.3.0-linux-x86_64.tar.gz.sha512</span><br><span class="line">tar -xzf elasticsearch-7.3.0-linux-x86_64.tar.gz</span><br><span class="line">cp -R elasticsearch-7.3.0 es-node1</span><br><span class="line">cp -R elasticsearch-7.3.0 es-node2</span><br><span class="line">mv elasticsearch-7.3.0 es-node3</span><br><span class="line">chown -R michael es-node* # 因为以 root 用户启动不了 ES</span><br></pre></td></tr></table></figure><p>下文的 <code>$ES_HOME</code> 就是指这里 tar 包解压后的文件夹目录，目录组成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── bin # 二进制脚本存放目录，包括 elasticsearch 来指定运行一个 node，包括 elasticsearch-plugin 来安装 plugins</span><br><span class="line">├── config # 包含了 elasticsearch.yml 配置文件</span><br><span class="line">├── data # 节点上分配的每个 index/分片 的数据文件</span><br><span class="line">├── jdk</span><br><span class="line">├── lib</span><br><span class="line">├── LICENSE.txt</span><br><span class="line">├── logs</span><br><span class="line">├── modules</span><br><span class="line">├── NOTICE.txt</span><br><span class="line">├── plugins # 插键文件存放的位置</span><br><span class="line">└── README.textile</span><br></pre></td></tr></table></figure><h3 id="使用命令行运行-Elasticsearch"><a href="#使用命令行运行-Elasticsearch" class="headerlink" title="使用命令行运行 Elasticsearch"></a>使用命令行运行 Elasticsearch</h3><p>首先，我们先运行一个节点起来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch</span><br></pre></td></tr></table></figure><div class="note warning">            <p>不能使用 root 账号运行上面的命令，否则会报错：</p>undefined          </div><p>如果需要新建用户的话可以运行 <code>adduser michael</code>，修改密码：<code>passwd michael</code>，然后 <code>chown -R es-node*</code>。</p><h3 id="检查一下运行状态"><a href="#检查一下运行状态" class="headerlink" title="检查一下运行状态"></a>检查一下运行状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET "localhost:9200/?pretty"</span><br></pre></td></tr></table></figure><p>或者在浏览器中访问 <code>localhost:9200</code> 都可以，会返回：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "name": "node-1",</span><br><span class="line">    "cluster_name": "michael-es",</span><br><span class="line">    "cluster_uuid": "GlzI_v__QJ2s9ewAgomOqg",</span><br><span class="line">    "version": &#123;</span><br><span class="line">        "number": "7.3.0",</span><br><span class="line">        "build_flavor": "default",</span><br><span class="line">        "build_type": "tar",</span><br><span class="line">        "build_hash": "de777fa",</span><br><span class="line">        "build_date": "2019-07-24T18:30:11.767338Z",</span><br><span class="line">        "build_snapshot": false,</span><br><span class="line">        "lucene_version": "8.1.0",</span><br><span class="line">        "minimum_wire_compatibility_version": "6.8.0",</span><br><span class="line">        "minimum_index_compatibility_version": "6.0.0-beta1"</span><br><span class="line">    &#125;,</span><br><span class="line">    "tagline": "You Know, for Search"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你是在服务器上部署的 ES，那么，在你的工作机上目前还无法调用通 <code>&lt;IP&gt;:9200</code>，需要一些配置才可以。后面会介绍。</p><h3 id="作为守护进程运行"><a href="#作为守护进程运行" class="headerlink" title="作为守护进程运行"></a>作为守护进程运行</h3><p>要将 ES 作为守护程序运行，请在命令行中指定 <code>-d</code>，指定 <code>-p</code> 参数，将进程 ID 记录到 <code>pid</code> 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch -d -p pid</span><br></pre></td></tr></table></figure><p>日志在 <code>$ES_HOME/logs</code> 目录中。</p><p>如果想停止  ES，运行如下的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill -F pid</span><br></pre></td></tr></table></figure><h3 id="在命令行配置-ES"><a href="#在命令行配置-ES" class="headerlink" title="在命令行配置 ES"></a>在命令行配置 ES</h3><p>ES 默认会加载位于 <code>$ES_HOME/config/elasticsearch.yml</code> 的配置文件。</p><p>任何能够通过配置文件设置的内容，都可以通过命令行使用 <code>-E</code> 的语法进行指定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch -d -Ecluster.name=my_cluster -Enode.name=node_1</span><br></pre></td></tr></table></figure><div class="note info">            <p>通常，任何群集范围的设置（如cluster.name）都应添加到elasticsearch.yml配置文件中，而任何特定于节点的设置（如node.name）都可以在命令行中指定</p>          </div><h3 id="配置-ES"><a href="#配置-ES" class="headerlink" title="配置 ES"></a>配置 ES</h3><p>官网关于配置的内容主要有两处：</p><ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/important-settings.html" target="_blank" rel="noopener">Important Elasticsearch configuration</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html" target="_blank" rel="noopener">Configuraing Elasticsearch</a> 做了说明。</li></ul><p>本文仅搭建一个单节点的 ES 服务，未搭建集群。</p><ul><li>设置集群名称</li></ul><p>通过 <code>cluster.name</code> 可以设置集群的名称：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster.name: michael-es</span><br></pre></td></tr></table></figure><p>通过 <code>node.name</code> 可以配置每个节点的名称，集群中每个节点的名称都不要相同</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.name: node-1</span><br></pre></td></tr></table></figure><ul><li>设置访问的地址和端口</li></ul><p>我们需要设定 ES 运行绑定的 Host，默认是无法公开访问的！如果设置为主机的公网 IP 或 <code>0.0.0.0</code> 就是可以公开访问的，可以都设置为公开访问或者部分主机公开访问。如果是公开访问就配置为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">network.host: 0.0.0.0</span><br></pre></td></tr></table></figure><p>另外，可以更改端口，默认端口是 9200 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.port: 9200</span><br></pre></td></tr></table></figure><div class="note warning">            <p>注意：这是指 http 端口，如果采用 REST API 对接 ES，那么就是采用的 http 协议</p>          </div><ul><li>集群地址设置</li></ul><p>配置集群的主机地址，配置之后集群的主机之间可以自动发现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discovery.seed_hosts: ["192.168.3.43"]</span><br></pre></td></tr></table></figure><blockquote><p>the default discovery settings are unsuitable for production use; at least one of [discovery.seed_hosts, discovery.seed_providers, cluster.initial_master_nodes] must be configured</p></blockquote><p>必须至少配置 <code>[discovery.seed_hosts，discovery.seed_providers，cluster.initial_master_nodes]</code> 中的一个。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> egrep -v "^#|^$" config/elasticsearch.yml</span><br><span class="line">cluster.name: michael-es</span><br><span class="line">node.name: node-1</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line">http.port: 9200</span><br><span class="line">discovery.seed_hosts: ["192.168.3.43"]</span><br><span class="line">cluster.initial_master_nodes: ["node-1"]</span><br></pre></td></tr></table></figure><p>经过上面的配置，这时候就可以使用 <code>http://192.168.3.43:9200/</code> 看到结果了。</p><p>关于 cluster.initial_master_nodes 可以查看如下资料</p><ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/modules-discovery-bootstrap-cluster.html" target="_blank" rel="noopener">Bootstrapping a cluster</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-discovery-settings.html" target="_blank" rel="noopener">Discovery and cluster formation settings</a></li></ul><h3 id="安装插键"><a href="#安装插键" class="headerlink" title="安装插键"></a>安装插键</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch-plugin install analysis-icu</span><br></pre></td></tr></table></figure><p>如果插键安装慢，可以先下载下来，再安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch-plugins/analysis-icu/analysis-icu-7.1.0.zip</span><br><span class="line">./bin/elasticsearch-plugin install file://file path Of analysis-icu-7.1.0.zip</span><br></pre></td></tr></table></figure><h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><p>分别进入对应 es-node2 和 es-node3 的文件夹，设置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> es-node2</span><br><span class="line">cluster.name: michael-es</span><br><span class="line">node.name: node-2</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line">discovery.seed_hosts: ["192.168.3.43"]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> es-node3</span><br><span class="line">cluster.name: michael-es</span><br><span class="line">node.name: node-3</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line">discovery.seed_hosts: ["192.168.3.43"]</span><br></pre></td></tr></table></figure><p>我们通过访问 <code>http://192.168.3.43:9200/_cat/nodes</code>查看集群是否 OK：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">172.20.0.1 18 98 35 1.16 0.69 0.58 dim - node-2</span><br><span class="line">172.20.0.1 14 98 35 1.16 0.69 0.58 dim - node-3</span><br><span class="line">172.20.0.1 19 98 35 1.16 0.69 0.58 dim * node-1</span><br></pre></td></tr></table></figure><p>有没有发现，我并没有给 <code>es-node2</code> 和 <code>es-node3</code> 明确的指定端口，为什么在一台机器上也成功启动了这两个节点？因为 Elasticsearch 会取用 9200~9299 这个范围内的端口，如果 9200 被占用，就选择 9201，依次类推。</p><p>其实，还有一个跟简单的方法创建集群，我们首先将上面运行的三个节点停止掉，然后进入 es-node1 文件夹下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p data/data&#123;1,2,3&#125;</span><br><span class="line">./bin/elasticsearch -E node.name=node-1 -E cluster.name=michael-es -E path.data=data/data1 -E path.logs=logs/logs1 -d -p pid1</span><br><span class="line">./bin/elasticsearch -E node.name=node-2 -E cluster.name=michael-es -E path.data=data/data2 -E path.logs=logs/logs2 -E http.port=9201 -d -p pid2</span><br><span class="line">./bin/elasticsearch -E node.name=node-3 -E cluster.name=michael-es -E path.data=data/data3 -E path.logs=logs/logs3 -E http.port=9202 -d -p pid3</span><br></pre></td></tr></table></figure><h3 id="ES-FAQ"><a href="#ES-FAQ" class="headerlink" title="ES-FAQ"></a>ES-FAQ</h3><p>Q1：<code>[1]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo "vm.max_map_count=262144" &gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>Q2：<code>max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/security/limits.conf</span><br><span class="line"><span class="meta">#</span> 加入以下内容</span><br><span class="line">* soft nofile 300000</span><br><span class="line">* hard nofile 300000</span><br><span class="line">* soft nproc 102400</span><br><span class="line">* soft memlock unlimited</span><br><span class="line">* hard memlock unlimited</span><br></pre></td></tr></table></figure><p>Q3：<code>master_not_discovered_exception</code></p><p>主节点指定的名字要保证存在，别指定了不存在的节点名。</p><h2 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h2><p>官方文档 <a href="https://www.elastic.co/guide/en/kibana/current/install.html" target="_blank" rel="noopener">Installing Kibana</a> 中提供了多种安装包对应的指导链接！本文就先选择 <a href="https://www.elastic.co/guide/en/kibana/current/targz.html" target="_blank" rel="noopener">tar 包</a>的方式安装。</p><h3 id="下载-Kibana-安装包"><a href="#下载-Kibana-安装包" class="headerlink" title="下载 Kibana 安装包"></a>下载 Kibana 安装包</h3><p>同样，Kibana 在我司镜像站上也有对应的软件包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">https://mirrors.huaweicloud.com/kibana/7.3.0/</span><br><span class="line">wget https://mirrors.huaweicloud.com/kibana/7.3.0/kibana-7.3.0-linux-x86_64.tar.gz</span><br><span class="line">wget https://mirrors.huaweicloud.com/kibana/7.3.0/kibana-7.3.0-linux-x86_64.tar.gz.sha512</span><br><span class="line">shasum -a 512 -c elasticsearch-7.3.0-linux-x86_64.tar.gz.sha512</span><br><span class="line">tar xzf kibana-7.3.0-linux-x86_64.tar.gz</span><br><span class="line">chown -R michael kibana-7.3.0-linux-x86_64</span><br><span class="line">cd kibana-7.3.0-linux-x86_64</span><br></pre></td></tr></table></figure><h3 id="配置-Kibana"><a href="#配置-Kibana" class="headerlink" title="配置 Kibana"></a>配置 Kibana</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">egrep -v "^#|^$" config/kibana.yml # 如下内容是修改的配置</span><br><span class="line">server.port: 5601</span><br><span class="line">server.host: "0.0.0.0"</span><br><span class="line">elasticsearch.hosts: ["http://192.168.3.43:9200"]</span><br><span class="line">kibana.index: ".kibana"</span><br></pre></td></tr></table></figure><p>更多配置内容，可以阅读 <a href="https://www.elastic.co/guide/en/kibana/current/settings.html" target="_blank" rel="noopener">Configuring Kibana</a></p><h3 id="运行-Kibana"><a href="#运行-Kibana" class="headerlink" title="运行 Kibana"></a>运行 Kibana</h3><p>如下方式可以实现后台运行，避免 Ctrl+C 终止了程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup bin/kibana &amp;</span><br></pre></td></tr></table></figure><p>访问：<code>http://192.168.3.43:5601/</code></p><p>这时候可以看到我们之前搭建的集群节点了：</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/Dg7DMe.png" alt="Kiana-ES"></p><h2 id="Filebeat-amp-amp-Logstash"><a href="#Filebeat-amp-amp-Logstash" class="headerlink" title="Filebeat &amp;&amp; Logstash"></a>Filebeat &amp;&amp; Logstash</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://mirrors.huaweicloud.com/filebeat/7.3.0/</span><br><span class="line">wget https://mirrors.huaweicloud.com/filebeat/7.3.0/filebeat-7.3.0-linux-x86_64.tar.gz</span><br><span class="line">wget https://mirrors.huaweicloud.com/filebeat/7.3.0/filebeat-7.3.0-linux-x86_64.tar.gz.sha512</span><br></pre></td></tr></table></figure><p>目前项目中是采用的直接往 Elasticsearch 中存储数据 + Kibana 展示数据的方式。所以，<a href="https://www.elastic.co/cn/products/beats/filebeat" target="_blank" rel="noopener">Filebeat</a> 和 Logstash 暂时没接触过。不过，在 B 站上看到一位 UP 主发了很多相关的学习教程，安利一下：</p><ul><li><a href="https://www.bilibili.com/video/av23720863" target="_blank" rel="noopener">EP26 - 安装与初始化配置ELK 6</a></li><li><a href="https://ngx.hk/?s=elk" target="_blank" rel="noopener">ELK搜索结果</a> 上面这位 UP 主的博客</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文是通过 tar 包方式安装的，发现，还不如用 RPM 包来的方便。不过配置的内容其实差不多，区别可能就是，RPM 包方式，可以直接用 systemctl 的命令查看状态、重启等。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/04f4d7b4a1d3" target="_blank" rel="noopener">程序羊-CentOS7上ElasticSearch安装填坑记</a> FAQ 有帮助</li><li><a href="https://time.geekbang.org/course/detail/197-102661" target="_blank" rel="noopener">极客时间-Elasticsearch核心技术与实战</a> 这篇文章阐述了 ES 集群的主节点的仲裁等知识</li><li><a href="https://jeremy-xu.oschina.io/2018/10/%E6%90%AD%E5%BB%BAelfk%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">搭建ELFK日志采集系统</a></li><li><a href="https://cuiqingcai.com/6255.html" target="_blank" rel="noopener">静觅—Ubuntu 搭建 Elasticsearch 6 集群流程</a></li><li><a href="https://www.ruanyifeng.com/blog/2017/08/elasticsearch.html" target="_blank" rel="noopener">阮一峰-全文搜索引擎 Elasticsearch 入门教程</a></li><li><a href="https://www.cnblogs.com/xishuai/p/elk-elasticsearch-kibana.html" target="_blank" rel="noopener">ELK 架构之 Elasticsearch 和 Kibana 安装配置</a></li><li><a href="https://wsgzao.github.io/post/elk/" target="_blank" rel="noopener">使用 ELK(Elasticsearch + Logstash + Kibana) 搭建日志集中分析平台实践</a></li><li><a href="http://www.justdojava.com/2019/08/11/elk-install/" target="_blank" rel="noopener">手把手教你，在CentOS上安装ELK，进行服务器日志收集</a></li></ul><p>Filebeat</p><ul><li><a href="https://www.cnblogs.com/cjsblog/p/9445792.html" target="_blank" rel="noopener">博客园-开始使用Filebeat</a></li></ul><p>SpringBoot+ES</p><ul><li><a href="https://my.oschina.net/zhaixingzu/blog/3010467" target="_blank" rel="noopener">【ES】Java High Level REST Client 使用示例（增加修改）</a></li><li><a href="https://www.jianshu.com/p/c1f2161a5d22" target="_blank" rel="noopener">Elasticsearch Java Rest Client 上手指南（上）</a></li><li><a href="https://www.cnblogs.com/guozp/archive/2018/04/02/8686904.html" target="_blank" rel="noopener">博客园——springboot elasticsearch 集成注意事项</a></li><li><a href="https://www.cnblogs.com/leeSmall/p/9218779.html" target="_blank" rel="noopener">lasticsearch系列七：ES Java客户端-Elasticsearch Java client（ES Client 简介、Java REST Client、Java Client、Spring Data Elasticsearch）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/michael_xiang/images/raw/master/201909078-
      
    
    </summary>
    
      <category term="DevOps" scheme="https://michael728.github.io/categories/DevOps/"/>
    
    
      <category term="DevOps" scheme="https://michael728.github.io/tags/DevOps/"/>
    
      <category term="CICD" scheme="https://michael728.github.io/tags/CICD/"/>
    
      <category term="ELK" scheme="https://michael728.github.io/tags/ELK/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 实战 —— 通过 Sentry 收集 Log4j2 异常日志记录</title>
    <link href="https://michael728.github.io/2019/08/11/java-spring-boot-sentry-log4j2/"/>
    <id>https://michael728.github.io/2019/08/11/java-spring-boot-sentry-log4j2/</id>
    <published>2019-08-11T11:49:10.000Z</published>
    <updated>2020-03-05T14:20:44.459Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/michael_xiang/images/raw/master/xOgFTp.png" alt="Sentry-Robot"></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在日常线上运行的应用中如果报了异常，怎么在第一时间收到报错告警并且查看报错日志呢？周五就因为缺乏报错日志，导致构建服务受影响超过了 2 小时，虽然不至于「死人」，但是也确实让我意识到日志的重要性！后来临时在相关的地方加上日志，通过错误信息很快定位了到了原因，原来是数据库被运维人员做了新特性的改动，而我们服务还未适配好。想想当时的场景，还真是有点紧张~囧</p><p>今天就学习一下利用 <a href="https://sentry.io/welcome/" target="_blank" rel="noopener">Sentry</a> 作为日志收集系统，结合之前学习的 <a href="https://michael728.github.io/2019/08/17/java-spring-boot-log4j2/">log4j2</a> 日志输出，主动收集异常日志。</p><a id="more"></a><h2 id="Sentry"><a href="#Sentry" class="headerlink" title="Sentry"></a>Sentry</h2><p>我们先来 Sentry 是怎么介绍自己的：</p><blockquote><p>Open-source error tracking that helps developers monitor and fix crashes in real time. Iterate continuously. Boost efficiency. Improve user experience</p></blockquote><p>大体意思就是：Sentry 是一款开源的错误跟踪系统，可帮助开发人员实时监控和修复崩溃。它是不断迭代的，提高效率，改善用户体验。Sentry 本身的文档也记载的比较全面，强烈安利，一般问题可以通过阅读 <a href="https://docs.sentry.io/" target="_blank" rel="noopener">Doc</a> 学习或者<a href="https://forum.sentry.io/" target="_blank" rel="noopener">论坛咨询</a>。</p><p>OK，下面我们就开始通过 Docker 安装 Sentry。</p><p>PS：如果你的 Docker 环境还未配置好，可以阅读我之前的总结：<a href="https://michael728.github.io/2019/06/01/docker-centos-install/">Linux——CentOS 安装 Docker 教程</a></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>在 <a href="https://docs.sentry.io/server/installation/" target="_blank" rel="noopener">Sentry Installation 页面</a>，官方做了总结，Sentry 需要和几个服务有交互：</p><ul><li><a href="http://www.postgresql.org/" target="_blank" rel="noopener">PostgreSQL</a>：Docker image <a href="https://hub.docker.com/_/postgres/" target="_blank" rel="noopener">postgres:9.5</a>，这里明确版本是 9.5，我觉得非常棒！这保证了在未来部署的可重现，避免了不同版本差异造成部署失败的问题。</li><li><a href="https://redis.io/" target="_blank" rel="noopener">Redis</a><ul><li>官方说如果你使用的 Ubuntu &lt; 15.04，推荐安装 <a href="https://launchpad.net/~chris-lea/+archive/ubuntu/redis-server" target="_blank" rel="noopener">chirs-lea/redis-server</a></li><li>文档推荐的是 Docker image <a href="https://hub.docker.com/_/redis/" target="_blank" rel="noopener">redis:3.2-alpine</a>.</li></ul></li></ul><p>硬件要求，具体的可以阅读<a href="https://docs.sentry.io/server/installation/#hardware" target="_blank" rel="noopener">官方文档</a>，我这里仅仅是家里测试使用，因此无所谓。</p><p>下面的步骤其实是官方文档的翻译，但是，跟着走了一遍之后发现，服务并不能正常运行起来，但是也没啥坏处，主要步骤其实就和这个差不多，可能是某些细节漏了，因此，你可以大体浏览一下步骤。如果不想浪费时间，可以直接跳到下面的 「脚本一键安装 Sentry」小节。</p><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><p>需要 <a href="https://www.docker.com/get-started" target="_blank" rel="noopener">Docker 版本 1.10+</a></p><p>克隆仓库 <a href="https://github.com/getsentry/onpremise" target="_blank" rel="noopener">getsentry/onpremise</a>。这个仓库是定制化构建你自己 Sentry 镜像的基础：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /data</span><br><span class="line">git clone https://github.com/getsentry/onpremise.git</span><br><span class="line">cd onpremise</span><br></pre></td></tr></table></figure><p>仓库里的 <code>sentry.conf.py and config.yml</code> 可供你 <a href="https://docs.sentry.io/server/config/" target="_blank" rel="noopener">配置 Sentry</a> 所用，建议先浏览一下这个配置文档。</p><p>现在开始构建我们定制好的镜像。如果你构建的镜像需要推送到你本地的镜像仓中，那么可以用如下方式先定义好镜像名再构建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY=registry.michael.com/sentry make build push</span><br></pre></td></tr></table></figure><p>我本地没有镜像仓，只需要用如下方式构建即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make build</span><br></pre></td></tr></table></figure><h3 id="运行依赖的服务"><a href="#运行依赖的服务" class="headerlink" title="运行依赖的服务"></a>运行依赖的服务</h3><p>Redis:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --detach \</span><br><span class="line">  --name sentry-redis \</span><br><span class="line">  redis:3.2-alpine</span><br></pre></td></tr></table></figure><p>PostgreSQL:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --detach \</span><br><span class="line">  --name sentry-postgres \</span><br><span class="line">  --env POSTGRES_PASSWORD=secret \</span><br><span class="line">  --env POSTGRES_USER=sentry \</span><br><span class="line">  postgres:9.5</span><br></pre></td></tr></table></figure><p>Outbound Email:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --detach \</span><br><span class="line">  --name sentry-smtp \</span><br><span class="line">  tianon/exim4</span><br></pre></td></tr></table></figure><h3 id="运行-Sentry-服务"><a href="#运行-Sentry-服务" class="headerlink" title="运行 Sentry 服务"></a>运行 Sentry 服务</h3><p><code>${REPOSITORY}</code> 只的是你刚刚定义的镜像名，如果没有，默认是 <code>sentry-onpremise</code>。</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/cTlup8.png" alt="REPOSITORY"></p><p>为了测试镜像是 OK 的，可以运行如下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --rm $&#123;REPOSITORY&#125; \</span><br><span class="line">  --help</span><br></pre></td></tr></table></figure><p>现在可以生成一个 <code>secret-key</code> 值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --rm $&#123;REPOSITORY&#125; \</span><br><span class="line">  config generate-secret-key</span><br></pre></td></tr></table></figure><p>生成的值可以在 <code>config.yml</code> 中设置给 <code>system.secret-key</code>,或者通过环境变量。如果是设置在 <code>config.yml</code> 文件中，这时候你必须重新构建你的镜像。</p><p>运行的基本命令举例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --detach \</span><br><span class="line">  --link sentry-redis:redis \</span><br><span class="line">  --link sentry-postgres:postgres \</span><br><span class="line">  --link sentry-smtp:smtp \</span><br><span class="line">  --env SENTRY_SECRET_KEY='&lt;secret-key&gt;' \</span><br><span class="line"><span class="meta">  $</span>&#123;REPOSITORY&#125; \</span><br><span class="line">  &lt;command&gt;</span><br></pre></td></tr></table></figure><div class="note warning">            <p>官方文档里有一行小字，说明的是后面的文档，不会特地的写上 –link 去表示链接容器，但是这些都是必须的！同时，${REPOSITORY} 会被引用为 sentry-onpremise。</p>          </div><h4 id="运行-Web-服务"><a href="#运行-Web-服务" class="headerlink" title="运行 Web 服务"></a>运行 Web 服务</h4><p>暴露的是 9000 的端口，这样部署之后，可以通过 <code>http://localhost:9000/</code> 访问。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --detach \</span><br><span class="line">  --link sentry-redis:redis \</span><br><span class="line">  --link sentry-postgres:postgres \</span><br><span class="line">  --link sentry-smtp:smtp \</span><br><span class="line">  --name sentry-web \</span><br><span class="line">  --publish 9000:9000 \</span><br><span class="line">  --env SENTRY_SECRET_KEY=$&#123;SENTRY_SECRET_KEY&#125; \</span><br><span class="line">  sentry-onpremise \</span><br><span class="line">  run web</span><br></pre></td></tr></table></figure><h3 id="脚本一键安装-Sentry"><a href="#脚本一键安装-Sentry" class="headerlink" title="脚本一键安装 Sentry"></a>脚本一键安装 Sentry</h3><p>发现了 <a href="https://github.com/getsentry/onpremise/blob/master/install.sh" target="_blank" rel="noopener">getsentry/onpremise/install.sh</a> 这个脚本，看懂这个脚本里的内容基本上就差不多知道安装步骤了。</p><p>读一下脚本：</p><ul><li><code>LATEST_STABLE_SENTRY_IMAGE=&#39;sentry:9.1.2&#39;</code> 安装的是 <code>sentry:9.1.2</code></li><li>在 <code>docker-compose.yml</code> 中会去创建两个卷，分别是 <code>sentry-data</code>和 <code>sentry-postgres</code>，这和上面步骤是不是发现区别了，上面创建<br><code>postgres</code> 时，可没有创建卷；</li><li><code>cp -n .env.example &quot;$ENV_FILE&quot;</code> 会将仓库下的 <a href="https://github.com/getsentry/onpremise/blob/master/.env.example" target="_blank" rel="noopener">.env.example</a> 文件重命名为 <code>.env</code> 文件，其实里面就是为了设置一个环境变量 <code>SENTRY_SECRET_KEY</code></li><li><code>export SENTRY_IMAGE=$LATEST_STABLE_SENTRY_IMAGE</code> 命名了一个环境变量，记录了镜像名</li><li><code>docker-compose build</code> 开始构建镜像啦，其实就是类似这个命令 <code>docker build .</code></li><li><code>SECRET_KEY=$(docker-compose run --rm web config generate-secret-key 2&gt; /dev/null | tail -n1 | sed -e &#39;s/[\/&amp;]/\\&amp;/g&#39;)</code> 运行命令获得 <code>secret-key</code> 值，赋值给了变量 <code>SECRET_KEY</code></li><li><code>sed -i -e &#39;s/^SENTRY_SECRET_KEY=.*$/SENTRY_SECRET_KEY=&#39;&quot;$SECRET_KEY&quot;&#39;/&#39; $ENV_FILE</code> 将 <code>SECRET_KEY</code> 变量值填写到环境变量文件 <code>.env</code> 中</li><li>接着就是设置数据库的步骤，这其实是就是为了在数据库中添加账号数据和其他一些数据表生成</li><li>最后就是执行 <code>cleanup</code> 函数</li></ul><p>执行脚本之前，我们先把之前创建的几个服务删除掉吧：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop sentry-smtp sentry-postgres sentry-redis</span><br><span class="line">docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure><h4 id="配置邮箱"><a href="#配置邮箱" class="headerlink" title="配置邮箱"></a>配置邮箱</h4><p>通过上面的阅读，可以发现，运行脚本时，会去执行 <code>docker build .</code>，这个会将配置文件 <code>config.yml</code> 和环境变量 <code>.env</code> 放入镜像的。因此，我们启用发生异常时获取邮箱告警的功能，需要现在配置文件中设置好邮箱配置。</p><p>这里我们选择在 <code>.env</code> 中配置好环境变量，实现邮箱的配置：<br>配置 <code>config.yml</code>:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">SENTRY_SECRET_KEY=)g=lkl1)uugx236%#)mq2o34^@a&amp;g3q85q**co*hbapm5y1*bs</span></span><br><span class="line"><span class="comment"># 邮箱设置</span></span><br><span class="line"><span class="string">SENTRY_EMAIL_HOST=smtp.qq.com</span></span><br><span class="line"><span class="string">SENTRY_EMAIL_USER=649168982@qq.com</span></span><br><span class="line"><span class="string">SENTRY_SERVER_EMAIL=649168982@qq.com</span></span><br><span class="line"><span class="comment"># 这里指的是邮箱的授权码，而非密码</span></span><br><span class="line"><span class="string">SENTRY_EMAIL_PASSWORD=xxxx</span></span><br><span class="line"><span class="string">SENTRY_EMAIL_USE_TLS=true</span></span><br><span class="line"><span class="string">SENTRY_EMAIL_PORT=587</span></span><br></pre></td></tr></table></figure><ul><li>网上的教程，大多数是 <code>SENTRY_EMAIL_HOST: &#39;smtp.exmail.qq.com&#39;</code>,这个是企业邮箱，我们个人的不这么设置。</li><li><code>SENTRY_EMAIL_USER</code> 和 <code>SENTRY_SERVER_EMAIL</code> 要保持一致；</li></ul><p>这里我设置 1 分钟，就能及时收到邮箱，但是设置 5 分钟，等了 5 分钟，也没收到，不知道是何原因：</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/igfeN5.png" alt="Project-Alerts"></p><p><img src="https://gitee.com/michael_xiang/images/raw/master/B625Ca.png" alt="Alerts"></p><p>经过上面的设置，可以试试邮箱发送功能是否 OK：点击左上角头像，选择 <code>Admin</code>-》<code>Mail</code>-》<code>测试设置</code></p><p><img src="https://gitee.com/michael_xiang/images/raw/master/80Ncez.png" alt="邮箱测试"></p><h4 id="部署-sentry"><a href="#部署-sentry" class="headerlink" title="部署 sentry"></a>部署 sentry</h4><p>下面开始安装步骤：</p><ul><li><code>sh install.sh</code> 执行安装脚本，脚本执行完需要一点时间，运行完成之后，会退出。中间过程会让你选择是否创建账号：</li></ul><p><img src="https://gitee.com/michael_xiang/images/raw/master/XoQY9F.png" alt="添加账号"></p><ul><li>接着运行 <code>docker-compose up -d</code> 即可；</li></ul><p><img src="https://gitee.com/michael_xiang/images/raw/master/zoG6sw.png" alt="容器列表"></p><p>PS：为何容器的名称是都是 <code>onpremise</code> 开头的呢？<a href="https://docs.docker.com/compose/reference/overview/" target="_blank" rel="noopener">因为不指定名称时，会默认取目录名的</a>。</p><p>这时候输入刚刚创建的账号登录：</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/WWx2n1.png" alt="login"></p><h2 id="配置-Sentry"><a href="#配置-Sentry" class="headerlink" title="配置 Sentry"></a>配置 Sentry</h2><h3 id="创建-project"><a href="#创建-project" class="headerlink" title="创建 project"></a>创建 project</h3><p>那我之前的 log4j2 的 demo 作为演示，这里选择一个 Java 项目，并且，我还创建了一个叫 <code>spring-boot</code> 的 Team。</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/VEi8nF.png" alt="project"></p><h2 id="spring-boot-项目适配"><a href="#spring-boot-项目适配" class="headerlink" title="spring-boot 项目适配"></a>spring-boot 项目适配</h2><p><a href="https://docs.sentry.io/clients/java/" target="_blank" rel="noopener">官方文档-Java</a> 给出了适用于 Java 项目的全面的适配指南，咱们使用的是 <a href="https://docs.sentry.io/clients/java/integrations/#log4j-2x" target="_blank" rel="noopener">log4j2</a>。</p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.sentry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentry-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="log4j2-xml-配置修改"><a href="#log4j2-xml-配置修改" class="headerlink" title="log4j2.xml 配置修改"></a>log4j2.xml 配置修改</h3><ul><li><code>configuration</code> 中加上 <code>packages=&quot;org.apache.logging.log4j.core,io.sentry.log4j2&quot;</code></li></ul><p>下面示例中的 <code>SentryAppender</code> 表示发送 <code>warn</code> 级别的日志到 Sentry Server。<code>ConsoleAppender</code> 仅仅表示是一个示例，表示你项目中之前使用的非 sentryappener 的例子。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">"warn"</span> <span class="attr">packages</span>=<span class="string">"org.apache.logging.log4j.core,io.sentry.log4j2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Sentry</span> <span class="attr">name</span>=<span class="string">"Sentry"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"Console"</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Note that the Sentry logging threshold is overridden to the WARN level --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"Sentry"</span> <span class="attr">level</span>=<span class="string">"WARN"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>经过测试，，因为原有项目中的 apppender 都是为了之前的作用设置的，比如控制台打印、比如输出到文件。要想将异常信息发送到 Sentry，这里的<code>SentryAppender</code> 是必不可少的。别忘了 <code>appender-ref</code> 也要设置！</p><h3 id="配置-DSN"><a href="#配置-DSN" class="headerlink" title="配置 DSN"></a>配置 DSN</h3><p><a href="https://docs.sentry.io/clients/java/config/#configuration" target="_blank" rel="noopener">配置页面</a> 介绍了如何设置 DSN（Data Source Name）。</p><p> 进入 Sentry，项目的 DSN 在项目页面-》setings-》Clinet Keys(DSN) 中可以发现：</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/dgVaSQ.png" alt="DSN"></p><p>配置 DSN 有好几种方式，具体的可以在页面查看，这里介绍我采用的：</p><p>在 <code>resources</code> 文件夹下，新建 <code>sentry.properties</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsn=http://8d53042c89774e5dba599ee67c5c8804@192.168.3.43:9000/3</span><br></pre></td></tr></table></figure><div class="note warning">            <p>默认的就是 <code>sentry.properties</code>，一开始我直接写在了 <code>application.properties</code> 中，Sentry 怎么也收不到异常日志。</p>          </div><h3 id="代码中"><a href="#代码中" class="headerlink" title="代码中"></a>代码中</h3><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Marker;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.MarkerManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LogManager.getLogger(MyClass.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Marker MARKER = MarkerManager.getMarker(<span class="string">"myMarker"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">logSimpleMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// This sends a simple event to Sentry</span></span><br><span class="line">        logger.error(<span class="string">"This is a test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">logWithBreadcrumbs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Record a breadcrumb that will be sent with the next event(s),</span></span><br><span class="line">        <span class="comment">// by default the last 100 breadcrumbs are kept.</span></span><br><span class="line">        Sentry.record(</span><br><span class="line">            <span class="keyword">new</span> BreadcrumbBuilder().setMessage(<span class="string">"User made an action"</span>).build()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This sends a simple event to Sentry</span></span><br><span class="line">        logger.error(<span class="string">"This is a test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">logWithTag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// This sends an event with a tag named 'log4j2-Marker' to Sentry</span></span><br><span class="line">        logger.error(MARKER, <span class="string">"This is a test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">logWithExtras</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// MDC extras</span></span><br><span class="line">        ThreadContext.put(<span class="string">"extra_key"</span>, <span class="string">"extra_value"</span>);</span><br><span class="line">        <span class="comment">// NDC extras are sent under 'log4j2-NDC'</span></span><br><span class="line">        ThreadContext.push(<span class="string">"Extra_details"</span>);</span><br><span class="line">        <span class="comment">// This sends an event with extra data to Sentry</span></span><br><span class="line">        logger.error(<span class="string">"This is a test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">logException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            unsafeMethod();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// This sends an exception event to Sentry</span></span><br><span class="line">            logger.error(<span class="string">"Exception caught"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unsafeMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"You shouldn't call this!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，Sentry 使用的接口和之前 log4j2 是有区别的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原来</span></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"><span class="comment">// sentry</span></span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Logger log = LogManager.getLogger(<span class="keyword">this</span>.getClass());</span><br></pre></td></tr></table></figure><p>实际过程中，这里是很多人忽视的，一定要仔细一点！</p><p>这时候，使用我们之前的错误接口故意打印错误日志，看看 Sentry 的捕获效果吧：</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/HyqIlX.png" alt="error"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天在之前加入的一个技术微信群里，一位同学发了一篇怎么搭建 Zabbix 的文章，被群主踢了。后来大家讨论，这种搭建的文章，普遍质量比较低，没有太多分享的意义，应该要更多的关注一些前言的知识、或者底层的基础知识。这种观点我是比较认同的，但是谁不是一步一步慢慢来的呢？</p><p>今天搭建 Sentry 的过程，对之前 docker-compose 的用法又有了进一步的认识，学习到了使用 <code>.env</code> 的方式设置容器内环境变量的方式，同时，也学习到了可以公用一种配置，让 docker-compose 文件内多个服务公用的方式。其实，自己的每一点的折腾，都会是后面的基石。只要持续积累，才会越走越顺！</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><ul><li><a href="https://github.com/Michael728/awesome-spring-boot-examples/tree/master/spring-boot-log4j2" target="_blank" rel="noopener">awesome-spring-boot-examples/log4j2</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://thinkhard.tech/2019/05/25/docker-sentry-deploy/" target="_blank" rel="noopener">神奇的展示-用 Docker 部署 Sentry Bug 日志收集服务</a></li><li><a href="https://juejin.im/post/5b226cbe51882574d02f9f62" target="_blank" rel="noopener">掘金-搭建私有的前端监控服务: sentry</a></li><li><a href="https://www.baoguoxiao.com/2018/10/30/sentry-configuring-mail/" target="_blank" rel="noopener">sentry配置邮件</a></li><li><a href="https://segmentfault.com/q/1010000016563419" target="_blank" rel="noopener">自建sentry后，配置了邮件服务，但是还是收不到验证邮件？</a> 这个问题有参考意义，还是推荐通过环境变量的方式而不是 <code>config.yml</code> 配置邮箱</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/michael_xiang/images/raw/master/xOgFTp.png&quot; alt=&quot;Sentry-Robot&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在日常线上运行的应用中如果报了异常，怎么在第一时间收到报错告警并且查看报错日志呢？周五就因为缺乏报错日志，导致构建服务受影响超过了 2 小时，虽然不至于「死人」，但是也确实让我意识到日志的重要性！后来临时在相关的地方加上日志，通过错误信息很快定位了到了原因，原来是数据库被运维人员做了新特性的改动，而我们服务还未适配好。想想当时的场景，还真是有点紧张~囧&lt;/p&gt;
&lt;p&gt;今天就学习一下利用 &lt;a href=&quot;https://sentry.io/welcome/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sentry&lt;/a&gt; 作为日志收集系统，结合之前学习的 &lt;a href=&quot;https://michael728.github.io/2019/08/17/java-spring-boot-log4j2/&quot;&gt;log4j2&lt;/a&gt; 日志输出，主动收集异常日志。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://michael728.github.io/categories/Java/"/>
    
    
      <category term="DevOps" scheme="https://michael728.github.io/tags/DevOps/"/>
    
      <category term="Java" scheme="https://michael728.github.io/tags/Java/"/>
    
      <category term="Spring Boot" scheme="https://michael728.github.io/tags/Spring-Boot/"/>
    
      <category term="日志" scheme="https://michael728.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 实战 —— 日志框架 Log4j2 SLF4J 的学习</title>
    <link href="https://michael728.github.io/2019/08/10/java-spring-boot-log4j2/"/>
    <id>https://michael728.github.io/2019/08/10/java-spring-boot-log4j2/</id>
    <published>2019-08-10T23:49:10.000Z</published>
    <updated>2020-03-05T14:20:44.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="https://gitee.com/michael_xiang/images/raw/master/joePal.png" alt="logging.apache"></p><p>Java 中比较常用的<a href="https://logging.apache.org/" target="_blank" rel="noopener">日志框架</a>：</p><ul><li>log4j(<code>Log for Java</code>)：Apache 的一个开源项目，七种日志级别：OFF、FATAL、ERROR、WARN、INFO、DEBUG、TRACE</li><li><a href="https://logback.qos.ch/" target="_blank" rel="noopener">logback</a>：是一个很成熟的日志框架，其实 logBack 和 log4j 出自一个人之手，这个人就是 Ceki Gülcü。logback 比 log4j 大约快 10 倍、消耗更少的内存，迁移成本也很低，自动压缩日志、支持多样化配置、不需要重启就可以恢复 I/O 异常等优势</li><li><a href="https://logging.apache.org/log4j/2.x/manual/index.html" target="_blank" rel="noopener">log4j2</a>：作者认为，log4j2已经不仅仅是 log4j 的一个升级版本了，而是从头到尾被重写的，这可以认为这其实就是完全不同的两个框架</li></ul><a id="more"></a><p>Spring Boot 默认使用 logback，但相比较而言，log4j2 在性能上面会更好。SpringBoot 高版本都不再支持 log4j，而是支持 log4j2。log4j2，在使用方面与 log4j 基本上没什么区别，比较大的区别是 log4j2 不再支持 properties 配置文件，支持 xml、json 格式的文件。</p><p>《阿里巴巴Java开发手册》，其中有一条规范做了「强制」要求：</p><blockquote><p>应用中不可直接使用日志系统（Log4j Logback）中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用日志门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p></blockquote><p>Java 简易日志门面（<code>Simple Logging Facade for Java</code>，缩写 <a href="https://www.slf4j.org/" target="_blank" rel="noopener">SLF4J</a>），它并不是真正的日志框架,他是对所有日志框架制定的一种规范、标准、接口，并不是一个框架的具体的实现，因为接口并不能独立使用，需要和具体的日志框架实现配合使用。可以在软件部署的时候决定要使用的 Logging 框架，目前主要支援的有 Java logging API、log4j 及 logback 等框架。</p><h2 id="理解-SLF4J"><a href="#理解-SLF4J" class="headerlink" title="理解 SLF4J"></a>理解 SLF4J</h2><p>接口用于定制规范，可以有多个实现，使用时是面向接口的(导入的包都是 slf4j 的包而不是具体某个日志框架中的包)，即直接和接口交互，不直接使用实现，所以可以任意的更换实现而不用更改代码中的日志相关代码。</p><p>比如：slf4j 定义了一套日志接口，项目中使用的日志框架是logback，开发中调用的所有接口都是 slf4j 的，不直接使用 logback，调用是 自己的工程调用 slf4j 的接口，slf4j 的接口去调用 logback 的实现，可以看到整个过程应用程序并没有直接使用 logback，当项目需要更换更加优秀的日志框架时(如log4j2)只需要引入 log4j2 的 jar 和 Llg4j2 对应的配置文件即可，完全不用更改 Java 代码中的日志相关的代码 <code>logger.info(“xxx”)</code>，也不用修改日志相关的类的导入的包( <code>import org.slf4j.Logger; import org.slf4j.LoggerFactory;</code>)</p><p>总结：使用日志接口便于更换为其他日志框架。</p><p>One More Thing：上面的这几段话是参考文章中截取的，也让我确实理解了为何推荐使用 SLF4J 的原因。这种做法感觉就是有点「面向接口编程」的思想，今天也查阅了一些这方面的资料，也让我想起了为何项目中写 Service 代码时，往往是先写个接口、然后在写个该接口的实现类。待有时间好好研究一些这块的优点！</p><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p><img src="https://gitee.com/michael_xiang/images/raw/master/AeAzbU.png" alt="评测"></p><p><img src="https://gitee.com/michael_xiang/images/raw/master/5XDdYv.png" alt="评测"></p><p>log4j2 的性能几乎是碾压的，优势很明显。更多关于性能的评测，在<a href="https://logging.apache.org/log4j/2.x/performance.html" target="_blank" rel="noopener">官网</a>可以看到</p><h2 id="log4j2-依赖"><a href="#log4j2-依赖" class="headerlink" title="log4j2 依赖"></a>log4j2 依赖</h2><p>需要在 pom 文件中排除默认的日志框架并引入 log4j2 依赖。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;!-- 去掉logback配置 --&gt;</span><br><span class="line">        &lt;exclusions&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">        &lt;/exclusions&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 引入log4j2依赖 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h2 id="log4j2-使用"><a href="#log4j2-使用" class="headerlink" title="log4j2 使用"></a>log4j2 使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">// 这了两种写法都 OK，推荐第一种，不用每次都要修改类名</span><br><span class="line">private static final Logger logger = LoggerFactory.getLogger(this.getClass());</span><br><span class="line">private static final Logger logger = LogManager.getLogger(UserController.class);</span><br><span class="line">//...</span><br><span class="line">logger.debug("this is debug");</span><br><span class="line">logger.info("this is info");</span><br></pre></td></tr></table></figure><h2 id="log4j2-日志级别"><a href="#log4j2-日志级别" class="headerlink" title="log4j2 日志级别"></a>log4j2 日志级别</h2><p>从小到大依次是:<del>all</del>、trace、debug、info、warn、error、<del>fatal、off</del></p><p>由于我们使用的是 slf4j 接口包，该接口包中只提供了未标有删除线的日志级别的输出。</p><h2 id="log4j2-配置文件结构"><a href="#log4j2-配置文件结构" class="headerlink" title="log4j2 配置文件结构"></a>log4j2 配置文件结构</h2><p>配置文件的主要结构如下：</p><ul><li>Appenders:<ul><li>Appender<ul><li>Filter</li><li>Layout</li><li>Policies</li><li>Strategy</li></ul></li></ul></li><li>Loggers<ul><li>Logger</li><li>RootLogger</li></ul></li></ul><h2 id="Appender"><a href="#Appender" class="headerlink" title="Appender"></a>Appender</h2><p>Appender 可以理解为一个管道，定义了日志内容的去向(保存位置)。</p><ul><li>配置一个或者多个 <code>Filter</code>。</li><li>配置 <code>Layout</code> 来控制日志信息的输出格式。</li><li>配置 <code>Policies</code> 以控制日志何时(When)进行滚动。</li><li>配置 <code>Strategy</code> 以控制日志如何(How)进行滚动。</li></ul><p>注意点：</p><ul><li>多个 <code>appender</code> 不能指向同一个日志文件，否则会报错：<code>Configuration has multiple incompatible Appenders pointing to the same resource &#39;logs/mybatis-demo-warn.log&#39;</code></li><li><code>ImmediateFlush=true</code>，一旦有新日志写入，立马将日志写入到磁盘的文件中。当日志很多，这种频繁操作文件显然性能很低下</li><li><code>immediateFlush</code>：log4j2 接收到日志事件时，是否立即将日志刷到磁盘。默认为 true。</li><li>BufferedIO: 文件流写出是否使用缓冲，true 表示使用，默认值为 false 即不使用缓冲。测试显示，即使在启用immediateFlush 的情况下，设置 <code>bufferedIO=true</code> 也能提高性能。</li><li>一个 LogConfig 可以使用多个 appender，一个 appender 也可以被多个 LogConfig 使用</li></ul><p><a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#RandomAccessFileAppender" target="_blank" rel="noopener">官宣——Appender</a></p><h3 id="PatternLayout"><a href="#PatternLayout" class="headerlink" title="PatternLayout"></a>PatternLayout</h3><p>这是常用的日志格式化类，其它日志格式化类很少用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;PatternLayout pattern="%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n" charset="UTF-8"/&gt;</span><br></pre></td></tr></table></figure><p>常用说明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%</span>d&#123;HH:mm:ss.SSS&#125; 表示输出到毫秒的时间</span><br><span class="line"><span class="meta">%</span>t 输出当前线程名称</span><br><span class="line"><span class="meta">%</span>-5level 输出日志级别，-5表示左对齐并且固定输出5个字符，如果不足在右边补0</span><br><span class="line"><span class="meta">%</span>logger 输出logger名称，因为Root Logger没有名称，所以没有输出</span><br><span class="line"><span class="meta">%</span>msg 日志文本</span><br><span class="line"><span class="meta">%</span>n 换行</span><br><span class="line"></span><br><span class="line">其他常用的占位符有：</span><br><span class="line"><span class="meta">%</span>F 输出所在的类文件名，如Client.java</span><br><span class="line"><span class="meta">%</span>L 输出行号</span><br><span class="line"><span class="meta">%</span>M 输出所在方法名</span><br><span class="line"><span class="meta">%</span>l 输出语句所在的行数, 包括类名、方法名、文件名、行数</span><br></pre></td></tr></table></figure><p>关于 pattern 的格式点击 <a href="http://logging.apache.org/log4j/2.x/manual/layouts.html#PatternLayout" target="_blank" rel="noopener">官宣——Pattern Layout</a></p><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>Filters 决定日志事件能否被输出。过滤条件有三个值：<code>ACCEPT(接受)</code>，<code>DENY(拒绝)</code>，<code>NEUTRAL(中立)</code>。</p><p>常用的 Filter 实现类有：</p><ul><li>LevelRangeFilter</li><li>TimeFilter</li><li>ThresholdFilter</li></ul><p>简单说就是 log4j2 中的过滤器 <code>ACCEPT</code> 和 <code>DENY</code> 之后，后续的过滤器就不会执行了，只有在 <code>NEUTRAL</code> 的时候才会执行后续的过滤器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;Console name="Console"&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">        设置 onMismatch="NEUTRAL" 可以让日志经过后续的过滤器</span><br><span class="line">        最后一个过滤器建议设置 onMismatch="DENY", 不然日志就输出了。</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;Filters&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 从大到小：error, warn, info, debug, trace --&gt;</span><br><span class="line">        &lt;LevelRangeFilter minLevel="error" maxLevel="info" onMatch="ACCEPT" onMismatch="NEUTRAL" /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 只允许在每天的 8点~8点半 之间输出日志 --&gt;</span><br><span class="line">        &lt;TimeFilter start="08:00:00" end="08:30:00" onMatch="ACCEPT" onMismatch="DENY" /&gt;</span><br><span class="line">    &lt;/Filters&gt;</span><br><span class="line"></span><br><span class="line">    &lt;PatternLayout pattern="%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n" charset="UTF-8"/&gt;</span><br><span class="line">&lt;/Console&gt;</span><br></pre></td></tr></table></figure><p>LevelRangeFilter 对它们进行了 <code>ACCEPT</code>，而剩下的 <code>trace Msg</code> 和 <code>debug Msg</code> 则会经过下一个过滤器。</p><h3 id="Policy"><a href="#Policy" class="headerlink" title="Policy"></a>Policy</h3><p><code>Policy &amp; Strategy</code></p><ul><li>Policy 是用来控制日志文件何时(When)进行 Rolling/滚动的；</li><li>Strategy 是用来控制日志文件如何(How)进行 Rolling/滚动的。</li></ul><p>所谓「日志滚动」就是当达到设定的条件后，日志文件进行切分。比如：工程师想让系统中的日志按日进行切分，并且按月归档。</p><p><code>Rolling</code> 的意思是当满足一定条件后，就重命名原日志文件用于备份，并重新生成一个新的日志文件。例如需求是每天生成一个日志文件，但是如果一天内的日志文件体积已经超过 1G，就重新生成。<strong>两个条件满足一个即可</strong>。</p><p>Policy常用的实现类:</p><ul><li><code>SizeBasedTriggeringPolicy</code>，根据日志文件的大小进行滚动。单位有：<code>KB</code>，<code>MB</code>，<code>GB</code></li><li><code>CronTriggeringPolicy</code>，使用 Cron 表达式进行日志滚动，很灵活</li><li><code>TimeBasedTriggeringPolicy</code>，这个配置需要和 <code>filePattern</code> 结合使用，注意 <code>filePattern</code> 中配置的文件重命名规则。滚动策略依赖于 <code>filePattern</code> 中配置的最具体的时间单位，根据最具体的时间单位进行滚动。这种方式比较简洁。<code>CronTriggeringPolicy</code> 策略更强大</li></ul><p>在 <code>TimeBasedTriggeringPolicy</code> 标签中加上了 <code>modulate</code> 属性并设置为 <code>true</code>，该属性的意思是是否对日志生成时间进行调制。若为 <code>true</code>，则日志时间将以 0 点为边界进行偏移计算。例如第一次日志保存时间是 3 点，<code>modulate</code>为 <code>true</code>，<code>interval</code> 是 <code>4h</code>。那么下次生成日志时间是 4点，08:00，12:00……。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;Appenders&gt;</span><br><span class="line">    &lt;RollingRandomAccessFile name="File" fileName="logs/app.log"</span><br><span class="line">                                filePattern="logs/$$&#123;date:hh-mm&#125;/%d&#123;hh-mm-ss&#125;.app.%i.log" &gt;</span><br><span class="line">        &lt;PatternLayout pattern="%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n" charset="UTF-8"/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Policies&gt;</span><br><span class="line">            &lt;!-- 每 5s 翻滚一次 --&gt;</span><br><span class="line">            &lt;!--&lt;CronTriggeringPolicy schedule="0/5 * * * * ?" /&gt;--&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!--</span><br><span class="line">                filePattern中最具体的时间单位是 秒。</span><br><span class="line">                这里用 TimeBasedTriggeringPolicy 替换 CronTriggeringPolicy</span><br><span class="line"></span><br><span class="line">                注意：modulate属性是指从启动时间开始算5秒，还是从0秒开始算5秒，运行一下就明白了。</span><br><span class="line">                modulate: true(默认值) // 会从启动时间开始算 5秒</span><br><span class="line">                modulate: false // 从 0秒开始算</span><br><span class="line">            --&gt;</span><br><span class="line">            &lt;TimeBasedTriggeringPolicy interval="5" modulate="true"/&gt;</span><br><span class="line">            &lt;SizeBasedTriggeringPolicy size="10 MB"/&gt;</span><br><span class="line">        &lt;/Policies&gt;</span><br><span class="line">        &lt;DefaultRolloverStrategy max="10" /&gt;</span><br><span class="line">    &lt;/RollingRandomAccessFile&gt;</span><br><span class="line">&lt;/Appenders&gt;</span><br></pre></td></tr></table></figure><h3 id="Strategy"><a href="#Strategy" class="headerlink" title="Strategy"></a>Strategy</h3><p>Strategy常用的实现类：</p><ul><li>DefaultRolloverStrategy</li><li>DirectWriteRolloverStrategy</li></ul><p>这两个 Strategy 都是控制如何进行日志滚动的。</p><p><code>DefaultRolloverStrategy</code> 默认的 <code>max</code>为 7。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;DefaultRolloverStrategy max="7"/&gt;</span><br></pre></td></tr></table></figure><p>max 参数指定了计数器的最大值。一旦计数器达到了最大值，过旧的文件将被删除。</p><p>注意：不要认为 max 参数是需要保留的日志文件的最大数目。</p><p>max 参数是与 <code>filePattern</code> 中的计数器 <code>%i</code> 配合起作用的，其具体作用方式与 <code>filePattern</code> 的配置密切相关。</p><p>1.如果filePattern中仅含有date/time pattern，每次rollover时，将用当前的日期和时间替换文件中的日期格式对文件进行重命名。max参数将不起作用。</p><p>如，<code>filePattern=&quot;logs/app-%d{yyyy-MM-dd}.log&quot;</code></p><p>2.如果 <code>filePattern</code> 中仅含有整数计数器（即<code>%i</code> ），每次 <code>rollover</code> 时，文件重命名时的计数器将每次加1（初始值为1），若达到 max 的值，将删除旧的文件。</p><p>如，<code>filePattern=&quot;logs/app-%i.log&quot;</code></p><p>3.如果 <code>filePattern</code> 中既含有 <code>date/time pattern</code>，又含有 <code>%i</code>，每次 <code>rollover</code> 时，计数器将每次加 1，若达到 max 的值，将删除旧的文件，直到 <code>data/time pattern</code> 不再符合，被替换为当前的日期和时间，计数器再从1开始。</p><p>如，<code>filePattern=&quot;logs/app-%d{yyyy-MM-dd HH-mm}-%i.log&quot;</code></p><h3 id="Appender-类型"><a href="#Appender-类型" class="headerlink" title="Appender 类型"></a>Appender 类型</h3><h4 id="FileAppender-File-、RandomAccessFileAppender-RandomAccessFile"><a href="#FileAppender-File-、RandomAccessFileAppender-RandomAccessFile" class="headerlink" title="FileAppender(File)、RandomAccessFileAppender(RandomAccessFile)"></a>FileAppender(File)、RandomAccessFileAppender(RandomAccessFile)</h4><ul><li>相同点：写入日志信息到文件</li><li>不同点：使用的 <code>I/O</code> 实现类不同，前者使用 <code>FileOutputStream</code>，后者使用 <code>RandomAccessFile</code>。</li></ul><p>官方文档说是在 <code>bufferedIO=true</code> (默认是 <code>true</code> )的情况下，性能提升 <code>20% ~ 200%</code>。</p><p>常用属性:</p><ul><li><code>fileName</code>：来指定文件位置，文件或目录不存在则会自动创建。</li><li><code>immediateFlush</code>：是否每次写入都要立刻刷新到硬盘中。默认 <code>true</code>，如果使用默认值可能会影响性能。</li></ul><h4 id="RollingFileAppender-RollingFile-、RollingRandomAccessFileAppender-RollingRandomAccessFile"><a href="#RollingFileAppender-RollingFile-、RollingRandomAccessFileAppender-RollingRandomAccessFile" class="headerlink" title="RollingFileAppender(RollingFile)、RollingRandomAccessFileAppender(RollingRandomAccessFile)"></a>RollingFileAppender(RollingFile)、RollingRandomAccessFileAppender(RollingRandomAccessFile)</h4><ul><li>相同点：写入日志信息到文件</li><li>不同点：使用的 <code>I/O</code> 实现类不同，前者使用 <code>FileOutputStream</code>，后者使用 <code>RandomAccessFile</code>。</li><li>上一对的实现类不能进行「日志滚动」，而带有 <code>rolling</code> 字样的 appender 就可以实现「滚动」功能。有「滚动」，会判断是否满足封存文件的要求，执行日志存档操作。</li></ul><blockquote><p>RollingRandomAccessFile Appender，相比 RollingFileAppender有很大的性能提升，官网宣称是20-200%</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;RollingRandomAccessFile name="File" fileName="logs/app.log"</span><br><span class="line">                            filePattern="logs/$$&#123;date:hh-mm&#125;/%d&#123;hh-mm-ss&#125;.app.%i.log" &gt;</span><br><span class="line">    &lt;PatternLayout pattern="%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n" charset="UTF-8"/&gt;</span><br><span class="line">    &lt;Policies&gt;</span><br><span class="line">        &lt;!-- 每 5s 翻滚一次 --&gt;</span><br><span class="line">        &lt;CronTriggeringPolicy schedule="0/5 * * * * ?" /&gt;</span><br><span class="line">        &lt;SizeBasedTriggeringPolicy size="10 MB"/&gt;</span><br><span class="line">    &lt;/Policies&gt;</span><br><span class="line">    &lt;DefaultRolloverStrategy max="10" /&gt;</span><br><span class="line">&lt;/RollingRandomAccessFile&gt;</span><br><span class="line">&lt;/Appenders&gt;</span><br></pre></td></tr></table></figure><p>常用属性：</p><ul><li><code>filePattern</code>：指定当发生Rolling时，文件的转移和重命名规则。至于其中的 <code>$${date:hh-mm}</code> 是表示了一个文件夹（以 <code>小时-分钟</code>）命名。</li><li><code>DefaultRolloverStrategy</code> 指定了如何(How)进行翻滚，并且指定了最大翻滚次数(影响%i参数值)，超过次数之后会按照相应的规则删除旧日志。</li><li><code>Policies</code>: 这里就是规定了何时进行滚动(When)，可以有多个Policy。<ul><li><code>CronTriggeringPolicy</code>，比如设置每 5s 进行一次翻滚</li><li><code>SizeBasedTriggeringPolicy</code> 指定当文件体积大于size指定的值时，触发Rolling。例如，如果当前文件超过了 10MB，但是文件的名字还没有进行翻滚(建立新文件)，那么就会用%i的方式进行翻滚。</li></ul></li></ul><p>如果配置的是 <code>RollingFile</code> 或 <code>RollingRandomAccessFile</code>，则必须配置一个 <code>Policy</code>。</p><h4 id="翻滚理解"><a href="#翻滚理解" class="headerlink" title="翻滚理解"></a>翻滚理解</h4><p>假设计数器次数设为2次 <code>&lt;DefaultRolloverStrategy max=&quot;2&quot; /&gt;</code>，<code>filePattern</code> 中既含有 <code>date/time pattern</code>，又含有 <code>%i</code>。</p><p>当满足翻滚触发条件时（时间间隔到了 OR 文件大小超了），就会启动 <code>Rolling</code>：</p><p>app.log</p><p>第一次翻滚：<code>app.log app.1.log // app.log -&gt; app.1.log</code><br>第二次翻滚：<code>app.log app.1.log app.2.lop // app.log -&gt; app.2.log</code></p><p>一个循环结束，到达了最大保存数 2 了，那么，<code>app1.log</code> 会被删除，下一个 <code>app3.log</code> 就会覆盖 <code>app2.log</code>，<code>app2.log</code>会改名为<code>app1.log</code></p><p>第三次翻滚：<code>app.log app.2.lop app.3.lop // app.log -&gt; app.3.log</code><br>第四次翻滚：<code>app.log app.3.lop app.4.lop // app.log -&gt; app.4.log</code></p><p>理解：编号最近的一次也就是最新的一次 log，而采取了 <code>Policy</code> 方式的日志，<code>fileName</code> 中保存的日志将不会是全量的日志，而是根据你 <code>Policy</code> 的条件切分后的最近一次的日志内容。</p><ul><li><a href="https://www.cnblogs.com/yeyang/p/7944899.html" target="_blank" rel="noopener">博客园-Log4j2中RollingFile的文件滚动更新机制</a> 滚动机制介绍的很详细</li><li><a href="https://blog.csdn.net/u013066244/article/details/72461105" target="_blank" rel="noopener">CSDN-log4j2教程【RollingFileAppender】</a></li></ul><h4 id="一个-Appender-示例"><a href="#一个-Appender-示例" class="headerlink" title="一个 Appender 示例"></a>一个 Appender 示例</h4><p>按月归档日志，按日进行切分，限制单文件大小为 500MB, 一天最多生成20个文件，也就是(20 * 500)MB大小的日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;Configuration name="baseConf" status="warn" monitorInterval="30"&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Appenders&gt;</span><br><span class="line">        &lt;RollingRandomAccessFile name="File" fileName="logs/app.log"</span><br><span class="line">                                 filePattern="logs/$$&#123;date:yyyy-MM&#125;/%d&#123;yyyy-MM-dd&#125;.app.%i.log" &gt;</span><br><span class="line">            &lt;PatternLayout pattern="%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n" charset="UTF-8"/&gt;</span><br><span class="line">            &lt;Policies&gt;</span><br><span class="line">                &lt;TimeBasedTriggeringPolicy interval="1" modulate="false"/&gt;</span><br><span class="line">                &lt;SizeBasedTriggeringPolicy size="500MB"/&gt;</span><br><span class="line">            &lt;/Policies&gt;</span><br><span class="line">            &lt;DefaultRolloverStrategy max="20" /&gt;</span><br><span class="line">        &lt;/RollingRandomAccessFile&gt;</span><br><span class="line">    &lt;/Appenders&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Loggers&gt;</span><br><span class="line">        &lt;Root level="info"&gt;</span><br><span class="line">            &lt;AppenderRef ref="File"/&gt;</span><br><span class="line">        &lt;/Root&gt;</span><br><span class="line">    &lt;/Loggers&gt;</span><br><span class="line"></span><br><span class="line">&lt;/Configuration&gt;</span><br></pre></td></tr></table></figure><h2 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h2><p>简单说 Logger 就是一个路由器，指定类、包中的日志信息流向哪个管道，以及控制他们的流量(日志级别)</p><p>Logger 部分为两个 Logger:</p><ul><li>RootLogger(必须配置)</li><li>Logger</li></ul><p>注意：Logger 中也可以加过滤器的！</p><h3 id="日志重复打印问题"><a href="#日志重复打印问题" class="headerlink" title="日志重复打印问题"></a>日志重复打印问题</h3><p>如果 Root 中的日志包含了 Logger 中的日志信息，并且 AppenderRef 是一样的配置，则日志会打印两次。</p><p>这时候我们需要使用一个 Logger 的属性来解决，那就是 <code>additivity</code>，其默认值为 <code>true</code>，需要配置为<code>false</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;Configuration name="baseConf" status="warn" monitorInterval="30"&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Appenders&gt;</span><br><span class="line">        &lt;Console name="Console"&gt;</span><br><span class="line">            &lt;PatternLayout&gt;</span><br><span class="line">                &lt;Pattern&gt;%d %p %c&#123;1.&#125; [%t] %m%n&lt;/Pattern&gt;</span><br><span class="line">            &lt;/PatternLayout&gt;</span><br><span class="line">        &lt;/Console&gt;</span><br><span class="line">    &lt;/Appenders&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Loggers&gt;</span><br><span class="line">        &lt;Logger name="me.master.snail.log.LogMain" level="info" additivity="false"&gt;</span><br><span class="line">            &lt;AppenderRef ref="Console"/&gt;</span><br><span class="line">        &lt;/Logger&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Root level="trace"&gt;</span><br><span class="line">            &lt;AppenderRef ref="Console"/&gt;</span><br><span class="line">            &lt;Filters&gt;</span><br><span class="line">                &lt;LevelRangeFilter minLevel="error" maxLevel="info" onMatch="ACCEPT" onMismatch="DENY" /&gt;</span><br><span class="line">            &lt;/Filters&gt;</span><br><span class="line">        &lt;/Root&gt;</span><br><span class="line">    &lt;/Loggers&gt;</span><br><span class="line">&lt;/Configuration&gt;</span><br></pre></td></tr></table></figure><ul><li>RootLogger 只能有 1 个，普通的 Logger 可以定义多个，可以细致到给某个类定义；</li><li>多个 Logger 配置重复了，在日志文件中会重复；</li><li>每一个 Logger 对应的 name 是包路径，表示在 name 包下的类使用 AppenderRef 指向的日志模板来输出日志；</li><li>不同的 LogConfig 之间其实是有继承关系的，子 LogConfig 会继承 parent 的属性，而所有 LogConfig 都继承自 Root LogConfig。所以即使只配置了 root logger，你一样可以在任何地方通过  <code>LoggerFactory.getLogger</code> 获取一个 logger 对象，记录日志;</li><li>先配置一个 Root，让所有需要使用日志的 logger 继承，然后对有特别需要的 logger 进行特殊的配置，比如我们希望 <code>org.springframework</code> 包只记录 <code>error</code>以及 <code>warn</code> 级别的 log，再比如，我们希望能显示mybatis 执行的 sql 的日志，都可以进行个性化的配置；</li></ul><h3 id="Logger-等级实验"><a href="#Logger-等级实验" class="headerlink" title="Logger 等级实验"></a>Logger 等级实验</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;logger name="org.springframework" level="INFO" additivity="true"&gt;</span><br><span class="line">    &lt;AppenderRef ref="InfoLog"/&gt;</span><br><span class="line">&lt;/logger&gt;</span><br><span class="line"></span><br><span class="line">&lt;Root level="ERROR" additivity="true"&gt;</span><br><span class="line">    &lt;AppenderRef ref="Console"/&gt;</span><br><span class="line">    &lt;AppenderRef ref="InfoLog"/&gt;</span><br><span class="line">    &lt;AppenderRef ref="WarnLog"/&gt;</span><br><span class="line">    &lt;AppenderRef ref="ErrorLog"/&gt;</span><br><span class="line">&lt;/Root&gt;</span><br></pre></td></tr></table></figure><ul><li>ROOT 等级设为 <code>ERROR</code> 时，<code>org.springframework</code> Logger 等级设为 <code>OFF</code> 时，发现原来的 <code>warn.log</code> 和 <code>info.log</code> 文件中，都只有级别大于或等于 ERROR 的日志信息了；</li><li>ROOT 等级设为 <code>ERROR</code> 时，<code>org.springframework</code> Logger 等级设为 <code>INFO</code> 时，发现<code>info.log</code> 文件中，增加了 <code>org.springframework</code> 包的相关 <code>INFO</code> 级别的日志信息了；</li></ul><p>总结：</p><ul><li>Logger 日志等级和 appender 日志等级的关系：logger 日志等级和 appender 日志等级，谁「高」听谁的；</li><li>普通 Logger 的优先级高</li></ul><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>在 log4j2 的官网建议开发者使用异步方式，这样做的好处是可以使用单独线程来打印日志，提高日志效率，避免由于打印日志而影响业务功能。</p><p>Log4j2 中的 AsyncLogger 的内部使用了 Disruptor 框架，因此要额外引入下面依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Disruptor --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lmax<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>disruptor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>AsyncLogger 是官方推荐的异步方式，它提供了两种方式使用异步日志，即「全局异步」和「混合异步」。</p><ul><li><a href="https://logging.apache.org/log4j/2.x/manual/async.html#AllAsync" target="_blank" rel="noopener">全局异步</a>：所有的日志都进行异步的日志记录</li><li><a href="https://logging.apache.org/log4j/2.x/manual/async.html#MixedSync-Async" target="_blank" rel="noopener">混合异步</a>：同时使用同步日志和异步日志</li></ul><p>全局异步的方式：</p><ul><li>系统初始化的时候加上全局配置：<code>System.setProperty(&quot;log4j2.contextSelector&quot;,&quot;org.apache.logging.log4j.core.async.AsyncLoggerContextSelector&quot;);</code></li><li>加载 JVM 启动参数里设置：<code>-DLog4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector</code></li></ul><div class="note warning">            <p>开启全异步时，日志配置中需要使用普通的Root和Logger元素。如果使用了AsyncRoot或AsyncLogger，将产生不必要的开销。</p>          </div><p>混合异步：</p><ul><li><code>log4j2.xml</code> 配置文件中使用 <code>AsyncRoot/AsyncLogger</code> 替代 <code>Root/Logger</code></li></ul><div class="note warning">            <p>全异步是官方推荐的，也是性能最佳的方式，但同步异步混合使用，能够提供更大的灵活性。使用 AsyncRoot、AsyncLogger、Root、Logger 混合配置，可以实现同步异步混合。但是需要注意，配置中只能有一个 root 元素，也就是只能使用 AsyncRoot 或 Root 中的一个。</p>          </div><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://gitee.com/michael_xiang/images/raw/master/8PAZgl.png" alt="log4j2-console"></p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><ul><li><a href="https://github.com/Michael728/awesome-spring-boot-examples/blob/master/spring-boot-logs/src/main/resources/log4j2.xml" target="_blank" rel="noopener">awesome-spring-boot-examples</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Log4j2</p><ul><li><a href="https://github.com/apache/logging-log4j2" target="_blank" rel="noopener">Github-apache/logging-log4j2</a></li><li><a href="https://juejin.im/entry/5b35f1e86fb9a00e315c330e" target="_blank" rel="noopener">掘金-zdran-Spring Boot 学习笔记(二) 整合 log4j2</a> 博主写了一些 Spring Boot 教程</li><li><a href="https://www.cnblogs.com/wuqinglong/p/9516529.html" target="_blank" rel="noopener">博客园-蜗牛大师-浅谈Log4j2日志框架及使用</a> 介绍的非常详细，强烈推荐！</li><li><a href="http://www.cnblogs.com/elaron/archive/2013/02/17/2914633.html" target="_blank" rel="noopener">博客园-Log4j2之Appenders</a> 对 appender 介绍详细</li><li><a href="https://it-linnan.github.io/log4j2%E5%BC%82%E6%AD%A5%E6%97%A5%E5%BF%97.html" target="_blank" rel="noopener">Log4j2异步日志</a></li><li><a href="https://blog.csdn.net/heyutao007/article/details/72773077" target="_blank" rel="noopener">CSDN-log4j2异步Logger</a> 提供了一副异步记载日志的图</li></ul><p>SLF4J</p><ul><li><a href="https://juejin.im/post/5c11c831e51d4511624d1b59" target="_blank" rel="noopener">掘金—HollisChuang—为什么阿里巴巴禁止工程师直接使用日志系统(Log4j、Logback)中的 API</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/michael_xiang/images/raw/master/joePal.png&quot; alt=&quot;logging.apache&quot;&gt;&lt;/p&gt;
&lt;p&gt;Java 中比较常用的&lt;a href=&quot;https://logging.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;日志框架&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;log4j(&lt;code&gt;Log for Java&lt;/code&gt;)：Apache 的一个开源项目，七种日志级别：OFF、FATAL、ERROR、WARN、INFO、DEBUG、TRACE&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://logback.qos.ch/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;logback&lt;/a&gt;：是一个很成熟的日志框架，其实 logBack 和 log4j 出自一个人之手，这个人就是 Ceki Gülcü。logback 比 log4j 大约快 10 倍、消耗更少的内存，迁移成本也很低，自动压缩日志、支持多样化配置、不需要重启就可以恢复 I/O 异常等优势&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://logging.apache.org/log4j/2.x/manual/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;log4j2&lt;/a&gt;：作者认为，log4j2已经不仅仅是 log4j 的一个升级版本了，而是从头到尾被重写的，这可以认为这其实就是完全不同的两个框架&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://michael728.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://michael728.github.io/tags/Java/"/>
    
      <category term="Spring Boot" scheme="https://michael728.github.io/tags/Spring-Boot/"/>
    
      <category term="日志" scheme="https://michael728.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
</feed>
