<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CentOS Nginx 安装及配置]]></title>
    <url>%2F2019%2F06%2F08%2Fcicd-centos-install-nginx%2F</url>
    <content type="text"><![CDATA[概念 了解 Nginx 的基本概念 安装12apt-get install nginx # Ubuntuyum install nginx -y # CentOS 配置文件1nginx -t # 检查配置文件正确性 test configuration and exit 主要文件位置 which nginx # or whereis nginx：查看主程序文件 /etc/init.d/：下创建了启动脚本nginx（需手动配置），支持service nginx start命令 /var/log/nginx：日志文件夹，/var/log/nginx/error.log：错误日志文件，/var/log/nginx/access.log：访问日志文件 /etc/nginx/nginx.conf：Nginx全局站点配置文件，日志文件可以在/etc/nginx/nginx.conf中配置，默认读取的配置文件 /etc/nginx/conf.d：自定义Nginx站点配置文件存放目录 /etc/nginx/conf.d/default.conf：网站默认站点配置 /usr/share/nginx/html：网站文件默认存放目录 sites-available：则是管理大量站点时服务器的一种通用配置。 sites-enabled：则是一种单独配置，需要使用enabled时，需要使用ln命令软连接到相应网站。 1sudo ln -s ~/path/to/your/mysite/mysite_nginx.conf /etc/nginx/sites-enabled/ /etc/nginx/nginx.conf中有如下语句：12include /etc/nginx/conf.d/*.conf;include /etc/nginx/sites-enabled/*; 可见，配置文件放在sites-avaliable文件夹中，需要创建软连接在sites-enabled中，才会生效。 server_name的作用其实是当该机器上同时部署了其他域名服务时起作用的。 如果nginx中只配置一个server域的话，则nginx是不会去进行server_name的匹配的。因为只有一个server域，也就是这有一个虚拟主机，那么肯定是发送到该nginx的所有请求均是要转发到这一个域的，即便做一次匹配也是没有用的。还不如干脆直接就省了。如果一个http域的server域有多个，nginx才会根据$hostname去匹配server_name进而把请求转发到匹配的server域中。此时的匹配会按照匹配的优先级进行，一旦匹配成功进不会再进行匹配 参考： nginx server_name怎么可有可无 location接受两个参数，一个字符串或者正则，和一段代码。字符串用于匹配某个特定目录。 123location / &#123; autoindex on; autoindex_exact_size off; # 默认是开，以b为单位，关闭后，会显示MB GB 注意点nginx 默认的账号权限太低，没有部分文件的访问权限，导致访问时出现 403 Forbidden。 配置文件 /etc/nginx/nginx.conf：1user nginx; 应该修改为：1user root; Nginx运行1/usr/sbin/nginx -h # 查看帮助 12345/usr/sbin/nginx -c /etc/nginx/nginx.conf # 默认也会读取该配置文件，所以，可以不加-c参数nginx # 运行/usr/sbin目录下的nginx的命令nginx -s reload # 运行这句话的前提是，nginx正在运行，重载，如果之前运行了stop，那么会提示出错 &quot;/run/nginx.pid&quot; failedservice nginx startservice nginx status FAQQ1：nginx: [error] open() “/usr/local/var/run/nginx.pid” failed (2: No such file or directory) nginx 重启报错:nginx Q2：中文乱码Nginx的server的配置内容，增加一行：charset utf-8; Nginx 显示中文乱码解决 Q3：权限问题导致Nginx 403 Forbidden错误的解决方法 权限问题导致Nginx 403 Forbidden错误的解决方法 参考 写给Web开发人员看的Nginx介绍 nginx配置初探 nginx配置文件参数详解（完整版） Nginx浏览目录配置及美化]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 基础知识学习]]></title>
    <url>%2F2019%2F06%2F08%2Fcicd-nginx-basic%2F</url>
    <content type="text"><![CDATA[资料基础 掘金-前端开发者必备的Nginx知识 介绍的比较综合，正向代理反向代理的区别、负载均衡等知识，都有介绍 静默虚空-Nginx 简易教程 博客园上的一篇推荐文章 简书-全面了解Nginx到底能做什么 Nginx的负载均衡 - 加权轮询 (Weighted Round Robin) 上篇，这个介绍了upstream资源池的调度算法之一，在其专栏还有其他介绍。 平滑的基于权重的轮询算法 ：本文也是介绍资源池调度算法的 理解nginx的配置：介绍的比较全面的一篇文章 Nginx实战（五） 反向代理 Understanding Nginx HTTP Proxying, Load Balancing, Buffering, and Caching 13 Nginx Location Directive Examples including Regular Expression Modifiers 关于location的作用介绍，很全面 Nginx的Upstream来做负载 部署两台WEB ：这个文章虽然比较少，但是里边明确了upstream名称和proxy_pass配置的对应关系。 proxy_pass的小说明：关于proxy_pass的一些FAQ Nginx 性能优化 百万并发下 Nginx 的优化之道 agentzh 的 Nginx 教程 常用命令12345678nginx -s stop 快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。nginx -s quit 平稳关闭Nginx，保存相关信息，有安排的结束web服务。nginx -s reload 因改变了Nginx相关配置，需要重新加载配置而重载。nginx -s reopen 重新打开日志文件。nginx -c filename 为 Nginx 指定一个配置文件，来代替缺省的。nginx -t 不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。nginx -v 显示 nginx 的版本。nginx -V 显示 nginx 的版本，编译器版本和配置参数。 反向代理 将server节点下的location节点中的proxy_pass配置为：http:// + upstream名称 app.conf：123456789101112131415161718192021222324252627282930313233343536373839404142upstream micahel-machine-manager &#123; server 100.253.128.222:40012; server 100.253.128.223:40012;&#125;upstream michael-machine-server &#123; server 100.253.128.55:40020; server 100.120.128.56:40020;&#125;server &#123; listen 80; server_name michael-api.hw.com; client_max_body_size 20M; client_body_buffer_size 10M; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_next_upstream error timeout invalid_header http_502 http_503 http_504; proxy_ignore_client_abort on; proxy_read_timeout 180; proxy_buffering on; proxy_buffer_size 8k; proxy_buffers 8 8M; gzip on; gzip_min_length 1000; gzip_types text/plain text/css application/json text/xml application/xml application/xml+rss text/javascript; location /MachineManager/ &#123; proxy_pass http://michael-machine-manager; &#125; location /MachineServer/ &#123; proxy_pass http://michael-machine-server; &#125; access_log /var/log/nginx/cid.hw.com-access.log main;&#125; 如何配置 Nginx 呢？可以利用这个神器： NginxConfig]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 docker-compose 安装搭建 RabbitMQ 集群]]></title>
    <url>%2F2019%2F06%2F07%2Fdocker-rabbitmq-env%2F</url>
    <content type="text"><![CDATA[本文介绍如何利用 Docker 方式创建 rabbitmq 集群。 rabbitmq 介绍在利用 Docker 创建 rabbitmq 容器之前，先了解 rabbitmq 的基础知识。 集群模式RabbitMQ 的 Cluster 集群模式一般分为两种，普通模式和镜像模式。 普通模式：默认的集群模式，以两个节点（rabbit01、rabbit02）为例来进行说明。对于 Queue 来说，消息实体只存在于其中一个节点 rabbit01（或者 rabbit02），rabbit01 和 rabbit02 两个节点仅有相同的元数据，即队列的结构。当消息进入 rabbit01 节点的 Queue 后，consumer 从 rabbit02 节点消费时，RabbitMQ 会临时在 rabbit01、rabbit02 间进行消息传输，把 A 中的消息实体取出并经过 B 发送给 consumer。所以 consumer 应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理 Queue。否则无论 consumer 连 rabbit01 或 rabbit02，出口总在 rabbit01，会产生瓶颈。当 rabbit01 节点故障后，rabbit02 节点无法取到 rabbit01 节点中还未消费的消息实体。如果做了消息持久化，那么得等 rabbit01 节点恢复，然后才可被消费；如果没有持久化的话，就会产生消息丢失的现象。 镜像模式：将需要消费的队列变为镜像队列，存在于多个节点，这样就可以实现 RabbitMQ 的 HA 高可用性。作用就是消息实体会主动在镜像节点之间实现同步，而不是像普通模式那样，在 consumer 消费数据时临时读取。缺点就是，集群内部的同步通讯会占用大量的网络带宽。 节点类型 RAM node：内存节点将所有的队列、交换机、绑定、用户、权限和 vhost 的元数据定义存储在内存中，好处是可以使得像交换机和队列声明等操作更加的快速 Disk node：将元数据存储在磁盘中，单节点系统只允许磁盘类型的节点，防止重启 RabbitMQ 的时候，丢失系统的配置信息 RabbitMQ 要求在集群中至少有一个磁盘节点，所有其他节点可以是内存节点，当节点加入或者离开集群时，必须要将该变更通知到至少一个磁盘节点。如果集群中唯一的一个磁盘节点崩溃的话，集群仍然可以保持运行，但是无法进行其他操作（增删改查），直到节点恢复。解决方案：设置两个磁盘节点，至少有一个是可用的，可以保存元数据的更改。 安装知识点 建立集群时，节点中的 Erlang Cookie 值要一致，默认情况下，文件在 /var/lib/rabbitmq/.erlang.cookie。 erlang 是通过主机名来连接服务，必须保证各个主机名之间可以 ping 通。可以通过编辑 /etc/hosts 来手工添加主机名和 IP 对应关系。如果主机名 ping 不通，rabbitmq 服务启动会失败。 123$ rabbitmqctl stop_app # 停止rabbitmq服务$ rabbitmqctl join_cluster rabbit@node1 # node2和node1构成集群, node2必须能通过node1的主机名ping通$ rabbitmqctl start_app # 开启rabbitmq服务 –ram 指的是作为内存节点,要是想做为磁盘节点的话,就不用加 –ram 这个参数了。在 RabbitMQ 集群里，必须至少有一个磁盘节点存在 1$ rabbitmqctl join_cluster --ram rabbit@node1 更改节点属性 123456$ rabbitmqctl stop_app # 停止rabbitmq服务$ rabbitmqctl change_cluster_node_type ram # 更改节点为内存节点Turning rabbit@node2 into a ram node$ rabbitmqctl change_cluster_node_type disc # 更改节点为磁盘节点Turning rabbit@node2 into a disc node$ rabbitmqctl start_app # 开启rabbitmq服务 查看集群的状态 1rabbitmqctl cluster_status 开启 web 管理工具 cluster 搭建起来后若在 web 管理工具中 rabbitmq_management 的 Overview 的 Nodes 部分看到 Node statistics not available 的信息，说明在该节点上web管理插件还未启用。 直接在显示提示信息的节点上运行： 1rabbitmq-plugins enable rabbitmq_management docker-compose基于 bitnami/bitnami-docker-rabbitmq 镜像，在一台机器上可以创建一个 rabbitmq cluster： docker-compose.yml 内容： 1234567891011121314151617181920212223242526272829303132333435363738version: '2'services: stats: image: bitnami/rabbitmq:3.7 environment: - RABBITMQ_NODE_TYPE=stats - RABBITMQ_NODE_NAME=rabbit@stats - RABBITMQ_ERL_COOKIE=s3cr3tc00ki3 ports: - '15672:15672' volumes: - 'rabbitmqstats_data:/bitnami' queue-disc1: image: bitnami/rabbitmq:3.7 environment: - RABBITMQ_NODE_TYPE=queue-disc - RABBITMQ_NODE_NAME=rabbit@queue-disc1 - RABBITMQ_CLUSTER_NODE_NAME=rabbit@stats - RABBITMQ_ERL_COOKIE=s3cr3tc00ki3 volumes: - 'rabbitmqdisc1_data:/bitnami' queue-ram1: image: bitnami/rabbitmq:3.7 environment: - RABBITMQ_NODE_TYPE=queue-ram - RABBITMQ_NODE_NAME=rabbit@queue-ram1 - RABBITMQ_CLUSTER_NODE_NAME=rabbit@stats - RABBITMQ_ERL_COOKIE=s3cr3tc00ki3 volumes: - 'rabbitmqram1_data:/bitnami'volumes: rabbitmqstats_data: driver: local rabbitmqdisc1_data: driver: local rabbitmqram1_data: driver: local docker-compose 语法格式： 1docker-compose [-f &lt;arg&gt;...] [options] [COMMAND] [ARGS...]` 运行 docker-compose up -d 运行，如果 docker-compose.yml 命名为其他名字，可以通过 -f 参数指定文件。 如上方式，会在主机上创建若干 volume，下面是一些关于 volume 的操作： 1234删除不使用的本地 volumesdocker volume prunedocker volume lsdocker volume rm &lt;volume name&gt; 如上创建好之后，是属于普通模式的集群。如果要设置为「镜像模式」，可以参考 Rabbitmq镜像集群部署，比较简单，在管理界面配置： Virtual host： 可选参数，针对指定vhost下的queue进行设置 Name: policy的名称 Pattern: queue的匹配模式(正则表达式) Definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode ha-mode:指明镜像队列的模式，有效值为 all/exactly/nodes all：表示在集群中所有的节点上进行镜像 exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定 nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定 ha-params：ha-mode模式需要用到的参数 ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual priority：可选参数，policy的优先级 其他方式创建容器节点123docker run -d --hostname rabbit1 --name myrabbit1 -p 15672:15672 -p 5672:5672 -e RABBITMQ_ERLANG_COOKIE='rabbitcookie' rabbitmq:3.6.15-managementdocker run -d --hostname rabbit2 --name myrabbit2 -p 5673:5672 --link myrabbit1:rabbit1 -e RABBITMQ_ERLANG_COOKIE='rabbitcookie' rabbitmq:3.6.15-managementdocker run -d --hostname rabbit3 --name myrabbit3 -p 5674:5672 --link myrabbit1:rabbit1 --link myrabbit2:rabbit2 -e RABBITMQ_ERLANG_COOKIE='rabbitcookie' rabbitmq:3.6.15-management 多个容器之间使用 --link 连接，此属性不能少；--link &lt;docker-name or docker-id&gt;:alias,alias 是源容器在 link 下的别名 Erlang Cookie值必须相同，也就是 RABBITMQ_ERLANG_COOKIE 参数的值必须相同； 要想知道 Erlang Cookie 位置，首先要取得 RabbitMQ 启动日志里面的 home dir 路径，作为根路径。使用：docker logs 容器名称 查看。 加入 RabbitMQ 节点到集群设置节点1： 12345docker exec -it myrabbit1 bashrabbitmqctl stop_apprabbitmqctl resetrabbitmqctl start_appexit 设置节点2，加入到集群： 123456docker exec -it myrabbit2 bashrabbitmqctl stop_apprabbitmqctl resetrabbitmqctl join_cluster --ram rabbit@rabbit1rabbitmqctl start_appexit 参数 --ram 表示设置为内存节点，忽略次参数默认为磁盘节点。 设置节点3，加入到集群： 123456docker exec -it myrabbit3 bashrabbitmqctl stop_apprabbitmqctl resetrabbitmqctl join_cluster --ram rabbit@rabbit1rabbitmqctl start_appexit 设置好之后，使用 http://物理机ip:15672 进行访问了，默认账号密码是 guest/guest 参考MQ 安装： CentOs7.3 搭建 RabbitMQ 3.6 Cluster 集群服务与使用 王磊的博客-RabbitMQ系列（五）使用Docker部署RabbitMQ集群 docker-compose配置rabbitmq集群服务器 官宣-Clustering Guide RabbitMQ 集群部署 MQ 使用： rabbbitmq 堆积分析 RabbitMQ使用教程（四）如何通过持久化保证消息99.99%不丢失？]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>容器</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用 Docker 安装 CICD 神器 Jenkins]]></title>
    <url>%2F2019%2F06%2F04%2Fcicd-docker-jenkins%2F</url>
    <content type="text"><![CDATA[Jenkins 学习系列： CentOS 安装 CICD 利器 Jenkins 利用 Docker 安装 CICD 神器 Jenkins 本文主要介绍如何利用 Docker 来快速搭建 Jenkins，相比较以前的方式，方便快捷很多！ 准备工作由于是基于 Docker 安装 Jenkins，因此，你的环境上必须要安装好 Dokcer，并配置好加速器，不然下载镜像速度可能会比较慢。怎么安装，可以参考如下文章： Linux–CentOS 安装 Docker 教程 Docker 入门指南——常用命令 使用容器 Docker 创建开发环境 Docker 命令运行 Jenkinsjenkinsci/blueocean 是官方推荐的镜像版本，集成了流水线插键，推荐： 123456789docker run \ -u root \ --name devops-jenkins \ -d \ -p 8080:8080 \ -p 50000:50000 \ -v /data/docker_local/jenkins-data:/var/jenkins_home \ -v /var/run/docker.sock:/var/run/docker.sock \ jenkinsci/blueocean:1.15.1 参数说明： -u root：（可选）由于默认的 jenkins用户无权访问 /var/run/docker.sock，您需要以 root 身份运行 Jenkins 以允许 Jenkins 在你流水线上生成 docker 容器执行步骤。这仅影响在 Jenkins 主节点上的运行，如果你计划在你的流水线执行机上去执行，那这不是必须的。 jenkinsci/blueocean 容器的端口 8080 到主机上的端口 8080。 第一个数字代表主机上的端口，而最后一个代表容器的端口。因此，如果您为此选项指定 -p 49000:8080 ，您将通过端口主机端口 49000 访问 Jenkins 更多对参数的说明，访问Installing Jenkins Docker-Compose 运行 Jenkins12345678910111213version: "3"services: jenkins: image: jenkinsci/blueocean:1.15.1 container_name: devops-jenkins # 容器名 user: root restart: always ports: - "8080:8080" - "50000:50000" volumes: - "/data/docker_local/jenkins-data:/var/jenkins_home" - "/var/run/docker.sock:/var/run/docker.sock" 配置配置插键代理为了提高插键的下载速度，插键高级配置中，配置国内的代理： https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json 有一个页面，专门查看 Jenkins 镜像状态的： the status of Jenkins mirrors 常用命令查看 Jenkins 的运行日志： 1docker logs -f jenkins 归档 awesome-docker-service-for-me 参考 官宣-安装Jenkins-中文 发现翻译的并不是特别好，推荐看英文 K8S牛刀小试CI之Jenkins on Docker篇(二)/)]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>cicd</tag>
        <tag>DevOps</tag>
        <tag>Jenkins</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用容器 Docker 创建开发环境]]></title>
    <url>%2F2019%2F06%2F02%2Fdocker-create-develop-environment%2F</url>
    <content type="text"><![CDATA[Docker 容器学习笔记系列： Linux–CentOS 安装 Docker 教程 Docker 入门指南——常用命令 使用容器 Docker 创建开发环境 个人在开发时能方便快捷的搭建对应的测试环境，比如搭建一个 Redis 数据库、MongoDB 数据库、Elasticsearch 服务。这样就不用拿公共的基础设施做测试了，避免损坏数据、破坏了线上环境。 本文就介绍如何利用容器 Docker 来快速搭建开发测试环境。 MySQL简单创建12345docker run -d \--name mysql \-p 3306:3306 \-e MYSQL_ROOT_PASSWORD=123456 \mysql:5.7 参数说明： -d：以后台方式运行 --name：将运行的容器命名为 mysql -p：端口映射，host_ip:container_ip，将主机的 3306 端口映射为 容器内部的 3306 端口，数据库连接时，是连接的你的 host_ip，这二者的顺序不要搞混 -e：设置环境变量，指定 root 账号的密码为 123456 上面这种方式运行后，我们将容器中的 mysql 数据和配置文件拷贝到宿主机上。（获取原始配置文件）。 因为没有将宿主机和容器相关目录挂载，这样会导致容器如果被删除，数据会丢失。 12345678# 创建好目录，不然会报错mkdir -p /dada/docker_local/mysql# 将容器中的 mysql 配置文件复制到宿主机中指定路径下，路径你可以根据需要，自行修改docker cp mysql:/etc/mysql/mysql.conf.d/mysqld.cnf /data/docker_local/mysql/config# 将容器中的 mysql 存储目录复制到宿主机中docker cp mysql:/var/lib/mysql/ /data/docker_local/mysql/data 这里放一份默认的配置文件 mysqld.cnf：123456789[mysqld]pid-file = /var/run/mysqld/mysqld.pidsocket = /var/run/mysqld/mysqld.sockdatadir = /var/lib/mysql#log-error = /var/log/mysql/error.log# By default we only accept connections from localhost#bind-address = 127.0.0.1# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0 完成上面的操作之后，将已经运行的容器删除：1docker rm mysql 正式创建接下来正式运行 MySQL 容器：1234567docker run -d \--name mysql \-p 3306:3306 \-v /data/docker_local/mysql/config/mysqld.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf \-v /data/docker_local/mysql/data/mysql:/var/lib/mysql \-e MYSQL_ROOT_PASSWORD=123456 \mysql:5.7 -v 将宿主机中的文件挂载到将容器中，容器中产生的数据会持久化下来，语法：-v [host-src:]container-dest[:&lt;options&gt;] 其实，如果你一开始就有了默认的配置文件，那么，就可以跳过之前的步骤，直接运行正式的创建 MySQL 容器的命令。 MongoDB创建容器1234567891011# 创建持久化目录mkdir -p /data/docker_local/mongo/configdbmkdir -p /data/docker_local/mongo/data/dbdocker run -d \--name mongo \-v /data/docker_local/mongo/configdb:/data/configdb \-v /data/docker_local/mongo/data/db:/data/db \-p 27017:27017 \mongo:4 \--auth 启动参数含义在 MySQL 启动时已经见过了，除了 auth： --auth：开启权限验证模式。默认情况下，mongo 数据库没有添加认证约束，为了增强数据库的安全性，我们需要对数据库添加授权认证。当我不加这个认证约束时，一个数据库的账号可以操作另一个数据库的数据，只有加了这个参数，我们针对某些数据库设置的角色，才仅在这个数据库上生效。 添加管理员账号 进入容器1docker exec -it mongo mongo admin 进入容器 mongo，运行命令 mongo admin，实现了： 进入 mongo 命令行 切换为 admin 数据库 创建一个拥有最高权限的 root 账号：1db.createUser(&#123; user: &apos;admin&apos;, pwd: &apos;123456&apos;, roles: [ &#123; role: &quot;root&quot;, db: &quot;admin&quot; &#125; ] &#125;); role 角色参数： Read：允许用户读取指定数据库 readWrite：允许用户读写指定数据库 dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile userAdmin：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户 clusterAdmin：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限 readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限 readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限 userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限 dbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限 root：只在admin数据库中可用。超级账号，超级权限 创建访问指定数据库的用户管理员已经创建成功后，我们需要重新连接 mongo 数据库，用管理员进行登录，并为目标数据库创建目标用户 12345678910111213# 进入容器，并切换到 admin 数据库docker exec -it mongo mongo admin# 授权 admindb.auth("admin", "123456");# 创建访问指定数据库的用户use beta;db.createUser(&#123; user: 'test', pwd:'test', roles: [ &#123;role:"readWrite",db:"beta"&#125;]&#125;);db.auth("test","test");# 尝试插入一条数据use betadb.test.insertOne(&#123;name:"michael",age:"28"&#125;)# 搜索 test collection 全部记录db.test.find() test 用户可以对(也只能对) beta 库进行操作 补充： 查看容器运行日志：docker logs mysql docker-composedocker-compse 俗称 Docker 三剑客，这里试试用它来同时启动 MySQL、MongoDB 吧： 12345678910111213141516171819202122232425version: "2"services: mongodb: image: mongo:4 container_name: mongodb # 容器名 ports: - "27017:27017" volumes: - "/data/docker_local/mongo/configdb:/data/configdb" - "/data/docker_local/mongo/data/db:/data/db" command: --auth # 开启授权验证 mysql: image: mysql:5.7 container_name: mysqldb # 容器名 ports: - "3306:3306" command: mysqld --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci #设置utf8字符集 restart: always environment: MYSQL_ROOT_PASSWORD: 123456 #root管理员用户密码 MYSQL_USER: test #创建test用户 MYSQL_PASSWORD: test #设置test用户的密码 volumes: - "/data/docker_local/mysql/config/mysqld.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf" - "/data/docker_local/mysql/data/mysql:/var/lib/mysql" 进入到上面编写的docker-compose.yml文件的目录，运行命令：123456789101112131415161718# 启动所有服务docker-compose up -d# 单启动 mysqldocker-compose up -d mysql# 暂停 mysqldocker-compose stop mysql# 重新启动容器docker-compose restart mysql# 登录到容器中docker-compose exec mysql bash# 删除所有容器和镜像docker-compose down# 显示所有容器docker-compose ps# 查看mysql的日志docker-compose logs mysql# 查看mysql的实时日志docker-compose logs -f mysql nginx123456789101112server &#123; client_max_body_size 4G; listen 8889; ## listen for ipv4; this line is default and implied server_name &lt;host_ip or domain_name&gt;; # 换成你服务器的 IP 或绑定的域名 charset utf-8; root /data; location / &#123; autoindex on; autoindex_exact_size off; # 默认是开，以b为单位，关闭后，会显示MB GB autoindex_localtime on; &#125;&#125; 为了避免中文乱码，需要配置 charset utf-8; 示例文件 Github-awesome-docker-service-for-me 参考 使用Docker快速搭建各种测试环境 本文主要参考 Docker初步实践 CSDN-docker安装mongo及开启用户认证 docker-compose 安装mysql5.7 使用 Docker Compose 搭建 MySQL 数据库主从复制实例]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>Env</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 入门指南——常用命令]]></title>
    <url>%2F2019%2F06%2F02%2Fdocker-useful-often-commands%2F</url>
    <content type="text"><![CDATA[Docker 容器学习笔记系列： Linux–CentOS 安装 Docker 教程 Docker 入门指南——常用命令 使用容器 Docker 创建开发环境 前面已经介绍了 Docker 的安装方式，本文总结一下使用 Docker 的基本概念和常用命令。 基本概念镜像 Image镜像是一些打包好的已有的环境，可以被用来启动和创建容器 容器 Container容器是镜像的实例化 容器的UUIDUUID – 通用唯一标识符（Universally Unique Identifier） 容器有三种方式来进行标识： 长UUID 短UUID Name UUID 是 Docker daemon 产生的，在一台主机上是唯一的，在创建容器的时候可以通过 --name 来指定容器的名字，如果不指定会自动分配一个字符串名称。 通过 docker ps、docker inspect 等命令可以查看到容器的标识信息 容器启动过程 检查本地是否存在指定的镜像，不存在就从公有仓库下载 利用镜像创建并启动一个容器 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去 从地址池配置一个 ip 地址给容器 执行用户指定的应用程序 执行完毕后容器被终止 镜像 查看 image 列表： 1docker iamges 下载镜像： 1docker pull registry.domain.com/library/ubuntu:14.04 制作镜像12# 常用下面这种方式制作镜像，Dockerfile 文件更透明docker build [-f DockerfileName] -t image_name DockerfilePath 这里 DockerfilePath 是 Context 上下文目录，在创建的时候会全部上传到 Docker Server 端，所以这个目录不要太大。 参数说明： -f/--file：Name of the Dockerfile (Default is ‘PATH/Dockerfile’)，Dockerfile的完整路径 -t/--tag：Name and optionally a tag in the ‘name:tag’ format，指定了镜像名称，镜像的名字及 tag，通常 name:tag 或者 name 格式 --no-cache：Do not use cache when building the image，这篇文章介绍了使用这个参数的场景，构建镜像中有时候包含 git clone 命令，会默认使用缓存，新代码就不会下载了，所以，有时候需要加上这个参数； --pull，默认 false。Always attempt to pull a newer version of the image，设置该选项，总是尝试 pull 镜像的最新版本 其他的 build 参数，可以采用 docker build -h 查看。 删除镜像删除 image 之前，需要先删除 container:12docker ps -adocker rm container_id/container_name 删除 image:12docker rmi &lt;image-id&gt;docker rmi &lt;image-name&gt;:&lt;tag&gt; 删除虚悬镜像(dangling image)：12345$docker image ls -f dangling=true #列出虚悬镜像$ docker image pruneWARNING! This will remove all dangling images.Are you sure you want to continue? [y/N] y 无tag镜像(dangling)显示无 tag 镜像：1$ docker images --filter &quot;dangling=true&quot; 当新构建的镜像占用这个镜像ID的 repo:tag 时，会出现这些图像，将其保留为 ： 或 untagged。可以使用如下命令批量删除这类镜像1$ docker rmi $(docker images -f "dangling=true" -q) 迁移镜像保存镜像到文件，语法格式：1docker save [OPTIONS] IMAGE [IMAGE...] 例如：123docker save image_name -o file.tar# Ordocker save image_name --output file.zip 将镜像保存一个 tar 包文件了，也可以是 zip 格式的压缩包。 加载一个 tar 包的镜像：1docker load -i file.tar 容器操作 查看运行中的容器 1docker ps 查看所有容器 1docker ps -a 显示运行的容器里的进程信息 1docker top cid 此处， cid 表示你运行的容器名 显示容器详细信息 1docker inspect cid 日志查看 123docker logs cid# 实时查看日志输出docker logs -f cid 查看容器root用户密码 1docker logs cid 2&gt;&amp;1 | grep &apos;^User: &apos; | tail -n1 容器运行语法格式：1Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...] 例如：1docker run -it --name cidregistry.domain.com/library/ubuntu:14.04 如果直接 docker run -it registry.domain.com/library/ubuntu 可能会出错，因为不加 tag ，默认就去运行 latest 版本，而本地没有 latest 版本，所以，需要将 image+tag，以冒号分隔拉去。 -i 交互操作 -t 终端 --name 指定容器名字 -d 后台运行一个容器 --rm，表明退出容器后随之将其删除，可以避免浪费空间 -p 映射端口 -v 挂载 volumn --privileged=false 容器内 root 拥有真正 root 权限 当处于一个容器中时，利用exit退出容器 在容器中运行一段程序 1docker run ubuntu apt-get update 启动已终止（stop）容器：1docker restart 3e8 # 3e8 为容器的 id 号，不需要全写，也可以用容器名替代 进入容器 进入正在运行的容器，退出不会造成容器停止： 1docker exec -it cid /bin/bash 附着到正在运行的容器中，退出时会导致容器终止，不常用： 1docker attach cid 从容器拷贝文件出来拷贝文件出来1docker cp cid:/container_path to_path 删除容器123456docker rm cid# 强制删除docker rm -f cid# 删除所有容器# -q 表示只列出容器的 id 值docker rm `docker ps -a -q` 容器运行状态修改1docker start/stop/kill/restart cid 更改容器名字1docker rename old new 修改容器，制作镜像image 相当于类，container 相当于实例，不过可以动态给实例安装新软件，然后把这个 container 用 commit 命令固化成一个 image：1docker commit -m "修改yum源" -a "michaelxiang" cid registry.domain.com/ci/centos-os:latest 这种制作镜像的方式并不推荐，因为不如 Dockerfile 方式透明。 推送镜像12docker login registry.domain.com -u username -p passworddocker push registry.domain.com/michael/IMAGE[:TAG] 如果支持 accesstoken 权限认证： 1docker login registry.domain.com -u test -p ACCESSTOKEN:XXXXXXXXXXXXX:ACCESSTOKEN docker-compose它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。 Compose 中有两个重要的概念： 服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。 项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。 Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理 如何写docker-compose.yml，Docker compose file 参考文档 官宣-Overview of docker-compose CLI Docker 三剑客之 Compose 项目 其他你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间： 1docker system df docker 配置daemon.json 文件123456789&#123; "insecure-registries": ["registry.xxx.com"], "registry-mirrors": ["https://xxxx.mirror.domain.com"], "exec-opts": ["native.cgroupdriver=systemd"], "storage-driver": "overlay2", "storage-opts": [ "overlay2.override_kernel_check=true" ]&#125; FAQQ1：Docker 空间问题Docker长时间运行后的volumes目录清理 悟能-Docker长时间运行后的volumes目录清理 参考命令： 官宣——Command-Line Interfaces (CLIs) 强烈推荐 Docker 使用总结 本文的主要参考 Docker 入门教程 Docker —— 从入门到实践 只要一小时，零基础入门Docker SF-docker命令详解 简书-Docker命令使用 Docker命令行参考(8) – docker images列出镜像 删除无 tag 镜像 镜像登录： docker搭建私有仓库、自签发证书、登录认证 容器间的通信： Docker容器与宿主机同网段互相通信 关于对docker run –link的理解 cizixs-docker 容器的网络模式]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序流程图学习笔记]]></title>
    <url>%2F2019%2F06%2F01%2Ftools-dev-program-flowchart%2F</url>
    <content type="text"><![CDATA[最近刚刚加入了部署小组，对接各个部署系统，业务逻辑有点繁杂，这时候想起来之前学过的流程图，或许，它可以帮我顺利整理出各个业务逻辑吧，因此，有了本文。 概念流程图（FlowChart）是表示算法、工作流或流程的一种框图表示，它以不同类型的框代表不同种类的步骤，每两个步骤之间则以箭头连接。这种表示方法便于说明解决已知问题的方法。流程图在分析、设计、记录及操控许多领域的流程或程序都有广泛应用。 符号 美国国家标准协会是1960年代就开始制定流程图及一些标准符号[3]。而在1970年，国际标准化组织采用其方案[4]。现时通用的版本ISO 5807是在1985年修订[5]。 所以，流程图的绘制是有标准的，每种符号都有其代表的含义。做事，就要做专业。 循环流程图示例for 循环for 循环形式：123for (表达式 1；表达式 2；表达式 3)&#123; 执行语句；&#125; while 循环while 循环形式：123while (条件表达式)&#123; 执行语句；&#125; do-while 循环do-while 循环形式：123do&#123; 执行语句；&#125; while(条件表达式) 经验 如果你在公司里不是一锤定音式的人物的话，你就需要对你的文档进行版本管理。流程图也不例外，什么时间发布的什么版本，都要清楚地标出来，「最新」是个用不得的词。 参考 wiki-流程图 office-建立基本流程圖 这个包含了一些 Visio 制作流程图的技巧 edraw-流程图专栏 这里介绍了很多技巧 丁宇-画Web流程图的一点心得 该作者博客还总结了一篇英文版的 The definitive guide to Web flowcharts 编程基本功训练：流程图画法及练习 介绍了一些比较复杂的例子，借鉴意义 【软件工程】看我火眼金睛——系统流程图、程序流程图、数据流图、活动图、状态图、顺序图辨析 介绍了流程图、时序图、数据流程图等基本概念]]></content>
      <categories>
        <category>ToolsDev</category>
      </categories>
      <tags>
        <tag>绘图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux——CentOS 安装 Docker 教程]]></title>
    <url>%2F2019%2F06%2F01%2Fdocker-centos-install%2F</url>
    <content type="text"><![CDATA[Docker 容器学习笔记系列： Linux–CentOS 安装 Docker 教程 Docker 入门指南——常用命令 使用容器 Docker 创建开发环境 本文主要介绍 CentOS 系统安装 Docker 的流程。 前提条件OS 要求CentOS7: The centos-extras repository must be enabled. This repository is enabled by default, but if you have disabled it, you need to re-enable it.The overlay2 storage driver is recommended 卸载旧的版本较旧版本的 Docker 被称为 docker 或 docker-engine。如果已安装这些，请卸载它们以及相关的依赖项： 12345678910sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine /var/lib/docker 目录下保存着镜像、容器、卷、网络。官方文档安装的 docker-ce 包，内部源中只有 docker-engine包，docker-ce 是最新的社区版本的包名。 安装 Docker CE使用源安装设置源1.安装依赖的包，yum tils 提供了 yum-config-manager 套件， device-mapper-persistent-data 和 lvm2 是 devicemapper 存储驱动所依赖的包。 123$ sudo yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 2.使用如下命令设置 stable 源： 123$ sudo yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo 国内可选择清华大学源-Docker Community Edition 镜像使用帮助 安装 Docker CE1.安装最新版本的 Docker CE：1$ sudo yum install docker-ce 2.要安装特定版本的 Docker CE，可在 repo 中列出可用版本，然后选择并安装：1$ yum list docker-ce --showduplicates | sort -r Docker 安装之后， docker 组就被创建了，但没有用户加到这个群组中。 3.启动 Docekr：1$ sudo systemctl start docker 4.可以通过运行 hello-world 镜像来验证 docker 的安装成功：1sudo docker run hello-world` 这个命令下载一个测试镜像，在容器中运行它。当容器运行时，它会打印一条信息并退出。 从 RPM 包安装如果无法使用 Docker的源来安装 Docker，则可以下载适用于您的发行版的 .rpm 文件并手动安装。每次要升级 Docker 时都需要下载新文件。 去 https://download.docker.com/linux/centos/7/x86_64/stable/Packages/ 下载 rpm 包 安装 Docker CE：$ sudo yum install /path/to/package.rpm 升级 Docker CE使用 yum -y upgrade docker-ce 升级版本。 卸载 卸载 Docker 包：$ sudo yum remove docker-ce 主机上的镜像、容器、卷或自定义配置文件不会自动删除。为了删除这些文件，可以运行如下命令：$ sudo rm -rf /var/lib/docker 你必须手动删除任何已编辑的配置文件 注意点 如果非 root 用户想要使用 Docker，你应该将该用户添加到 docker 组中：sudo usermod -aG docker your-user 安装 Docker CE 之后，它在基于 DEB 的发行版上会自动启动。在基于 RPM 的发行版上，需要使用相应的 systemctl 或 service 命令手动启动它 使用 systemd 控制 Docker使用 systemd 控制 Docker 手动启动大多数 Linux 发行版使用 systemctl 启动服务，如果没有，就用 service命令： systemctl:$ sudo systemctl start docker service:$ sudo service docker start 系统自启If you want Docker to start at boot, see如果你想要实现开启自启 docker，可以看看这篇文章 Configure Docker to start on boot 1systemctl list-unit-files|grep docker # 查看 Docker 服务状态 配置 Docker daemon 选项推荐的方法是使用平台独立的 daemon.json 文件，默认位于 /etc/docker/ 中。详细配置项，查看官宣-Daemon configuration file，有一份中文的备注说明：docker daemon(dockerd)配置文件daemon.json。 你可以使用 daemon.json 配置几乎所有守护程序配置选项。下面的例子配置了两个选项。你不能使用 daemon.json 机制配置的一个选项是 HTTP proxy。 Runtime directory and storage driver你可能想要通过移动镜像、容器和卷到独立分区来控制磁盘空间。 为了实现这个，可以在 daemon.json 中做如下配置：1234&#123; &quot;data-root&quot;: &quot;/mnt/docker-data&quot;, &quot;storage-driver&quot;: &quot;overlay&quot;&#125; HTTP/HTTPS proxyDocker 守护进程使用 HTTP_PROXY, HTTPS_PROXY 和 NO_PROXY 环境变量在它的启动环境中来配置 HTTP 和 HTTPS 代理。你不能使用 daemon.json 文件来配置这些环境变量。 如果你使用的是 HTTP 或 HTTPS 代理服务器，例如在公司设置中，则需要将此配置添加到 Docker systemd 服务文件中。 1.为 docker 服务创建一个 systemd 目录：1$ sudo mkdir -p /etc/systemd/system/docker.service.d 2.创建一个文件 /etc/systemd/system/docker.service.d/http-proxy.conf，加入 HTTP_PROXY 环境变量：12[Service]Environment=&quot;HTTP_PROXY=http://proxy.example.com:80/&quot; 或者，如果你使用 HTTPS 代理服务，创建一个文件 /etc/systemd/system/docker.service.d/https-proxy.conf，加入 HTTPS_PROXY 环境变量：12[Service]Environment=&quot;HTTPS_PROXY=https://proxy.example.com:443/&quot; 3.如果你拥有内部的 Docker registries 服务或者要使用国内的镜像加速器-daocloud.io，你需要通过指定 NO_PROXY 环境变量来不通过代理访问它们：12[Service]Environment=&quot;HTTP_PROXY=http://proxy.example.com:80/&quot; &quot;NO_PROXY=localhost,127.0.0.1,docker-registry.somecorporation.com,daocloud.io&quot; 这样，你访问 NO_PROXY 中的网址时，就不会走代理，速度会比较快。 Or, if you are behind an HTTPS proxy server:12[Service]Environment=&quot;HTTPS_PROXY=https://proxy.example.com:443/&quot; &quot;NO_PROXY=localhost,127.0.0.1,docker-registry.somecorporation.com&quot; 一个实际配置的栗子：1234567mkdir -p /etc/systemd/system/docker.service.d/ # 先保证有这个目录cat &lt;&lt;&apos;EOF&apos;&gt;/etc/systemd/system/docker.service.d/http-proxy.conf # 这里一定要记得让内部镜像仓地址不要走代理,否则无法访问我们私有的镜像仓[Service]Environment=&quot;HTTP_PROXY=http://127.0.0.1:3128/&quot;Environment=&quot;HTTPS_PROXY=http://127.0.0.1:3128/&quot;Environment=&quot;NO_PROXY=localhost,127.0.0.0/8,.domain.com&quot;EOF 4.Flush changes:1$ sudo systemctl daemon-reload 5.重启 Docker：1$ sudo systemctl restart docker 6.验证配置项已经被加载：12$ systemctl show --property=Environment dockerEnvironment=HTTP_PROXY=http://proxy.example.com:80/ 如果你采用的 HTTPS 代理：12$ systemctl show --property=Environment dockerEnvironment=HTTPS_PROXY=https://proxy.example.com:443/ 手动创建 systemd 单元文件当你手动安装 Docker 时，如果你想要用 systemd 管理 Docker，可以安装两个单元文件 service 和 socket，参考 moby/contrib/init/systemd/，下载文件至 /etc/systemd/system。 配置使用 docker 镜像仓库选择一：ustc的镜像新版的 Docker 使用 /etc/docker/daemon.json（Linux） 配置 Daemon： 123&#123; &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]&#125; USTC-Docker镜像使用帮助 选择二：Docker 中国官方镜像加速123&#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]&#125; Docker 中国官方镜像加速 Docker 拖取镜像默认走的是 HTTPS 协议（443端口），一般私有仓库都没有合法的 HTTPS 证书，通过通过配置私有仓库为非安全仓库：123&#123; &quot;insecure-registries&quot; : [&quot;hub.h.com&quot;]&#125; insecure-registries 就是配置的非安全仓库的地址。 测试配置的结果： busybox是一个集成了一百多个最常用linux命令和工具的软件,同时它也是一个最小的Linux系统，它提供了该系统的主要功能，例如grep、find、mount以及telnet等但不包含一些与GNU相关的功能和选项 1docker pull busybox Docker 存储驱动Linux kernel 4.0以后才支持的overlay2（Linux kernel 3.18以后才支持的叫overlayFS）。同时请确保docker的服务端版本不低于1.12，否则无法支持。uname -sr 可以查看系统内核版本。 Docker 1.12.6/v17.03 文档中 CentOS7 系统下安装时，明确说明，用于生产时，必须使用 devicemapper 驱动的 direct-lvm 模式，需要我们提前准备好块设备，以提供更好的稳定性和性能。默认使用 devicemapper 驱动的 loop-lvm 模式，因为安装简单，只适用于测试环境。从 docker info 信息可以看出，loop-lvm 模式最大可用空间只有107GB。生产环境下必须使用 devicemapper 驱动的 direct-lvm 模式，使用块设备，速度更快并且能更有效地使用系统资源。 在 Docker v17.06 及以后的版本中，关于 OverlayFS 存储驱动，尽量使用 overlay2 而不要使用 overlay，官方的说明是 overlay 可以使用但不建议。使用 overlay2 时 Linux 系统内核要求4.0以上，或者 CentOS7 的内核在 3.10.0-693 以上。Docker-CE v17.06 及以上，在使用 overlay2 驱动时，还需要设置额外的参数，以禁止检测内核为4.0版本。 12345678910111213141516171819202122232425262728293031#查看当前存储驱动docker info|grep -i storage#停止Dockerservice docker stop#清空数据，如果有啥需要的请自己备份rm -rf /var/lib/docker/*#修改配置文件vi /etc/docker/daemon.json#如果没有这个文件或没有内容，就直接把下面的粘贴进去#不然就只添加那一条#如果不是在最后一行加请自行在末尾添加逗号&#123; "storage-driver": "overlay2"&#125;#如果是CentOS7或者RedHat7内核在3.10.0-693以下的，设置额外的参数：&#123; "storage-driver": "overlay2", "storage-opts": [ "overlay2.override_kernel_check=true" ]&#125;#当然，也可以通过给docker修改启动参数的方式来# 1.修改/etc/init.d/docker# 这个直接在 dockerd 后面加参数就行，不过其实和下面的差不多# 2.修改/etc/sysconfig/docker# 改成类似 other_args="-s overlay2"# 3.修改/usr/lib/systemd/system/docker.service# 改成类似 ExecStart=/usr/bin/dockerd -s overlay2#启动dockerservice docker start 通常在生产构建机器上，一般系统盘大小都不大，都会挂载一个较大容量的数据盘，比如 data 目录。那么，为了避免日后 Docker 的根目录 /var/lib/mock过大，撑爆系统盘，我们需要想办法修改一下 Docker 的根目录，主要有两种办法： 1.先备份 /var/lib/docker的内容，然后在创建/data/docker的软连接: ln -s /data/docker /var/lib/docker 2.修改 daemon.json 配置： 123456&#123;# before before 17.06-ce"graph": "/data/docker",# docker after 17.06-ce"data-root":"/data/docker",&#125; 参考 官宣-Get Docker CE for CentOS 官宣-Control Docker with systemd-Docker代理设置 如何在CentOS 7中安装Docker 这篇文章中提到为了使用 overlay2 必须升级 CentOS 内核，其实也可以不用的 Dockuer Hub 镜像： 第二天堂-Docker 设置 socks5 代理或使用国内镜像 伊布-国内 docker 仓库镜像对比 文中附有一个测试镜像速度的脚本 阿里云-Docker 镜像加速器 华为云-Docker Hub 服务 存储驱动： 老高的技术博客-centos升级内核版本以支持overlay2 深入了解Docker存储驱动 一个关于容器和 K8s 相关的社区 官宣-Use the OverlayFS storage driver 官宣-Docker storage drivers senra-Docker切换OverLay(2)——提高性能，加快速度 CentOS7.x系统中使用Docker时，在存储方面需要注意的问题 运维笔记-DOCKER更改镜像存储位置 描述了常见修改存储位置的两个方法，同时，提到了新旧版本的配置项的注意点 SOF-How to change the docker image installation directory 解释了不同版本根目录配置项的区别]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】说说云计算中的地域和可用区概念]]></title>
    <url>%2F2019%2F06%2F01%2Fcloud-concept-region-az%2F</url>
    <content type="text"><![CDATA[原文链接： 说说云计算中的地域和可用区概念 亚马逊 AWS 是公共云计算的先驱，一些云计算中重要的产品设计和基础概念可以说都是亚马逊引入的。这其中有两个非常重要的概念：地域（Region）和可用区（AZ：Availabe Zone）。很多第一次接触云计算的同学，光看这两个名字的字面意义，虽然也能够猜出大致的意思，但深入的学习了解云计算一段时间之后，才能深刻的体会这两个概念对于云计算的重要影响。包括国内的这些云计算服务商，也是过了很长时间才陆续在产品中引入可用区的设计的。 理想情况下，我们当然希望云计算能够彻底消除地域的影响，就像我们用电的时候不用关心发电厂在哪里一样。但现实显然没有那么美好，不同地域的机房之间的网络还做不到像电网一样透明。所以在云计算产品的最底层，首先需要考虑不同地域的影响。不同地域之间，一般只能通过公网连通，内部之间网络是不通的。当然，对于云计算服务商来说，为管理需要，一般还是会通过有限的带宽来连通不同地域的机房，用于云计算内部资源管理，以及一些特殊的产品场景，比如跨地域的镜像复制。但因为内部带宽有限，一般不会完全开放给用户使用。 所以，地域就是物理意义上的不同地方的机房，这个不同地方，一般来说距离较远，机房之间用光纤直连的成本较高。并且相对来说会在用户需求量较大的地方部署地域机房，比如阿里云的云服务器的地域在境内有杭州，上海，北京，深圳，青岛，海外已经上线的包括香港、硅谷和新加坡。实际上阿里云一开始是没有上海地域的，因为上海杭州距离较近，部署直连光纤的成本也相对可控，阿里内部之前很多应用都是分别部署在杭州和上海，基本上是当作一个地域来使用的，后来可能因为需求大而分开了。 所以，地域很好理解，就是物理上相隔较远的机房，因为跨地域的机房之间的带宽无法满足内网需求，所以不同地域的机器之间内网是不通的。当然，随着骨干网络等物理层基础设施的发展，未来跨地域内网连通并非完全不可能的事情。在这个过程中，公共云计算服务商也可能根据用户的诉求，在某些场景开放一些有限的内部网络带宽来做产品，比如，前面说的阿里云的跨地域镜像复制，以及最近推出来的OSS跨地域复制等。一般来说，在数据和存储领域内的产品会先行支持跨地域的功能，毕竟数据容灾是更强烈的需求。 那么，同一个地域之内又分成多个可用区，为什么要搞这么复杂？原因很简单，IT系统从远古时代就有同城容灾的需求，那使用云计算以后，怎么实现同城跨机房容灾呢？如果用户购买的云服务器无法区分在哪个机房，那么就无法在业务应用层面来设计同城容灾。所以云计算服务商提出了同地域内不同可用区的概念，简单点理解，可以认为就是同城不同机房，云计算服务商会从底层的机房电力/网络等层面仔细设计来保障一个可用区出现故障的时候不会影响到另外一个可用区，当然你要说杭州彻底被钱塘江潮淹没的情况，那可用区也救不了你，要在业务应用层面考虑通过不同的地域来设计异地容灾了。 所以，简单来说，可以将地域理解为不同城市的机房，将可用区理解为同一个城市的不同机房。当然，实际上不同可用区也可能是在同一个机房，可用区的概念严格来说是按照电力和网络设备等相互独立来设计的。同一个地域内的不同可用区之间，内网是连通的，但是网络的响应时间会有差异。下面是我用阿里云杭州地域做的一次 ping 的测试，来观察同地域不同可用区之间的网络情况。 主机1在杭州可用区 B，主机2在杭州可用区 D，数据库 1 在杭州可用区 B。同一个可用区内，从主机 1 ping 数据库 1 的结果如下： 12345ping rdsxxx.mysql.rds.aliyuncs.comPING rdsxxx.mysql.rds.aliyuncs.com (100.98.xx.xxx) 56(84) bytes of data.64 bytes from 100.98.xx.xxx: icmp_seq=1 ttl=56 time=0.260 ms64 bytes from 100.98.xx.xxx: icmp_seq=2 ttl=56 time=0.472 ms64 bytes from 100.98.xx.xxx: icmp_seq=3 ttl=56 time=0.396 ms 同地域跨不同可用区，从主机 2 ping 数据库1 的结果如下： 12345ping rdsxxx.mysql.rds.aliyuncs.comPING rdsxxx.mysql.rds.aliyuncs.com (100.98.xx.xxx) 56(84) bytes of data.64 bytes from 100.98.xx.xxx: icmp_seq=1 ttl=54 time=1.63 ms64 bytes from 100.98.xx.xxx: icmp_seq=2 ttl=54 time=1.73 ms64 bytes from 100.98.xx.xxx: icmp_seq=3 ttl=54 time=1.74 ms 很明显，不同可用区之间的内网是连通的，但响应时间比同一个可用区之内要慢 1ms 多。所以，在实际应用中，如果需要考虑同城容灾或者同城双活，需要尽量将应用和数据库分布部署在不同的可用区。如果对响应时间高度敏感，则建议部署在同一个可用区内。在购买云服务器和数据库的时候，要注意选择了。 另外，目前阿里云大数据平台主要部署在杭州地域，如果业务应用的数据需要进入到阿里云大数据平台加工处理，则云服务器和数据库最好优先在杭州地域购买，以后阿里云应该会在更多地域部署大数据平台。不过悲催的是，杭州机房资源整体上比较紧张，杭州地域的云服务器时不时可能断供一小段时间。 总结这里写一下自己对「地域」和「可用区」的理解： 这两个概念都是对管理的主机的的一个区域的划分。「地域」这个划分的范围比较大，好比一个城市圈的范围。那么「可用区」这个范围可以理解为城市圈中的一个个小区。这个小区住不下了，可以去另外一个小区住。同一个地域里，可用区之间访问是方便、快捷的，所以，一个服务部署时，常常需要在同一「地域」下的不同「可用区」中都部署一下，这样一个挂了、另外一个可以撑起来，不至于服务全挂了。 补充资料 云计算之路-阿里云上：地域与可用区 云区域（region)，可用区（AZ），跨区域数据复制（Cross-region replication）与灾备（Disaster Recovery）（部分1 云区域（region)，可用区（AZ），跨区域数据复制（Cross-region replication）与灾备（Disaster Recovery）（部分2）]]></content>
      <categories>
        <category>Cloud</category>
      </categories>
      <tags>
        <tag>Cloud</tag>
        <tag>概念</tag>
        <tag>术语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用 Hexo + Github Pages 搭建博客并优化 Next 主题教程]]></title>
    <url>%2F2019%2F05%2F19%2Fhexo-blog-full-note%2F</url>
    <content type="text"><![CDATA[概述本文总结一下 Hexo 搭建博客的主要流程，能够在日后快速恢复博客环境。 Hexo 的官方文档写的已经很全面了，本文仅将一些注意点列出。 安装 Hexo 的文档参考： 官宣-Hexo 文档 前提安装 Hexo 之前，你的电脑上需要有 Node.js Git 如果是 Mac 用户， 您在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install 安装命令行工具 安装 Hexo全局安装 hexo-cli：1npm install -g hexo-cli 如果遇到权限的问题，可以使用如下命令：1sudo chown -R $(whoami) /usr/local/lib/node_modules/ 设置 /usr/local/lib/node_modules/ 文件夹属于当前用户。 此外，如果你要使用 root 权限安装的话，可以使用 sudo -s 切为 root 用户进行相关操作。这么做的话，会将一些文件夹的默认属组设置为 root 了，不推荐。 npm 权限问题： Global installs (sudo npm i -g) fail on Mac after 6.5 upgrade. Works fine after 6.4.1 downgrade npm，yarn如何查看源和换源 建站123hexo init MyBlogcd MyBlognpm install 执行完毕之后，博客其实已经 OK 了： 12hexo ghexo s 执行上面命令即可本地预览博客内容了。 部署官宣-站点配置文件 内容中介绍了很多字段的用途 Hexo 提供快速一键部署，将博客部署到 GIthub Pages。 安装 hexo-deployer-git：12$ cd MyBlog$ npm install hexo-deployer-git --save 修改站点配置文件中的配置：12345# npm install hexo-deployer-git --savedeploy:- type: git repo: git@github.com:Michael728/michael728.github.io.git branch: master 执行部署：1hexo d 常用命令hexo 常用指令 1234567hexo version # 显示hexo版本hexo new &lt;title&gt; # 创建新文章hexo g/generate # 生成静态文件hexo clean # 清除缓存文件和已生成的静态文件（public）hexo server # 启动本地服务器hexo d/deploy # 部署网站hexo list &lt;type&gt; # 列出网站资料 npm 常用指令12345678npm install 模块名 -g --save # g全局安装 save安装包信息将加入到dependencies（生产阶段的依赖）npm install gulp@3.9.1 # 指定版本npm install # 该命令可以根据dependencies配置安装所有的依赖包npm update [-g] 模块名npm outdated 模块名 # 检查模块是否过时npm ls -g # 查看全局安装的模块npm uninstall 模块名npm info hexo-cli # 查看hexo-cli模块的信息 npm常用命令 【原】npm 常用命令详解 Hexo 写作技巧 Sanarous-hexo博客Next主题进阶写作技巧 Note语法：1234567&#123;% note [class] [no-icon] %&#125;这里写你需要写的内容&#123;% endnote %&#125;// 注意上面的class和no-icon属性是可以选择的[class] : default | primary | success | info | warning | danger.[no-icon] : Disable icon in note. 示例：123&#123;% note success no-icon %&#125;success形式的类别&#123;% endnote %&#125; 效果： success形式的类别 这里使用 no-icon 表示不显示图标，可选，默认会带有图标。 使用主题自带 FontAwesome 图标源码：123- &lt;i class=&quot;fa fa-pencil&quot;&gt;&lt;/i&gt; 铅笔- &lt;i class=&quot;fa fa-cloud-upload&quot;&gt;&lt;/i&gt; 上传- &lt;i class=&quot;fa fa-download&quot;&gt;&lt;/i&gt; 下载 效果： 铅笔 上传 下载 文本居中源码：123456&#123;% cq %&#125;人生乃是一面镜子，从镜子里认识自己，我要称之为头等大事，也只是我们追求的目的！&#123;% endcq %&#125; 效果： 人生乃是一面镜子，从镜子里认识自己，我要称之为头等大事，也只是我们追求的目的！ 主题自带 label 标签首先在主题 _config.xml 配置：12# Label tag.label: true 源码：1&#123;% label primary@primary内容 %&#125; 效果：primary内容 主题自带 tabs 标签主题配置文件： 1234567# Tabs tagtabs: enable: true transition: tabs: true labels: true border_radius: 0 源码示例：1234567891011&#123;% tabs 选项卡, 2 %&#125;&lt;!-- tab --&gt;这是选项卡 1 内容&lt;!-- endtab --&gt;&lt;!-- tab --&gt;这是选项卡 2 内容&lt;!-- endtab --&gt;&lt;!-- tab --&gt;这是选项卡 3** 哇，你找到我了！φ(≧ω≦*)♪～&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 效果：选项卡 1选项卡 2选项卡 3这是选项卡 1 内容这是选项卡 2 内容这是选项卡 3* 哇，你找到我了！φ(≧ω≦)♪～ 主题自带样式按钮源码：1&#123;% btn https://www.baidu.com, 点击下载百度, download fa-lg fa-fw %&#125; 效果：点击下载百度 Hexo 其他知识图床由于一直使用的是「微博图床」，渣浪微博和简书开启了图片防盗链，请大家在博客中加入以下标签来绕过： 1&lt;meta name="referrer" content="never" /&gt; ​​​​ Next 主题只需要在 themes/next/layout/_partials/head/head.swig 中添加上面一行内容即可。 Next 主题 theme-next/hexo-theme-next 安装 Next12$ cd MyBlog$ git clone https://github.com/theme-next/hexo-theme-next themes/next Next 扩展都安装在themes/next/source/lib文件夹下 12cd MyBloggit clone https://github.com/theme-next/hexo-theme-next themes/next 启动 Next 主题编辑站点配置文件 _config.yml：1theme: next # 启用next主题 主题设置 next-开始使用 设置语言站点配置文件：1language: zh-CN # 最新版中，不再使用zh-Hans 设置菜单编辑主题配置文件： 123456789menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 菜单内容的设置格式是：item name: link || icon。其中 `item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。 设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。 icon 使用的是 fontawesome 图标，严格区分大小写。 设置头像将准备好的头像放置在主题目录下的 source/images/ 中。 12345avatar: # In theme directory (source/images): /images/avatar.gif # In site directory (source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/logo.jpg 百度统计 登录百度统计， 定位到站点的代码获取页面 复制 hm.js? 后面那串统计脚本 id，如： 编辑 主题配置文件， 修改字段 baidu_analytics 字段，值设置成你的百度统计脚本 id 阅读次数使用 LeanCloud 参考这个 为NexT主题添加文章阅读量统计功能 1234leancloud_visitors: enable: true # 启用了 valine，所以这里可以置为 false app_id: xxx app_key: xxx 设置 RSS主题配置文件中，rss 字段设为空，启用，设为 false 则不启用。启用的话，需要安装插键：1npm install hexo-generator-feed --save 添加标签页面 新建页面 hexo new page tags 设置页面类型，编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云1234title: 标签date: 2014-12-22 12:39:04type: &quot;tags&quot;--- 如果有集成评论服务，页面也会带有评论。 若需要关闭的话，请添加字段 comments 并将值设置为 false，如：12345title: 标签date: 2014-12-22 12:39:04type: &quot;tags&quot;comments: false--- 修改菜单，在菜单中添加链接。编辑 主题配置文件 ， 添加 tags 到 menu 中 标签示例：1234title: 标签测试文章tags: - Testing - Another Tag 请参阅 Hexo 的分类与标签文档，了解如何为文章添加标签或者分类 补充：12345categories:- Diarytags:- PS3- Games 分类方法的分歧如果您有过使用WordPress的经验，就很容易误解Hexo的分类方式。WordPress支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是Hexo不支持指定多个同级分类。下面的指定方法：123categories:- Diary- Life 会使分类Life成为Diary的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。 并列分类，了解一下：123categories:- [Linux]- [Tools] 并列+子分类，再了解一下：123categories:- [Linux, Hexo]- [Tools, PHP] 同样的方法，添加分类页面：1$ hexo new page categories 设置字体设置字体可参考:官宣-字体 设置代码高亮主题代码高亮预览 1234# Code Highlight theme# Available value: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night eighties 侧边栏社交链接主题配置文件：1234567social: GitHub: https://github.com/Michael728 || github 微博: https://weibo.com/1838446070/profile?topnav=1&amp;wvr=6 || weibo 博客园: https://www.cnblogs.com/michael-xiang/ || globe 知乎: https://www.zhihu.com/people/michaelXoX || globe Twitter: https://twitter.com/728_michael || twitter Telegram: https://t.me/michaelxiang || telegram 图标名称 是 Font Awesome 图标的名字（不必带 fa- 前缀）。 enable 选项用于控制是否显示图标，你可以设置成 false 来去掉图标 1234social_icons: enable: true icons_only: false transition: false 开启打赏功能只需要 主题配置文件 中填入 微信 和 支付宝 收款二维码图片地址 即可开启该功能：12345678910reward_settings: # If true, reward would be displayed in every article by default. # You can show or hide reward in a specific article throuth `reward: true | false` in Front-matter. enable: true animation: false comment: 我知道是不会有人点的，但万一有人想不开呢👇reward: wechatpay: /images/wechatpay.jpg alipay: /images/alipay.png 友情链接12345678910111213# Blog rollslinks_icon: linklinks_title: 关注列表 #Linkslinks_layout: block#links_layout: inlinelinks: #Title: http://example.com Blog List: https://michael728.github.io/2018/09/16/blog-interesting/ ZeeCoder: https://zcheng.ren/posts/ ehlxr: https://ehlxr.me/ 卡瓦邦噶: https://www.kawabangga.com/ David Dai: https://blog.stdioa.com/ 建站日志: https://michael728.github.io/2016/09/03/blog-logfile/ 站点建立时间这个时间将在站点的底部显示，例如 ©2013 - 2015。 编辑 主题配置文件，新增字段 since： 订阅微信公众号12345# Wechat Subscriberwechat_subscriber: enabled: true qcode: /uploads/wechat-qcode.jpg description: 欢迎您扫一扫上面的微信公众号，订阅我的博客！ 设置动画效果主题配置文件设置。比较在乎速度，可以关闭动画。 123456789101112131415161718# Use velocity to animate everything.motion: enable: true async: false transition: # Transition variants: # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut # swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut # bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut # slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut # slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut # perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut post_block: fadeIn post_header: slideDownIn post_body: slideDownIn coll_header: slideLeftIn # Only for Pisces | Gemini. sidebar: slideUpIn 设置背景动画编辑 主题配置文件， 搜索 canvas_nest 或 three_waves，根据您的需求设置值为 true 或者 false 即可 我只启用了 canvas_nest 12canvas_nest: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1.0.0/canvas-nest.min.jscanvas_nest_nomobile: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest-nomobile.min.js 搜索–Local Search1$ npm install hexo-generator-searchdb --save 站点配置文件，新增如下内容：12345search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件，启用本地搜索：123# Local searchlocal_search: enable: true 不蒜子统计编辑 主题配置文件 中的 busuanzi_count 的配置项：123456789busuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye # 文章阅读次数，关闭，避免与leanclound_visitors冲突 post_views: false post_views_icon: eye fancybox fancyBox is a tool that offers a nice and elegant way to add zooming functionality for images, html content and multi-media on your webpages 检查_config.yml 中是否开启了 fancybox 找到 vendors，把 fancybox 和 fancybox_css 设置成推荐值 参考： 文章里面的图片点击没有反应，也没有放大效果 [solved] 内容分享theme-next-needmoreshare2：12cd themes/nextgit clone https://github.com/theme-next/theme-next-needmoreshare2 source/lib/needsharebutton 主题配置文件配置：12345678910111213141516needmoreshare2: enable: true postbottom: enable: true options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook float: enable: false options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook 评论Next 评论配置很简单，支持很丰富。 front matter 中设置 comments: false，当前页就不会显示评论框了。 Disqus 评论启用，但是得网络畅通才能看到：1234disqus: enable: true shortname: xxx count: true 编辑 主题配置文件， 将 disqus 下的 enable 设定为 true，同时提供您的 shortname。count 用于指定是否显示评论数量 ValineValine这个评论系统也是用到了 leancloud 点击登录或注册Leancloud; 创建应用(如果已经创建了博客应用，就不用再创建了) 获取 APP ID 和 APP KEY: 刚刚创建的应用 &gt; 设置 &gt; 应用 KEY 1234567891011valine: enable: false # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version. appid: xxx # your leancloud application appid appkey: xxx # your leancloud application appkey notify: true # mail notifier , https://github.com/xCss/Valine/wiki https://valine.js.org/notify.html verify: true # Verification code placeholder: ヾﾉ≧∀≦)o来啊，快活啊! # comment box placeholder avatar: identicon # wavatar retro gravatar style https://github.com/xCss/Valine/wiki/avatar-setting-for-valine guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: true # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&apos; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html visitor 文章访问量统计。 recordIP，默认是 fasle，是否记录评论者IP valine 配置项查看 头像设置，可以用你对应的邮箱设置 Gravatar，这样你评论时，就是注册时使用的邮箱了。 邮件提醒，进入Leancloud&gt;选择你的评论所存放的应用&gt;设置&gt;邮件模板，按下图设置好用于重置密码的邮件主题&gt;然后保存:12345&lt;p&gt;Hi, &#123;&#123;username&#125;&#125;&lt;/p&gt;&lt;p&gt;你在 &#123;&#123;appname&#125;&#125; 的评论收到了新的回复，请点击查看：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://michael728.github.io/&quot; style=&quot;display: inline-block; padding: 10px 20px; border-radius: 4px; background-color: #3090e4; color: #fff; text-decoration: none;&quot;&gt;马上查看&lt;/a&gt;&lt;/p&gt; 参考： valine-admin 在 NexT 中使用 Valine 评论系统 hexo next 新增阅读排行页面参考这两个教程： hexo next 新增阅读排行页面 打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化 在 NexT 中使用 Valine 评论系统 在Hexo博客中加入豆瓣读书页面hexo-douban 可以实现生成豆瓣读书、电影、游戏的页面。具体的使用方法可以看项目的主页或者这篇文章 在Hexo博客中加入豆瓣读书页面 1hexo clean &amp;&amp; hexo douban -bm &amp;&amp; hexo g &amp;&amp;hexo deploy 看板娘 EYHN/hexo-helper-live2d Hexo 博客照着配置就行 live2d-看板娘预览 用Live2D让看板喵入住你的Hexo博客吧(^o^)/~ 给博客添加能动的看板娘(Live2D)-关于模型的二三事 Hexo 博客看板娘配置进阶 博客园添加Live2d看板娘 博客园增加看板娘 SEO 优化 Hexo博客Next主题SEO优化方法 Hexo-Next搭建个人博客（SEO优化） Hexo+Next主题搭建博客安装美化及SEO优化指南 最后博客建完的地址：https://michael728.github.io/ 参考 hexo：（三）hexo Next 主题下载和配置 打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化 手摸手教你用github和hexo搭建个人博客（五） hexo的next主题个性化配置教程 NexT 主题的扩展以及设置 Sanarous-使用Hexo+Next主题搭建自己的个人博客]]></content>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】程序员的核心能力]]></title>
    <url>%2F2019%2F05%2F11%2Fthink-core-skill-programmer%2F</url>
    <content type="text"><![CDATA[原文链接：程序员的核心能力 阅读博客时发现的这篇文章，觉得说的挺有道理，转载一下。自己近期也感觉到了一些焦虑感，觉得太多东西要学了，各个技术公众号、论坛，传递出来的这些东西，都让人感觉焦虑！一直在大容量的「被灌输」，自己的主动思考却少之又少，这必然不是成长的长久之道！ 程序员要掌握的知识，要具备的能力实在太多，多得头发都不够掉。 大体有两大方向。一是对工具的熟练掌握，如操作系统、网络、IO、编程语言等；另一个是用代码为现实问题生成解决方案的能力，这其中最重要的是抽象能力。 前一个方向是很容易意识到的，很多现象可以说明这一点，比如，世面上介绍如何使用语言、框架的书汗牛充栋；比如，很多人眼里进这一行的门槛是上1个月的语言培训课。 工具的意义不容否认，为此我还写过一篇《工具优先》。但工具的生命周期其实很短，从个人发展角度看，把过多时间投入到半衰期很短的事物上，并不划算。我入门时接触的是Pascal, BasicScript, ASP, IIS，不知道现在还有没有人用这些。很多程序员也赶时髦，本来写java的，golang流行了，python流行了，学！本来搞业务开发的，大数据火了，机器学习火了，学！打的旗号自然很鲜明：持续学习。几次之后，却怅然若失，貌似没一个是拿得出手的，不过是低水平重复，换个工具，继续做原来的事而已。充其量效率提高了，但效率型工作是可替代性最强的，被其它人替代，被机器替代。 一颗上进爱学习的心，怎么就被辜负了呢？因为核心能力没有提升。人的能力好比电子围绕原子核旋转，大部分情况下处于巡航状态，在这过程中不断积蓄能量，始终向核心方向用力，就会跃迁到更高级轨道（这里指更靠近核心的轨道，实际电子是更远离核心的道）。“一万小时理论”和“10万行代码理论”只片面强调了量，如果没有聚焦核心，刻意练习，只能是低水平重复，甚至轨道降级。 核心是抽象能力。这个世界的运行，有讲逻辑的，也有不讲逻辑的。程序员要处理的事是讲逻辑的那部分，因为你所依赖的计算机是讲逻辑的，要让它意气用事，感情用情，目前还很困难。通过抽象，我们识别并保留逻辑部分，抛弃其它内容，然后用计算机语言翻译、实现这个逻辑，进而解决问题。 抽象这个词，本身就挺抽象的。到底什么是抽象？ 抽象是去除多余和细节。比如下面这个标志，一看就懂是座拱桥，但并没有显示拱桥的幅度、宽度和长度，因为这些数据对于你意识到这是一座拱桥并没有帮助。 什么是多余信息，取决于目的。考虑地铁换乘图，其目的是告诉乘客该搭哪条线，在哪里换乘，所以保留了结构关系：站点的分布，以及线路的汇合点，但忽略了物理关系：站点的地理位置、相对距离，甚至扭曲了线路的方向。而如果是开车用的导航图，则必须保证比例尺和实际情况一致，方向也不能有差错，以免误导。 抽象是建立模板或蓝图。不少公司里有邮件模板、文档模板、PPT模板、报销单模板，等等，它们规定好了结构、风格，并留出一个个空白，使用的时候填空就好。模板描述不变的内容，变量则延迟到使用场景中确定。Java编程时，经常要应用各种设计模式，其实质是通过抽象，固化不变的，封装变化的。比如，很常用的模板方法，流程和步骤无论什么场景都不变，已经在父类写好了，将具体场景的方法在父类里声明，但延迟到子类实现，封装的是方法实现。又比如，创建对象时，不常写new Tesla()，而是运用简单工厂模式，写成TeslaFactory.create()，因为对象的创建是易变的。与其在特斯拉多一个型号时，把所有new的地方都改一遍，不如在create方法里集中改。 总之，抽象是应对变化，或者说寻找不变性的手段。既可以是不同事物之间的不变性，也可以是同一事物不同历史时间的不变性。虽然这里讲的是编程，但其应用远不止于此，看看贝索斯是怎么说的： 我常被问一个问题：“在接下来的10年里，会有什么样的变化?”……但我很少被问到“在接下来的10年里，什么是不变的?”我认为第二个问题比第一个问题更加重要，因为你需要将你的战略建立在不变的事物上。 有了上面的解释，便不难理解面向对象编程的原则：依赖接口而不是实现，依赖抽象类而不是具体类。它让代码的适应性更强，将来少改代码，少出错。同时，做一些参数设定时，更加有理有据，而不是trial and error。线程池大小怎么定？不用关心具体工作，分析阻塞和非阻塞的时间比例，应用Amdahl’s law搞定。队列大小怎么定？不管究竟放的是什么，确定你期望的排队时长，用Little’s law算下。 世面上鲜有讲如何培养抽象思维的书，设计模式一类的，算搭一点边，但那是人家抽象的结果，而不是关于抽象的方法。也许我们在运用这些模式，或浏览一些工具和类库的代码过程中，偶有灵光一现，能从这些结果中反推作者的设计思想和精妙之处，毕竟它们也是抽象的结果。 学习使用工具时，如果多个心眼，留意为什么有这个工具，做了什么取舍，工具于你将不仅是效率意义。做业务开发时，如果不是简单地翻译需求，多想一层，哪里易变，哪里不易变，如何隔离变化，再简单的开发，于你也有精进意义。 抽象的层级可以有很多，能做多少层级的抽象是一种能力，而判断需要多少层级的抽象则是一种艺术。 地上一个猴，树上七个猴，一共有几个猴？1+7=8，一共八个猴，用数字符号代替猴子，这是第一层。从对象到数字，大多数人对此熟悉到甚至没有意识到这是一种抽象。再进一层，则有些困难了，当初我理解“加速度”这个概念，就费功。不光是数量，还有结构的抽象，关系的抽象。当然，它们离我们都很远…… 可是，真的很远吗？当大部分人在关心如何写程序时，有人开始研究如何用程序写程序，当大部分人在关心如何看书、学习时，有人在教别人看书、学习。]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyCharm/IDEA 使用技巧总结]]></title>
    <url>%2F2019%2F05%2F11%2Ftools-dev-pycharm-idea%2F</url>
    <content type="text"><![CDATA[工欲善其事必先利其器 基本概念IDEA 没有类似 Eclipse 的工作空间的概念（workspace），最大单元就是 Project。这里可以把 Project 理解为 Eclipse 中的 workspace。Module 可以理解为 Eclipse 中的 project。一个 工程（Project） 下可以创建多个 模块（Moudle）。 src 目录，用于存放代码 .idea 目录和 project01.iml 文件都是 IDEA 工程特有的。 删除 module ，这样不会删除代码文件，只是从 Project 中移除组织关系，如下图：系统设置 设置Tab为4个空格不要勾选Use Tab character 设置显示收藏栏等工具栏 支持滚轮调节字体大小 鼠标滑过，显示文档 设置换行符默认为LFEditor-&gt;Code Style 页面不仅能设置换行符，还可以设置 wrap columns。 参考： IntelliJ换行CRLF, LF, CR的解释和默认设置 设置 File EncodingsSettings-&gt;Editor-&gt;File Encodings，编码全都设为 UTF-8。 设置显示空格「游标卡尺」的名号不是白叫的，所以，必须设置显示空格、缩进等，可以在 Settings-&gt;Editor-&gt;General-&gt;Apperance中设置显示空格、行号、CSS颜色、方法分隔符等效果。 1ctrl+alt+s #输入whitespace，搜索相关设置，打开 舒服的pycharm设置 设置头信息Settings-&gt;Editor-&gt;File and Code Templates-Files-&gt;Includes-&gt;File Header 设置如下模板： Python 头信息设置：123456#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : $&#123;DATE&#125; $&#123;TIME&#125;# @Author : Michael# @File : $&#123;NAME&#125;.py# @Software: $&#123;PRODUCT_NAME&#125; Java 头信息设置：123456/** * Description: * User: $&#123;USER&#125; * Date: $&#123;YEAR&#125;-$&#123;MONTH&#125;-$&#123;DAY&#125; * Time: $&#123;TIME&#125; */ PyCharm创建.py自动添加文件头注释 IntelliJ IDEA文件头注释模板 自动编译有时候我们需要操作 class 文件时，却忘记了对 java 类文件进行编译，从而还是对旧的文件进行了操作。 打开内存使用状态1settings—Appearance &amp; Behavior—Appearance—Show memory indicator 参考： 玄玉-idea配置小结 博主介绍的很详细 import每个类而非整个包1settings—Editor—Colors Style—Java—Imports—Class count to use import with ‘*’ 设置大一点 当 Java 类中 import 某个包下的类超过这里设置的个数，就会换成用星号来代替，比如 import java.util.* 版本控制下文件变化的显示1settings—Version Control—Show directories with changed descendants 开启后若想调整文件夹的显示颜色：settings—Version Control—File Status Color 省电模式在菜单栏 File 下面有一个选项是 Power Save Mode，这个叫「省电模式」，如果不小心勾选了这个选项，那么会关掉代码检查和代码提示等功能，所以需要注意。 给提示时忽略大小写Java 是严格区分大小写的，未设置时，输入 str 时，它不会提示 String，要想实现忽略大小写的情况它也能智能提示，可以进行如下设置，而且，这样设置它也不是完全按照首字母进行匹配了，比如你输入 hmap 时，也会看到 HashMap 的智能提示，相当方便： 自定义 Terminalsettings-&gt;Tools-&gt;Terminal Shell path 原来的值是: C:\Windows\System32\cmd.exe Windows 修改为： C:\Program Files\Git\bin\bash.exe 修改为 Git bash 的终端； &quot;C:\Windows\System32\cmd.exe&quot; /k &quot;&quot;%CMDER_ROOT%\vendor\init.bat&quot;&quot; 修改为 Cmder 的终端，这种方式就会弹出 Cmder 的窗口，需要配置系统变量 CMDER_ROOT，值为：D:\Green-SF\cmder。 参考： Pycharm官宣-Terminal Github-Run cmder inside IntelliJ idea Windows 上切换 Jetbrains IDE 的 terminal 为 PowerShell 或 cmder 脚本运行结束后留在命令行这样脚本运行中的变量在脚本结束后还可以调用，调试时还是挺好用 pycharm常用设置和技巧 设置Tab标签页File-&gt;Editor-&gt;General-&gt;EditorTable-&gt;Tab closing Policy-&gt;Tab limit 在 Windows-&gt;Editor Tabs 可以设置标签页的相关内容，比如： Tabs Placement 放置位置，我勾选了 Right、Show tab in single row 勾选了 Sort Tabs By Filename 勾选了 Open New Tabs At The End 我设置最多打开标签页10个，同时将位置移到了右边，通过alt+←/→可以切换工作区。默认是10，即最多打开十个窗口，再打开新的就会把之前的窗口T掉！ IntelliJ IDEA设置打开窗口的数量 自动导包 import popupEditor-&gt;General-&gt;Auto Import-&gt;Python-&gt;Show import popup 主题 IDEA主题- Dracula 关联数据库 生成 JavaDOCJavadoc用于描述类或者方法的作用，具体介绍，可查看CSDN-Javadoc 使用详解 12Locale：输入语言类型：zh_CNOther command line arguments：-encoding UTF-8 -charset UTF-8 缓存和索引的清理IDEA 首次加载项目时，都会创建索引。创建索引的过程，暂时不要去编辑代码，避免遇到未知问题。有时候意外断电或蓝屏，出现索引损坏情况，可以清除缓存和索引，还原成默认状态。 File-Invalidate Caches 这个会将本地修改历史也会清理掉，如果想要将这个数据保留，LocalHistory 需要提前备份：1234# system 目录，系统文件目录，是 IDEA 与开发项目一个桥梁目录，里边主要有缓存、索引、容器文件输出等等/Users/michael/Library/Caches/IntelliJIdea2018.2/LocalHistory# 顺带看一下 config 目录，是 IDEA 个性化设置目录，是整个 IDE 设置目录/Users/michael/Library/Preferences/IntelliJIdea2018.2 参考： Where is IntelliJ IDEA config stored in OSX? 官宣-Directories used by the IDE to store settings, caches, plugins and logs 取消更新取消 IDEA 自动更新，避免引入不稳定的问题： 快捷键Mac 的 Command 键一般是对应了 Win 的 Ctrl 键，在 Win 上，还可以用 Alt+&lt;n&gt; 打开相关窗口，在 Mac 上同样要使用 Command+&lt;n&gt;。 除此以外，还可以在 Settings-Keymap 中，设置快捷键、输入快捷键查看对应的功能； 快捷键设置 alt+r：打开最近项目 ctrl+shift+o：打开项目 自动补全快捷键，默认是 ctrl+空格，这个和一些中文输入法的切换快捷键冲突了，于是，我多设置了一个 ctrl+/ ： 模板系统内置的：postfix completion自定义：live templete psvm 再按 Tab 生成 main 方法，或者，输入 main 之后，再按 ctrl+j sout 输出函数 soutp 打印函数的形参 soutv 打印变量值 xxx.out 打印变量 xxx 的值 fori 循环 iter 增强 for 循环（for each） list.for list.fori list.forr 逆序遍历 ifn 条件判断 inn 不等于 null prsf 私有的静态的常量 快捷键 ctrl+j 可以查看有哪些缩写字符。 更多关于模板的知识，点击官宣-live templates 参考： IntelliJ 创建main函数快捷 常用快捷键查看继承关系重构 修改变量名和方法名大小写切换，常量通常定义为都是大写构造器 alt+↑/↓: 快速在方法间跳转 ★★ alt+p：打开Python控制台 ★★★ alt+enter万能键，不同场景有不同的表现方式，在还没import(install)模块名上使用会import(install)相对应的模块，在方法名上使用补注释，在测试中使用帮你补充断言代码……不管出错了不知道怎么办，知道怎么办想这么办时都按下这个快捷键，有惊喜，万能纠错键 ★★★ alt+f12 打开命令行终端(view-&gt;tool window)★★★； ctrl+home、ctrl+end 回到页首/页尾，关键字Move Caret to Text End 或者 开头 Move Caret to Text Start，参考 ctrl+n 构造器、getter、setter 方法 ★★★ 查看接口继承关系： ctrl + h 查看 hierarchy,只能查看向上向下继承关系，而不能看实现了哪些接口。查看继承关系，右击，点击 Digram 查看； ctrl + alt +B 查找接口的实现类 ctrl+e 打开最近文件 ★★★ ctrl+y 删除当前行 ★★★ ctrl+w 不断按下这个快捷键，选择代码块范围逐步扩大；★★★ ctrl+alt+←/→ 快速跳转光标刚刚所在行 ★★★ ctrl+alt+L，格式化代码 ctrl+space 万能提示键 shift+enter另起一行，光标在行内任意位置都能另起一行，且不破坏当行结构★★★ ctrl+alt+enter向上另起一行 ★★★ ctrl+F4：关闭当前页 ★★ crtl+q查询documentation ctrl+鼠标点击 查看内置函数啥的 ctrl+D 复制当前行 ctrl+f12 File Structure，查看 class method field。 ctrl+Shift+F: 在整个项目中 或 指定目录里 进行全局搜索; ★★★ ctrl+shift+a：Find Action 快捷键，输入关键词，不会的就问它，超级赞的快捷键 ★★★ ctrl+shift+u：大小写转换，在 Edit-&gt;Toggle Case 中能看到选项 ctrl+shift+v：从最近的缓冲区粘贴 ctrl+shift+backspace 快速跳转到最后修改的地方★★★ ctrl + shift + v 在 Pycharm 中，访问历史粘贴板 ★★ ctrl+shift+ +/- ：代码块折叠★ ctrl+alt+shit+j：多目标选择选择的词，或者用alt+鼠标点击也可以实现效果，Select All occurrences★★ 双击shift搜索一切，不管是IDE功能、文件、方法、变量，它都能搜索，使用频率很高的一个快捷键,！可以按最近使用过的文件名, 类名, 方法名等去搜索定位! 注意，这个搜索不支持搜索关键字的内容。★★★ shift+F6：文件重命名★★ shift+F2：跳转到上一个高亮错误 或 警告位置 搜索 Ctrl＋N：快速搜索类 Ctrl＋Shift＋N：快速搜索文件 Ctrl＋Alt+Shift＋N：快速搜索函数 参考： 极客学院-IntelliJ IDEA 使用教程-快捷键 alt+enter 快捷键的妙用创建对象时，可以先 new 后alter+enter，IDEA 会自动补全，直接让你输入对象名： 重构 Shift+F6 重命名所有的文件，类名，函数名，属性名都可以重命名，值得点赞的是，只要你使用 Shift+F6 重命名，所有使用过这个名称的地方都会跟着改变； 函数的重构，Ctrl+F6 重构函数当你需要重构方法时，无论是增加参数，修改返回值，还是更改函数实现，只需要Ctrl+F6，就可以把所有用到此函数的地方一起重构 参考： 你们都在用IntelliJ IDEA吗？或许你们需要看一下这篇博文版本控制 调试技巧 step over F8 下一步，当前断点如果是一个方法，不会进入方法体内； step into F7 下一步，当前断点如果是一个方法，则进入方法体内； force step into Alt+Shift+F7 下一步，当前行如果是一个方法，强制进入方法体内； step out Shift+F8 跳出 run to curser Alt+F9 运行到鼠标所在行，临时设置断点，有用 resume program F9 恢复程序运行，运行到下一个断点处，是不是有点像 pdb 中的 c 快捷键； stop Command+F2 停止 view breakpoints 查看所有断点，可以在运行时选择哪些断点暂停略过； mute breakpoints 所有断点失效/生效的切换； 条件断点在循环里增加条件判断，具体操作：在断点处右击，在某个条件下，实施断点。 查看表达式的值（可以查看已有变量的值）： 调用栈ctrl+alt+h 快捷键 参考： IDEA的查询引用、调用关系图的功能 Intellij IDEA神器常用技巧八-2018版本新增快捷键 挖掘IntelliJ IDEA的调试功能 查看类的继承关系 IDEA查看接口或类的继承实现关系图 IntelliJ IDEA 中如何查看一个类的所有继承关系(当前类的所有继承关系图) 高效定位代码-无处不在的跳转project之间跳转ctrl+alt+左右方括号： 查看快捷键ctrl+shift+a：搜搜快捷键 查看最近文件ctrl+e可以在ctrl+shift+a：搜索reccent … 快速跳转到最后修改的地方ctrl+shift+backspace 快速跳转到最后修改的地方 利用书签跳转 F11：添加、取消书签 ctrl+f11：添加、取消有标记的书签 ctrl+&lt;n&gt;：跳转到有标记的书签处 添加收藏 Favoritesalt+shift+f：add to favorities 编辑区和文件区的跳转alt+1进入文件区esc：进入编辑区 精准搜索类搜索ctrl+n：快速搜索类 文件搜索快速打开指定的文件，方便★★★：ctrl+shift+n 函数搜索-symbolctrl+shift+alt+n 搜索 Maven 依赖包中的内容有时候可能需要在源码分析时想要搜索 Maven 依赖包中的内容，只要如下设置即可扩大搜索范围： ctrl+shift+f -&gt;scope-&gt;All Places 列操作 选中单词转大写 多光标选中 多光标 按住 Alt 键，可以快速实现多光标、块选择。 界面中的基本功能如果没有如老师那样的窗口，可点击view——tool buttons打开 alt+&lt;n&gt;快捷键 ★★★如下图圈出的数字 n，可以使用alt+&lt;n&gt;的方式快捷使用，替代鼠标操作。 注意，Mac 使用的是 command+&lt;n&gt;方式； 打开收藏 ★★★在一些调试的函数那里打断点，然后alt+7收藏中就会方便的查看； TODO在项目中使用# TODO，可以在Alt+6中看到哪些待开发的备注 调试技巧设置程序环境变量Run-&gt;Edit Configurations-&gt;Environment-&gt;Environment variables 1System.getenv(&quot;HOME_TEST&quot;); 必备插件官网插键库：https://plugins.jetbrains.com/ 插键说明： Install JetBrains plugin：弹出IntelliJ IDEA 公司自行开发的插件仓库列表，供下载安装。 Browse repositories：弹出插键仓库中所有插键列表供下载安装。 Install plugin from disk：浏览本地的插键文件进行安装。 推荐插键： BashSupport Dash: ctrl+shift+h Key Promoter X 快捷键提示 Statistic 代码统计 CheckStyle-IDEA 代码样式检查 Lombok plugin FindBugs-IDEA 代码 Bug 检查 Mongo Material Theme 主题插键 CamelCase 将不是驼峰格式的名称，快速转成驼峰格式，安装好后，选中要修改的名称，按快捷键 shift+alt+u。 Rainbow Brackets 彩虹括号 Alibaba Java Coding Guidelines Maven Helper：安装之后，直接打开pom文件，即可查看依赖数，还能自动分析是否存在 jar 包冲突，查看idea 中解决maven 包冲突的问题 String Manipulation：字符串转换工具，安装好插件后，选中需要处理的内容后，按快捷键 Alt+m，即可弹出工具功能列表 AceJump：允许您快速将光标导航到编辑器中可见的任何位置，只需点击ctrl +;，然后输入一个你想要跳转到的字符，之后键入匹配的字符就跳转到你想要挑战的地方了 activate-power-mode：写代码的时候，就会附加一些狂拽炫酷屌炸天的效果 参考 hollis-IntelliJ IDEA 18 周岁，吐血推进珍藏已久的必装插件 FAQQ1: intellj Idea中给新建的项目导入jar包？ 推荐intellij idea Project Structure 讲解 Q2: IDEA如何快速生成Get/Set方法？ Intellij IDEA 生成Get/Set方法快捷键 Alt + Insert 组合，可唤出选择面板 Q3: 找不到提示 IntelliJ cannot find any declarations 最后近期由于微博图床挂了，所以，截图都看不了了，点击原文链接，可查看图片： PyCharm/IDEA 使用技巧总结 参考 IntelliJ IDEA 使用教程 简书-IntelliJ IDEA 教程 技巧篇 作者写了一系列的总结 你有哪些想要分享的 PyCharm 使用技巧？ IntelliJ IDEA神器使用技巧 Java人员正确使用 IntelliJ IDEA的方式 挖掘IntelliJ IDEA的调试功能 IDEA 注册-lanyu Github-judasn/IntelliJ-IDEA-Tutorial]]></content>
      <categories>
        <category>ToolsDev</category>
      </categories>
      <tags>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shadowsocks+vps+mac]]></title>
    <url>%2F2019%2F04%2F27%2Ftools-ss-vps%2F</url>
    <content type="text"><![CDATA[Vultr 选择的是日本的节点，发现速度比较不错，油管视频 720P 无压力！而且，感觉 Vultr 的界面也很清新，用着很方便。 我自搭梯子，选择的是：Shadowsocks-libev+开启simple-obs插键+BBR加速。 Vultr 通过我的链接注册充值，你我都可以获得 $10 账户返利，所以，如果有需要，就点击注册吧： Vultr 注册返利链接 VPSvultr速度比较： vultr-downloadspeedtests vultr中文网 一键安装脚本 秋水逸冰 Shadowsocks 一键安装脚本（四合一） 秋水逸冰 一键脚本搭建SS/搭建SSR服务并开启BBR加速 Vultr中文网-Vultr 一键搭建酸酸 Shad0ws0cks 图文教程（推荐） 123wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.shchmod +x shadowsocks-all.sh./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log Docker方式 docker文档 docker-ss-搜索结果 加速配置：我选用的 BBR 加速的方式 BBR 安装： 1wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh 锐速安装，参考锐速破解版linux一键自动安装包： 1wget -N --no-check-certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh &amp;&amp; bash serverspeeder.sh 客户端 Shadowsocks各种客户端 Mac 客户端下载 ShadowsocksX-NG-R/releases ShadowsocksX-NG/releases NG 客户端插键配置 插键选项： 1obfs=http;obfs-host=www.bing.com Android shadowsocks/shadowsocks-android 插键-shadowsocks/simple-obfs-android 服务端命令启动脚本后面的参数含义，从左至右依次为：启动，停止，重启，查看状态。 Shadowsocks-Python 版：/etc/init.d/shadowsocks-python start | stop | restart | status ShadowsocksR 版：/etc/init.d/shadowsocks-r start | stop | restart | status Shadowsocks-Go 版：/etc/init.d/shadowsocks-go start | stop | restart | status Shadowsocks-libev 版：/etc/init.d/shadowsocks-libev start | stop | restart | status 配置文件：1234567891011Shadowsocks-Python 版：/etc/shadowsocks-python/config.jsonShadowsocksR 版：/etc/shadowsocks-r/config.jsonShadowsocks-Go 版：/etc/shadowsocks-go/config.jsonShadowsocks-libev 版：/etc/shadowsocks-libev/config.json 参考 聪聪-SS/SSR 简介 写给非专业人士看的 Shadowsocks 简介 VPS+ShadowsocksR 搭建自己的 VPN]]></content>
      <categories>
        <category>ToolsDaily</category>
      </categories>
      <tags>
        <tag>ss</tag>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux lvm 分区知识笔记]]></title>
    <url>%2F2019%2F04%2F23%2Flinux-lvm-partion%2F</url>
    <content type="text"><![CDATA[盘面上可以细分出扇区（Sector）与柱面（Cylinder)两种单位，其中扇区每个为512bytes那么大。 通常所说的”硬盘分区”就是指修改磁盘分区表，它定义了”第n个磁盘块是从第 x个柱面到第y个柱面”.因此，当系统要读取第n个磁盘块时，就是去读硬盘上第x个柱面到第y个柱面的信息. 整块磁盘的第一个扇区特别重要，因为它记录了整块磁盘的重要信息： 主引导分区（Master Boot Record, MBR）：可以安装引导加载程序的地方，有446bytes. 分区表（partition table）：记录整块磁盘分区的状态，有64bytes。 磁盘分区表（partion table）在分区表所在的64bytes容量中，总共分为四组记录区。每组记录区记录了该区段的起始与结束的柱面号码。 其实所谓的分区只是针对那个64bytes的分区表进行设置而已。 硬盘默认的分区表仅能写入四组分区信息 四组分区信息我们称为主（Primary）或者扩展（Extended）分区。 分区最小单位为柱面（cylinder）。 分区的优点： 数据安全 有助于数据读取的速度和性能 扩展分区的目的是使用额外的扇区记录分区信息，扩展分区本身并不能拿来格式化。由扩展分区切出来的分区，就被称为逻辑分区（logical partition）。逻辑分区的设备名称号码由5号开始。 主分区、扩展分区和逻辑分区的定义： 主分区与扩展分区最多可以有4个（磁盘限制） 扩展分区最多只有1个（操作系统限制） 逻辑分区是由扩展分区持续切割出来的分区 能够被格式化后作为数据访问的分区为主分区与逻辑分区，扩展分区无法格式化。 逻辑分区的个数依操作系统而不同，SATA硬盘则有11个逻辑分区（5号到15号）。 分区是个很麻烦的东西，因为它是以柱面为单位的“连续”磁盘空间，且扩展分区又是类似独立的磁盘空间。 扩展分区是不能直接用的，他是以逻辑分区的方式来使用的，所以说扩展分区可分成若干逻辑分区。 他们的关系是包含的关系，所有的逻辑分区都是扩展分区的一部分。 磁盘分区LVM卷管理123456789disk=/dev/vdbpvcreate $disk # 磁盘还没有分主分区或者扩展分区，就可以直接创建物理卷（Physical volume (PV) ）了，物理卷的名字就是磁盘的名字/分区的名字vgcreate ci-vg $disk # 创建卷组Volume group (VG)，卷组名为 ci-vg1lvcreate -L 100G -n app_data ci-vg # or lvcreate -L 100G --name app_data ci-vg，将ci-vg 卷组中的 100G 空间划分为逻辑卷Logical volume (LV)，逻辑卷名为 app_data# lvcreate -l +100%FREE -n app_data ci-vg 将卷组百分百的空间都划分给 app_data 这个逻辑卷lvdisplay # 查看逻辑卷路径mkfs.ext3 /dev/ci-vg/app_data # 格式化mount /dev/ci-vg/app_data /data # 挂载，前提是要有 /data 目录df -Th # 查看 接着，为了开机自动挂载，执行： 1echo "mount /dev/ci-vg/apkg /apkg" &gt;&gt; /etc/rc.d/rc.local 这个命令在有些情况不会生效，开机自启挂载磁盘，稳妥的方式推荐编辑 /etc/fstab 文件：1/dev/ci-vg/app_data /data ext3 defaults 0 0 分区常用命令 lsblk：查看磁盘分区情况 ★★★ vgdisplay: 查看卷组信息 vgs： 查看卷组信息，简略 fdisk -l：查看系统内分区信息 扩容1234pvcreate /dev/vdc # 新增磁盘vdc，创建为物理卷vgextend ci-vg1 /dev/vdc # 将新增的物理卷添加到已有的逻辑卷组中lvextend -l +100%FREE /dev/ci-vg/data_app # # 用 lvextend 将 /dev/ci-vg1/apkg 所在卷组所有剩余空间都分配给了它resize2fs /dev/ci-vg/data_app # # 磁盘格式是 ext2 ext3 ext4 使用 resize2fs， xfs使用 xfs_growfs 对扩容后的 LV 格式大小调整 扩容参考 手把手教你给 CentOS 7 添加硬盘及扩容(LVM) Linux LVM分区之VG扩容、LV扩容、LV缩减、LVM快照 Linux LVM 动态扩容（在线） FAQQ1：发现开机启动时，rc.local没有自启动执行尝试了chmod +x /etc/rc.d/rc.local之后，问题依旧，排除了权限的问题。编辑rc.local文件，在touch /var/locak/subsys/local下一行，加上sleep 10，问题解决。 Q2: -bash: pvcreate: command not found通过yum install lvm2安装，支持命令。 参考 LVM (简体中文)) Linx卷管理详解 Linux逻辑卷详解总结 Linux 磁盘和分区 Linux LVM简明教程 开机挂载 CentOS 6.3开机自动挂载磁盘和文件夹 fstab 文件格式介绍]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>分区</tag>
        <tag>lvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-玩转Spring全家桶]]></title>
    <url>%2F2019%2F04%2F18%2Fnote-spring%2F</url>
    <content type="text"><![CDATA[trends.embed.renderExploreWidget("TIMESERIES", {"comparisonItem":[{"keyword":"spring","geo":"US","time":"today 12-m"},{"keyword":"springboot","geo":"US","time":"today 12-m"},{"keyword":"ejb","geo":"US","time":"today 12-m"}],"category":0,"property":""}, {"exploreQuery":"geo=US&q=spring,springboot,ejb&date=today 12-m,today 12-m,today 12-m","guestPath":"https://trends.google.com:443/trends/embed/"});]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作中常用的 Shell 命令及技巧]]></title>
    <url>%2F2019%2F04%2F14%2Flinux-useful-shell-commands-in-work%2F</url>
    <content type="text"><![CDATA[调试 bash 脚本的技巧 加 -x 参数运行 bash 脚本时，会显示执行的语句 12# 也可以在 demo.sh 中加上 set -xbash -x demo.sh 设置环境变量，然后通过如上方式运行脚本时，会显示行号 1export PS4='+$&#123;BASH_SOURCE&#125;:$&#123;LINENO&#125;:$&#123;FUNCNAME[0]&#125;: ' 参考 [耗子叔-如何调试BASH脚本](https://coolshell.cn/articles/1379.html/comment-page-1#comment-1965637 快速输入历史命令输入关键词之后，连续使用ctrl+r快速切换 In reverse-i-search (Ctrl+R ) ,Any method to switch between similar commands in history linux – 在反向搜索(Ctrl R),任何在历史记录中类似命令之间切换的方法 Ctrl+p/n 向上/向下 显示缓存命令 Ubuntu终端常用的快捷键 ssh远程执行命令需要远程到其他节点上执行一些 shell 命令，示例： 123456789#! /bin/shset -xssh root@192.168.3.43 &gt; /dev/null 2&gt;&amp;1 &lt;&lt; EOFcd /tmptouch test.txtexitEOFecho done 参考： 简书-【ssh】ssh远程执行命令 for循环123456789101112131415echo "Start Datetime:" $(date +"%Y-%m-%d %H:%M:%S")for i in &#123;1..3&#125;do echo $i git pull --all if [ $? -ne 0 ] then echo "不成功" # 睡眠2s sleep 2 else break fidoneecho "End Datetime:" $(date +"%Y-%m-%d %H:%M:%S") 参考： Linux下Shell的for循环语句 Shell脚本中的分号使用 if 判断判读字符串($str)是否包含另一个字符串($str1)： 方法1：123if [ `echo $str | grep -e '$str1'` ] ; then echo yesfi 方法2(如果$str1在判断中直接使用字符串而不是变量，则不能加引号，如if [[ $str =~ ^dx ]]判读字符串$str是否以dx开头，^dx不能加引号)：123if [[ $str =~ $str1 ]] ; then echo yesfi 比较两个字符串是否相等的办法是：1if [ "$test"x = "test"x ]; then 这里的关键有几点： 使用单个等号，我发现，2个等号也 OK； 注意到等号两边各有一个空格：这是unix shell的要求 注意到&quot;$test&quot;x最后的x，这是特意安排的，因为当$test为空的时候，上面的表达式就变成了x = testx，显然是不相等的。而如果没有这个 x，表达式就会报错：[: =: unary operator expected 参考： shell中if做比较 从URL截取字段默认去除url的最后斜线： 12url=http://xxx/patch/xxx/xxxx/tar_name=$(echo $&#123;url%*/&#125;|awk -F &apos;/&apos; &apos;&#123;print $NF&#125;&apos;) shell判断字符串包含1if [[ $tar =~ tar.gz ]];then echo &quot;包含&quot;;fi Shell判断字符串包含关系的几种方法 Bash 加 -xe 表示什么意思-e 使shell立即退出，某些东西会返回一个错误(这通常在shell脚本中用作故障保护机制),-x 允许详细执行脚本，你可以看到发生了什么 将-xe参数传递给/ bin / bash的做法是什么 Shell 中的引号https://blog.csdn.net/miyatang/article/details/8077123 Shell定义变量和给变量赋值将命令的执行结果赋值给变量：123var=&apos;pwd&apos;# 或者var=$(pwd) 将 Bash 的内置命令 read 读入的内容赋值给变量：1echo -n &quot;Enter var:&quot;;read var 通配符与特殊符号 符号 意义 * 代表0个到无穷多个任意字符 ？ 代表一定有一个任意字符 [] 同样是代表一定有一个在中括号内的字符（非任意字符）。例如，[abcd]代表一定有一个字符，可能是这四个中的一个 [-] 若减号在括号内，代表在编码顺序内的所有字符。例如，[0-9]代表0-9之间所有数字，因为数字的语系编码是连续的 [^] 若中括号第一个字符是^，表示原向选择，例如[^abc]代表一定有一个字符，只要是非a,b,c的其他字符就接收 示例： 找出/etc/目录下文件夹名字刚好有5个字母的文件名：ll -d /etc/????? 找出/etc/下面文件名含有数字的的文件名：ll -d /etc/*[0-9]* 找出/etc/下面文件名开头非小写字母的文件名：ll -d /etc/[^a-z]* 将上面例子找到的文件复制到/tmp中：` bash 中的特殊符号 符号 内容 # 注释符号 \ 转义符号，将特殊字符或通配符还原成一般字符 竖线 管道 ; 连续命令执行分隔符，连续命令的界定 ~ 用户的主文件夹 $ 使用变量的前导符 &amp; 作业控制，将命令变成背景下工作 ! 逻辑运算意义上的“非” >,&gt;&gt; 数据流重定向，输出导向，分别是“替换”与“累加” &lt;,&lt;&lt; 数据流重定向，输入导向 ‘’ 单引号，不具有变量置换的功能 “” 具有变量置换的功能 `` 两个重音符中间为可以先执行的命令，也可以使用$() () 中间为子shell的起始与结束 {} 中间为命令块的组合 给Linux新增硬盘之后的操作12fdisk -l #查看磁盘情况，发现有磁盘没有分区，比如是/dev/xvdefdisk /dev/xvde #进行磁盘分区的操作 fdisk磁盘分区时，可以输入m，会有提示：123456789101112131415161718Command (m for help): mCommand action a toggle a bootable flag b edit bsd disklabel c toggle the dos compatibility flag d delete a partition l list known partition types m print this menu n add a new partition o create a new empty DOS partition table p print the partition table q quit without saving changes s create a new empty Sun disklabel t change a partition&apos;s system id u change display/entry units v verify the partition table w write table to disk and exit x extra functionality (experts only) 我依次这么输入的：1234567add a new partition:npartion type:pPartion number:分区个数 1First sector默认值:EnterLase sector默认值:Enterprint the partion table:pwrite table to disk and exit:w 分区完成之后，需要格式化1mkfs -t ext4 /dev/xvde1 将新建分区挂载到/data目录下： 12mkdir /datamount /dev/xvde /data 挂载完毕，输入df -hT可以查看到新建的分区 设置文件系统的自动挂载1vi /etc/fstab 添加/dev/xvde1 /data ext4 defaults 0 1 在 fstab 配置文件中加入挂载点之后其实就已经是开机自动挂载了，不需要用 mount 命令挂载。但是还是用 mount 实在，因为最后还是需要写入/etc/fstab 第一段可以用分区名，也可以用 blkid 的方式获取 UUID 的值 参考： www.jianshu.com/p/7b8c3509d5fe 玩转 Linux 之：磁盘分区、挂载知多少？ LVM) Linux 磁盘管理 备份原有配置文件只将不带注释的内容提取出来，作为配置文件 12mv /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd.conf_bakgrep -v &quot;#&quot; /etc/vsftpd/vsftpd.conf_bak &gt; /etc/vsftpd/vsftpd.conf -v 参数表示反选 修改主机名 Linux下修改主机名hostname 查看Linux系统版本12345lsb_release -a # 适用于所有Linux系统cat /etc/os-release #推荐cat /etc/redhat-release # 仅适用于Redhat系列的Linux系统uname -a # 查看Linux内核cat /proc/version # 查看Linux内核 Linux 命令行：查看系统版本的几种方法 Linux查看安装的系统版本 显示 shell 执行过程1set -x 如果想隐藏某一行的内容：12345set -xxxxxset +xyyyyset -x Linux 查看脚本的执行过程 Shell脚本调试技术 查看端口占用123[root@centos7.4 software]# netstat -apn 查看当前运行的所有进程的端口使用情况[root@centos7.4 software]# netstat -apn | grep 端口号 查看指定端口使用情况[root@centos7.4 software]# kill 指定端口的pid号 杀死指定进程（端口号对应的pid） 打印第X行1head -n X | tail -n 1 显示 Path 环境变量显示你的环境变量PATH，一个目录一行： 1echo $PATH | tr : \\n atime mtime ctime 的含义 atime (access time) 访问时间，表示文件最后被访问的时间； mtime (modify time) 修改时间，文件内容被修改的最后时间，平常我们 ls -l 查看文件是，显示的就是 mtime； ctime (change time) 变化时间，文件的元数据发生变化的时间，例如权限、所有者等，通俗来讲，就是文件属性或文件位置改动的时间； 利用 stat file_name 可以查看文件 「amc」time 。 1echo "hello" &gt;&gt; issue 写文件操作（&gt;&gt; 方式）不会导致 atime(访问时间）的修改，但是 mtime 和 ctime 会发生修改。mtime 修改了我们可以理解的，毕竟我们修改了文件的， 那为何ctime也修改了呢， 仔细可以发现我们文件的大小发生了变化，也就是元数据发生了变化，所以ctime也是要变化的 参考： linux中文件的三种time（atime,mtime,ctime） 重定向相关 CSDN-Linux里的2&gt;&amp;1究竟是什么 防火墙有时候需要服务器上需要打开防火墙的端口： 1234sudo firewall-cmd --zone=public --add-port=60001/udp --permanentsudo firewall-cmd --reload#之后检查新的防火墙规则firewall-cmd --list-all 由于只是用于开发环境，所以打算把防火墙关闭掉 12345678910111213//临时关闭防火墙,重启后会重新自动打开systemctl restart firewalld//检查防火墙状态firewall-cmd --statefirewall-cmd --list-all//Disable firewallsystemctl disable firewalldsystemctl stop firewalldsystemctl status firewalld//Enable firewallsystemctl enable firewalldsystemctl start firewalldsystemctl status firewalld 参考： CentOS 7开放端口和关闭防火墙 FAQQ:Linux各目录的作用 linux各文件夹的作用 /usr 目录结构 Unix目录结构的来历 Q：http://blog.csdn.net/u011109356/article/details/54928955/dev/xvda1 占满 Linux好文 Linux工具快速教程]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 配置教程-开发篇]]></title>
    <url>%2F2019%2F04%2F14%2Ftools-dev-mac%2F</url>
    <content type="text"><![CDATA[将 Mac 日常使用的软件和开发软件区分开，将之前写的 Mac 配置的文章分成了两篇： Mac 配置教程-日常篇 Mac 配置教程-开发篇 图床 iPic 设置快捷键 Command+Shift+u PicGo 设置快捷键是 command+shift+p 免密登录1234brew install ssh-copy-idssh-copy-id root@1.2.3.4# 等价于ssh-copy-id -i ~/.ssh/id_rsa.pub root@1.2.3.4 -p 22 ssh-copy-id 这个工具，它的原理其实是把自己的公钥（默认使用 ~/.ssh/id_rsa.pub 这个文件中的内容）复制到目标服务器的~/.ssh/authorized_keys 文件内。 可以利用 SSH 的配置文件来记住已有的配置，快速登录： 编辑~/.ssh/config 文件: 12345Host ss HostName x.x.x.x User root Port 22 IdentityFile ~/.ssh/id_rsa 后续，仅需要ssh ss，即可免密登录。 网络分析 HTTP View 超酷的HTTP(S)的调试助手，一键拦截HTTP(S)，仔细研究和检查流量，并准确地发现您的代码正在发送什么。 编程字体 Hack 专为在源代码中使用而设计的开源字体 alfred 唤起快捷键设为：command双击 输入框：lock，锁屏 empty 清空回收站，瞬间强迫症患者清爽了。 eject 命令可以弹出磁盘、存储卡或者虚拟磁盘镜像，如 .dmg 挂载后的磁盘。 open + 文件名或者空格 + 文件名 搜索文件，Enter 键直接打开文件，→+Reveal in Finder 可以在文件夹中打开文件； find + 文件名 直接在文件夹中打开文件； 输入 in 命令，以及待搜索的文本，列出磁盘中包含该文本的相关文件，可以快速定位文件，相当于简易的终端 find 命令。 快捷搜索URL：123456789百度- https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;wd=&#123;query&#125;淘宝 - https://s.taobao.com/search?q=&#123;query&#125;豆瓣电影：http://movie.douban.com/subject_search?search_text=&#123;query&#125;&amp;cat=1002bilibili：http://search.bilibili.com/all?keyword=&#123;query&#125;百度：https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;wd=&#123;query&#125;stackoverflow：http://www.stackoverflow.com/search?q=&#123;query&#125;githubUser：https://github.com/&#123;query&#125;githubSearch：https://github.com/search?utf8=%E2%9C%93&amp;q=&#123;query&#125;MDN：https://developer.mozilla.org/zh-CN/search?q=&#123;query&#125; 参考： 掘金-Mac 提升开发效率的小工具 剪贴板历史有了 Alfred 的剪贴板增强，以上场景都不是问题，首先要在 Features -&gt;; Clipboard 中打开剪贴板历史： 这里我把它们都设置为存储三个月，同时把打开剪贴板的默认快捷键为 Ctrl + Shift + C。 通过 Command + 数字键，就可以把它粘贴出来 文本片段有一些文本是需要反复输入的，比如你的邮箱、QQ号、地址、手机号码、某个网址等信息，亦或者聊天常用语句、表情等等，这些都可以通过 Alfred 来管理，节省输入时间。打开 Features -&gt;; Snippets： https://www.alfredapp.com/extras/snippets/ 字典设置输入dc开头，然后输入查询的单词； workflow个人推荐的workflow: github：使用之前，需要先gh &gt; login。 ip address：查看本机ip 快递查询：输入kd+单号 YoudaoDict 人民币金额大写：cny然后输入数字即可 Hash：查看文件MD5值等 http_status_code:显示 http 状态码含义 CodeVar： encode 百度地图 我常用的存储在这儿了：my-config-files/alfred-work-flow 下载源： alfredworkflow workflow-list zenorocha/alfred-workflows 自定义终端1234567891011121314151617181920212223242526on alfred_script(q) tell application "iTerm" set _length to count window if _length = 0 then create window with default profile end if set aa to (get miniaturized of current window) if aa then set miniaturized of current window to false end if set bb to (get visible of current window) if bb is false then set visible of current window to true end if set cc to frontmost if cc is false then activate end if (*if _length = 0 then*) set theResult to current tab of current window (*else set theResult to (create tab with default profile) of current window end if*) write session of theResult text qend tellend alfred_script Alfred使用参考： 总是在 Mac 「装机必备」看到的搜索利器 Alfred，究竟是怎么用的？| 新手问号 效率神器 Alfred workflow 插件推荐 Alfred 效率神器全攻略 Alfred神器使用手册 Mac效率神器Alfred系列教程—文件搜索 Beyond CompareBeyond Compare：完美的diff工具； Charles Charles 注册码/破解 DashDash：计算机语言文档神器； 选中文本搜索开发文档：alt/option+s ForkLift 3Mac 上的 Finder 的增强版本，FTP 工具，官网有视频介绍，强烈安利！ 被忽视的 FTP 与文件管理工具：ForkLift 3 for Mac go2shell从官网下载安装，然后打开，同意安装到Finder。 go2shell官网 Mac通过安装Go2Shell实现“在当前目录打开iTerm2” Git 下载安装 123$ ssh-keygen -t rsa -C "649168982@qq.com"$ git config --global user.name "Michael728"$ git config --global user.email "649168982@qq.com" 我的 Git 配置文件在：my-config-files/git FAQQ1： git status乱码执行：git config --global core.quotepath false参考：Git Status 中文乱码解决 Q2：Github 下载速度慢 加快国内访问Github网站的速度 国内为何访问Github如此慢 Homebrew &amp; Cask &amp; launchrocketHomebrew-官网安装 brew 命令： 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" Homebrew cask可以优雅、简单、快速的安装和管理 OS X 图形界面程序，比如 Google Chrome 和 Dropbox，安装 cask 命令：1brew tap caskroom/cask 常用命令： 123456789101112brew search xxx // 搜索brew cask search xxx // 搜索brew list --versions // 查看安装过的包列表，同时显示版本号brew update // 更新 brewbrew upgrade &lt;package_name&gt; // 更新用brew安装的软件brew cleanup // 清理旧版本的包缓存时，清除安装包brew cask cleanup // 清除安装包brew doctor // 检测brew outdated // 看一下哪些软件可以升级brew info xxx // 查看某个软件信息brew cask info xxx // 查看某个软件信息brew unlink vim 更多命令可以通过man brew查看： brew 命令官网 SF-homebrew的tap功能详解 CSDN-mac的homebrew命令详解&amp;全部选项翻译 Homebrew 能够安装哪些软件： brew search xxx 在官网浏览 在Homebrew formulas index查看详细的使用信息 测试安装是否成功： 1234brew install wgetbrew cask install google-chromebrew cask install cakebrew # brewbrew cask install launchrocket # 管理 brew 安装的 service 的工具，安装之后可以看所有的 service 的运行状态 brew 方式安装的软件都在/usr/local/Cellar目录下，执行brew link xxx，则会在/usr/local/share创建软连接。 brew cask 方式安装的软件在/usr/local/Caskroom目录下 Homebrew已成为Mac开发用户必不可少的工具, 大部分开发工具的安装和环境构建都非常方便. 但是如果配合Cakebrew和LaunchRocket, 那将会更方便管理。 brew和brew cask有什么区别？：cask 更偏向图形化软件的安装。 拓展预览程序1brew cask install qlcolorcode qlstephen qlmarkdown quicklook-json qlimagesize webpquicklook qlvideo provisionql quicklookapk 插键-sindresorhus/quick-look-plugins Homebrew 源加速知乎上给出了两种方式，因为有 VPS了，所以，目前我采用的是设置 ~/.curlrc 文件配置如下内容：1socks5 = &quot;127.0.0.1:1086&quot; 具体配置文件，可以查看：my-config-files-homebrew 参考： Homebrew有比较快的源（mirror）吗？ Homebrew Cask 源使用帮助 Homebrew专栏 使用brew cask来安装Mac应用 iTerm2 快捷键打开ITerm2:打开设置，keys-hotkey-show/hide window，我设置快捷键为command+~ 切分屏幕：command+d 水平切分，command+Shift+d垂直切分；Command + [ 和 Command + ] 来切换到左侧或者右侧的标签页。 一个标签页中开的窗口太多，有时候会找不到当前的鼠标，command+/找到它。 按command+;弹出自动补齐窗口，列出曾经使用过的命令 按command+Shift+h弹出历史粘贴记录窗口，command+Shift+;弹出历史命令记录窗口。 command+d，新建垂直标签，利用 command+[/] 左右切换标签窗口。 1234567ctrl + w —往回删除一个单词，光标放在最末尾ctrl + k —往前删除到末尾，光标放在最前面（可以使用ctrl+a）ctrl + u 删除光标以前的字符ctrl + k 删除光标以后的字符ctrl + a 移动光标至的字符头ctrl + e 移动光标至的字符尾ctrl + l 清屏 iTerm2 中选择文本有三种方式，分别是： 双击：选中单词 三击：选中整行 参考： 你应该知道的 iTerm2 使用方法–MAC终端工具 皮肤+字体 皮肤资源 dracula：本人采用的就是这个主题，因为VScode中也是它。 powerline字体教程 字体安装： 1pip install powerline-status 这套皮肤+字体的设置主要是为了配合zsh终端下的现实效果，zsh的使用配置，见文章： zsh+on-my-zsh配置教程指南（程序员必备） 最后效果如下图： 皮肤安装教程见： iTerm 2 &amp;&amp; Oh My Zsh【DIY教程——亲身体验过程】 最简单iTerm2 + oh-my-zsh打造Mac炫酷终端教程-菜鸟版实操整理 FAQQ1: iterm 本地终端中文不乱码，ssh远程中文乱码 iterm 配置utf8编码，本地终端中文不乱码，ssh远程中文乱码，咋整啊 Medishttps://github.com/luin/medis redis 数据库客户端 MySQL sequelpro mysql 客户端，颜值高。免费 Node Node官网：下载LTS版本 12sudo npm install -g hexo # 博客所需sudo npm install gitbook-cli -g # 笔记所需 MoshMosh 表示移动 Shell(Mobile Shell)，是一个用于从客户端跨互联网连接远程服务器的命令行工具。它能用于 SSH 连接，但是比 Secure Shell 功能更多。它是一个类似于 SSH 而带有更多功能的应用。程序最初由Keith Winstein 编写，用于类 Unix 的操作系统中，发布于 GNU GPL V3 协议下。 Mosh 最大的特点是基于UDP方式传输，支持在服务端创建一个临时的Key供客户端一次性连接，退出后失效；也支持通过SSH的配置进行认证，但数据传输本身还是自身的 UDP 方式。 Mosh 有两个非常有用的功能 会话的中断不会导致当前正在前端执行的命令中断，相当于你所有的操作都是在 screen 命令中一样在后台执行。 会话在中断过后，不会立刻退出，而是启用一个计时器，当网络恢复后会自动重新连接，同时会延续之前的会话，不会重新开启一个。 Mosh 替换 SSH 链接，需要你本机和远端 host 都安装 mosh 才OK： 123brew install mosh # macyum install mosh # centosapt-get install mosh # ubuntu PS：我用这款工具的主要原因是，在家里我的 Mac 连接虚拟机的速度非常慢，ssh 到虚拟机执行命令非常卡顿，使用 mosh 之后流畅了许多。 有时候需要服务器上需要打开防火墙的端口： 12sudo firewall-cmd --zone=public --add-port=60001/udp --permanentsudo firewall-cmd --reload Python3安装 在Mac OS X上安装Python 3 Python3-Anaconda 1echo 'export PATH="~/anaconda3/bin:$PATH"' &gt;&gt; ~/.bash_profile 安装之后记得重启终端。 Postman Postman官网 Pycharm 官宣-Pycharm lanyus 福利，细心读者能发现 :) SourceTree源码管理：SourceTree sourcetree官网 typoraMarkdown 编辑器： typora官网 安装 macvim 和 vim1brew install macvim Homebrew formulas index-macvim已经明确指出，这么安装和brew install vim的vim冲突，所有某些博客文章中安装macvim的指导说需要先安装vim的说法是有问题的，我那么执行时就报错了： 1This formula is in conflict with the following 错误提示： 12345Updating Homebrew...Error: Cannot install macvim because conflicting formulae are installed. vim: because vim and macvim both install vi* binariesPlease `brew unlink vim` before continuing. 我先执行了brew install vim，然后通过brew unlink vim去除了/usr/local/share/创建的 vim 相关的软连接，避免和macvim冲突。然后又通过brew install macvim安装了macvim。 如果你想采用macvim代替vim，需要： 123brew unlink vimbrew link macvimalias vim='mvim -v' # 加入 zsh 配置文件 如果你想采用 brew 安装的 vim，替换系统默认的： 123brew unlink mackvimbrew link vimexport PATH="/usr/local/Cellar/vim/8.1.0550/bin:$PATH" # 加入 zsh 配置文件 安装之后，还有一些兼容性的设置需要设置才行： 123vmap &lt;C-c&gt; "+y " 在Visual模式时，按Ctrl+c复制选择的内容set backspace=2 " http://cenalulu.github.io/linux/why-my-backspace-not-work-in-vim/set clipboard+=unnamed " 共享剪贴板 http://www.vitah.net/posts/9ddf2fa9/ 关于 Vim 的配置及使用，可以阅读：Vim 插键及配置 参考： Macvim install fails on MacOS 10.14 FAQ-macvim-dev/macvim Mac的VIM中delete键失效的原因和解决方案 macOS上安装MacVim zsh真是不得不介绍的神器，专门写了一篇文章： zsh+on-my-zsh配置教程指南（程序员必备） Mac 下环境变量规则及管理 VScode 官宣-VS Code 打造性感好用的VS Code编辑器 在 VS code 中快捷键 Shift + Command + p 输入 code ,选择安装 code 命令： 然后就可以在终端中这么打开 VS Code了 ： 1code .vimrc Mac 相关好文 推荐-Mac OS X 配置指南 | Mac OS X Setup Guide Mac开发和编程工具 Mac 提升开发效率的小工具 GitBook-Mac-程序员的自我修养 最后原文链接：Mac 配置总结]]></content>
      <categories>
        <category>ToolsDev</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 模块的加载顺序]]></title>
    <url>%2F2018%2F12%2F15%2Fpython-package-import-order%2F</url>
    <content type="text"><![CDATA[基本概念module模块， 一个 py 文件或以其他文件形式存在的可被导入的就是一个模块 package包，包含有 init 文件的文件夹 relative path相对路径，相对于某个目录的路径 absolute path绝对路径，全路径 Python 解释器是如何查找包和模块的Python 执行一个 py 文件，无论执行的方式是用绝对路径还是相对路径，interpreter 都会把文件所在的 directory 加入 sys.path 这个 list 中，并且是索引为 0 的位置。Python 就是在 sys.path 中查找包和模块的。 1234567891011121314151617181920# test.py# coding:utf-8import sysprint(sys.path)print('Now in main.py')def hello(): print('michael hello')if __name__ == '__main__': hello()# 执行 python test.py$ python test.py['/tmp/module-package/app', '/usr/lib64/python27.zip', '/usr/lib64/python2.7', '/usr/lib64/python2.7/plat-linux2', '/usr/lib64/python2.7/lib-tk', '/usr/lib64/python2.7/lib-old', '/usr/lib64/python2.7/lib-dynload', '/usr/lib64/python2.7/site-packages', '/usr/lib/python2.7/site-packages']Now in test.pymichael hello Python 解释器查找包的顺序解释器查找包： 解释器会默认加载一些 modules，除了sys.builtin_module_names 列出的内置模块之外，还会加载其他一些标准库，都存放在sys.modules字典中。 然后就是搜索 sys.path 路径下的模块了。 1234In [3]: import sysIn [4]: print(sys.builtin_module_names)('_abc', '_ast', '_codecs', '_collections', '_functools', '_imp', '_io', '_locale', '_operator', '_signal', '_sre', '_stat', '_string', '_symtable', '_thread', '_tracemalloc', '_warnings', '_weakref', 'atexit', 'builtins', 'errno', 'faulthandler', 'gc', 'itertools', 'marshal', 'posix', 'pwd', 'sys', 'time', 'xxsubtype', 'zipimport') 这样的查找顺序将会导致同名包或模块被遮蔽。 示例2：123456789101112131415161718192021222324# tree$ tree . -L 1.├── __init__.py├── name├── os.py├── test2.py├── test.py└── test.pyc# test2.pyimport osfrom redis import Redisfrom test import helloprint('Now in test2.py')print(os.getcwd())# 执行 python test2.py$ python test2.pyTraceback (most recent call last): File "test2.py", line 2, in &lt;module&gt; from redis import RedisImportError: No module named redis 这里的 os 模块并不是是 built-in module，上面已经将 sys.builtin_module_names 内容打印出来了。只是 Python 解释器启动时就加载到了 sys.modules中缓存起来了。所以，即使在同目录下有同名模块，解释器依然是可以找到正确的 os 模块的！如果你在import os之前，先执行del sys.modules[&#39;os&#39;]，那么，标准模块 os 就会被同目录下的 os.py 屏蔽了。 redis 属于第三方模块，默认安装位置是 Python 环境变量中的 site-packages，解释器启动之后，会将此目录加到 sys.path，由于当前目录会在 sys.path 的首位，当前目录的 redis 优先被找到了，site-packages 中的 redis 模块被屏蔽了。 综上所述，搜索的一个顺序是：sys.modules 缓存 -&gt; sys.path[0] 即当前目录查找 -&gt; sys.path[1:]路径查找。 同时发现，模块被加载的时候，其中非函数或类的语句，例如 print(&#39;hello&#39;)、name=michael等，是会在 import的时候，默认就执行了。 交互式执行环境的查找顺序交互执行环境，解释器会自动把当前目录加入到sys.path，这一点和直接执行文件是一样的，但是这种方式下，sys.path[0] 是存储的当前目录的相对路径，而不是绝对路径。 1234In [4]: import sysIn [5]: sys.path[0]Out[5]: '' 模块中的 __file__ 变量文件中的 __file__当模块以文件的形式出现 file 指的是模块文件的路径名，以相对路径执行 file 是相对路径，以绝对路径执行 file 是绝对路径： 123456789# test3.pyprint __file__# 执行 python test.py$ python test3.pytest3.py$ python /tmp/module-package/app/test3.py/tmp/module-package/app/test3.py 交互式 Shell 中的 __file__前交互式 Shell 的执行并不是以文件的形式加载，所以不存在 __file__ 这样的属性： 1234567In [8]: __file__---------------------------------------------------------------------------NameError Traceback (most recent call last)&lt;ipython-input-8-358d5687b810&gt; in &lt;module&gt;()----&gt; 1 __file__NameError: name '__file__' is not defined sys.argv[0] 变量sys.argv[0] 是获得入口执行文件路径，__file__ 是真实被执行模块的文件路径。比如下面例子中，test2.py 就是入口执行文件，而 test.py 就是在 import 时真实被执行的模块 12345678910# test.pyprint(__file__)print(sys.argv[0])# test2.pyimport test# 执行 python test2.py/tmp/module-package/app/test.py # __file__test2.py # sys.argv[0] sys.modules 的作用载入的模块存放在何处？ 答案是 sys.modules。 模块一经载入， Python 会把这个模块加入 sys.modules 中供下次载入使用，这样可以加速模块引入，起到缓存作用。sys.modules 是一个 dict 类型的值。 123456789101112In [14]: sys.modules['requests']---------------------------------------------------------------------------KeyError Traceback (most recent call last)&lt;ipython-input-14-8aefaef0aed5&gt; in &lt;module&gt;()----&gt; 1 sys.modules['requests']KeyError: 'requests'In [15]: import requestsIn [16]: sys.modules['requests']Out[16]: &lt;module 'requests' from '/usr/lib/python2.7/site-packages/requests/__init__.pyc'&gt; 123# 没有预先引入 math，但是 sys.modules 中已经有这个键In [18]: sys.modules['math']Out[18]: &lt;module 'math' from '/usr/lib64/python2.7/lib-dynload/math.so'&gt; 需要注意的是， sys.modules[&#39;math&#39;] 尽管可以看到 math 键，但是，要使用它，还是需要显示 import math 之后才能使用的，因为那只是 Python 解释器后台缓存的，你不显示引入，本地空间还是不会去发现它。 总结Python 通过查找 sys.path 来决定包的导入，Python解释器启动时加载的模块缓存 &gt; 同级目录 &gt; sys.path[1:]。Python 中的特有属性 __file__ 以及 sys.argv[0]、sys.argv[0]、sys.modules 可以帮助分析包的查找和导入过程。 解决这个问题，请教了大牛同事，果然一下子让我明白了。于是，自问自答了在 SegmentFault 上提的问题： Python 包的引入顺序到底是怎样的？ 参考 三月沙-如何理解 Python 的模块查找原理与方式 本文内容主要参考，但是该文章中提到的os属于built-in moulde的理解是有误的，本文中修正了理解。 构建一个模块的层级包 The Python Standard Library Medium-Python 的 Import 陷阱 CSDN-Python 模块搜索路径 提交了 PYTHONPATH 这个环境变量的作用 librarybook-The sys module 官宣-System-specific parameters and functions]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python 调试模块 ipdb]]></title>
    <url>%2F2018%2F12%2F15%2Fpython-debug-ipdb%2F</url>
    <content type="text"><![CDATA[授人以鱼不如授人以渔，掌握调试方法是学习提升的一个必备条件。前几天因为探索了一下 Python 模块引入路径的问题，看到「翔 Core」用 pdb 调试的很溜，因此，今天研究一下 ipdb好啦。 安装ipdb 是 pdb 模块的升级版，会启动一个 ipython 的调试窗口。 1pip install ipdb 使用 python -m ipdb demo.py 直接运行程序，不需要再程序中去插入内容； import ipdb;ipdb.set_trace()，这种用法需要在程序内部插入语句，类似插入「断点」的效果； 帮助文档在 ipdb 窗口，输入 h ，会看到帮助文档，h &lt;command&gt; 可以查看具体命令的帮助。 1234567891011121314Documented commands (type help &lt;topic&gt;):========================================EOF cl disable interact next psource rv unta clear display j p q s untilalias commands down jump pdef quit source upargs condition enable l pdoc r step wb cont exit list pfile restart tbreak whatisbreak continue h ll pinfo return u wherebt d help longlist pinfo2 retval unaliasc debug ignore n pp run undisplayMiscellaneous help topics:==========================exec pdb 常用命令 a(rgs)：打印当前函数的参数列表 ★★★ b(reak) [ ([filename:]lineno | function) [, condition] ]：设置断点，可以接行数或者行数名作为参数，比如，b 8 就是在第8行打断点，还可以给外部的文件加上断点 b file_name:line_number，如果只敲 b ，会显示全部断点 c(ont(inue))：继续执行，当遇到断点时才会停止 ★★★ cl(ear) filename:lineno ：可以清除断点，不过不加「断点号」，可以清除所有断点 disable bpnumber [bpnumber ...] ：禁用指定[断点号]的断点 enable bpnumber [bpnumber ...]：启用指定[断点号]的断点 Enter：重复上次命令 ★★★ j(ump)：设置下一步执行的行，这个语句可以让你跳过某些语句的执行，并不是网上一些文章说的跳到某行，跳到某行可不是代表会跳过某些语句的，文档最准确 ll or l：查看当前将要运行的代码段 n(ext)：让程序运行下一行，如果当前语句有一个函数调用，用 n 是不会进入被调用的函数体中的 ★★★ pp expression or p expression：前者以 pprint 方式打印表达式的值，后者 print 方式 ★★★ q(uit)：退出调试，同时，你也可以使用 Ctrl+D退出调试 r(eturn)：继续执行，直到当前函数返回 ★★★ restart &quot;restart&quot; is an alias for &quot;run&quot;. ：是 run 命令的别名，重新启动调试器； run [args...] ：这里的参数会作为运行脚本的参数，等价于 python demo.py [args...]，可以通过 sys.argv 查看参数列表，重新运行时，断点等信息会保留的 s(tep)：和 n 相似，但是如果当前有一个函数调用，s 会进入被调用的函数体中 ★★★ w(here)：打印一个堆栈跟踪， ! ：感叹号后面跟着语句，可以直接改变某个变量的值 示例断点示例下面是一个关于断点的示例：执行 b 7、b 12 之后，输入 ll 查看，最左侧的 1、2 就是断点号，输入 c ，下次运行到断点处，执行就会停下来。 123456789101112131415ipdb&gt; ll----&gt; 1 a = 'michael' 2 print(a) 3 4 def hello(name): 5 print('hello') 6 for i in range(5):1 7 print(i) 8 print(name) 9 10 11 hello('michael')2 12 x = 10 13 y = 20 执行 disable 1，下次执行到「断点1」处，就不会停下来了，输入 b 可以查看全部断点： 1234ipdb&gt; bNum Type Disp Enb Where1 breakpoint keep no at /Users/michael/Code/00-Temp/b.py:72 breakpoint keep yes at /Users/michael/Code/00-Temp/b.py:12 如果想清除「断点2」，那么执行 cl 2 即可： 12ipdb&gt; cl 2Deleted breakpoint 2 at /Users/michael/Code/00-Temp/b.py:12 run 示例1234567891011ipdb&gt; run --name michaelRestarting b.py with arguments: --name michael&gt; /Users/michael/Code/00-Temp/b.py(1)&lt;module&gt;()----&gt; 1 a = 'michael' 2 print(a) 3ipdb&gt; import sysipdb&gt; sys.argv['b.py', '--name', 'michael'] 看到上面的结果，确实等价于 python b.py --name michael。 注意点在 ipdb 调试窗口，虽然可以随时给变量赋值，但是要注意变量的名字和 ipdb 的命令不能重复了，否则会出错，可以用 !b=123 来规避这个问题。 案例背景遇到这个错误： 1AttributeError: 'module' object has no attribute 'processor' 网上有相关问题： https://stackoverflow.com/questions/1250103/attributeerror-module-object-has-no-attribute 主要是两种常见的错误会造成这个： 模块命名和标准模块命名冲突了； 循环引用 分析搜索项目中哪些地方引入 platform 1grep -rIin 'import platform' 同时，还可以在使用 platform.processor() 方法前面加上 print(paltform.__file__) 查看启动 Python 时，就自动加载的模块： 1python -v 或者 12import syssys.modules['platform'] 查看运行编包命令时，加载的模块： 1python -v /usr/bin/pkg 将以上输出对比了一下，先排除标准模块会引入 platform ，因为标准模块，一般都是「自包含」。然后和 python -v 对比，发现编包命令多加载了一个第三方 blessings 模块，是不是它引入 platform 的呢？ 发现，正常的构建机器上，这个模块是 1.6.1 版本，而目前发现问题的机器，这个包版本是 1.7 版本。那么，来看看，他俩之间的差异： Github-erikrose/blessings包，点击分支，查看 Tag 1.7 的提交记录，发现了这个提交 1from platform import python_version_tuple 1.7 版本中，这一行删除了，所以发生了差异。 根本原因： 1pkgutil.iter_modules(package.__path__) 相关问题 SOF-AttributeError: ‘module’ object has no attribute 最后学完这个 ipdb 的调试，再回头看看 Pycharm 的 debug 功能，貌似都能理解了！ 参考 使用IPDB调试Python代码 IBM-Python 代码调试技巧 油管-Introduction to the Python Debugger]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>method</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 标准库 argparse 的用法]]></title>
    <url>%2F2018%2F12%2F09%2Fpython-argparse-note%2F</url>
    <content type="text"><![CDATA[argparse 是 Python 内置的一个用于命令项选项与参数解析的模块。Python 也有第三方的库可用于命令行解析，而且功能也更加强大，比如 docopt，Click Argparse主要有三个步骤： 创建 ArgumentParser() 对象 调用 add_argument() 方法添加参数 使用 parse_args() 解析添加的参数 参数说明add_argument12ArgumentParser.add_argument(name or flags...[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest]) 每个参数解释如下: name or flags - 选项字符串的名字或者列表，例如 foo 或者 -f, –foo。 action - 命令行遇到参数时的动作，默认值是 store。 store_const，表示赋值为const； append，将遇到的值存储成列表，也就是如果参数重复则会保存多个值; append_const，将参数规范中定义的一个值保存到一个列表； count，存储遇到的次数；此外，也可以继承 argparse.Action 自定义参数解析； nargs - 应该读取的命令行参数个数，可以是具体的数字，或者是?号，当不指定值时对于 Positional argument 使用 default，对于 Optional argument 使用 const；或者是 * 号，表示 0 或多个参数；或者是 + 号表示 1 或多个参数。 const - 一个在 action 和 nargs 选项所需的常量值。 default - 不指定参数时的默认值。 type - 命令行参数应该被转换成的类型。 choices - 参数可允许的值的一个容器。 required - 可选参数是否可以省略 (仅针对可选参数)。 help - 参数的帮助信息，当指定为 argparse.SUPPRESS 时表示不显示该参数的帮助信息. metavar - 在 usage 说明中的参数名称，对于必选参数默认就是参数名称（上面的 name or flags），对于可选参数默认是全大写的参数名称. dest - parse_args() 方法返回的对象所添加的属性的名称。默认情况下，对于可选参数选取最长的名称，中划线转换为下划线. 官方示例123456789101112131415161718# 创建了 ArgumentParser 对象，该对象具有解析命令行转为 Python 数据类型的全部信息parser = argparse.ArgumentParser(description='Process some integers.')# 增加参数parser.add_argument('integers', metavar='N', type=int, nargs='+', help='an integer for the accumulator')parser.add_argument('--sum', dest='accumulate', action='store_const', const=sum, default=max, help='sum the integers (default: find the max)')parser.add_argument('--foo', action='store_true')parser.add_argument('--bar', action='store_false')# 调用 parse_args() 会返回对象的两个属性，integers 和 accumulate。 integers 属性是一个列表# 如果在命令行中指定了 --sum，例如 python a.py 1 --sum ，则 accumulate 属性将是 sum() 函数，# 如果没有加上 --sum，例如 python a.py 1，则 accumulate 为 max() 函数&gt;&gt;&gt; parser.parse_args(['--sum', '7', '-1', '42'])Namespace(accumulate=&lt;built-in function sum&gt;, integers=[7, -1, 42]) 这里的 store_const 可以这么理解，它对应的属性是可以手动赋值的，比如这里的 accumulate，该属性值是自动获取： 如果参数中使用了 --sum，那么后面不赋值，accumulate 也会根据取 const 指定的值取值； 如果参数中没有出现 --sum，那么这个可选参数会去 default 指定的值，如果不指定默认值，会取值 None 这里的 store_false 可以这么理解，它对应的属性也是不可以赋值的，是自动获取的： 命令行使用了 --foo，这个属性就为 True，否则为 False 命令行使用了 --bar，这个属性就为 False，否则就为 True 互斥示例123group = parser.add_mutually_exclusive_group()group.add_argument("-v", "--verbose", action="store_true")group.add_argument("-q", "--quiet", action="store_true") 源代码本文示例代码可见： python-useful-modules/learn_argparse/ 参考： 极客学院-argparse 官宣-Python argparse 知乎-Python-argparse-命令行与参数解析 简书-python argparse用法总结 理解了 store 和 互斥参数]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 配置教程-日常篇]]></title>
    <url>%2F2018%2F12%2F08%2Ftools-daily-mac%2F</url>
    <content type="text"><![CDATA[今年终于在推出 2018 款 MBP 时，看到升级了 CPU，我就果断下手「拔草」。本文记录使用 Mac 的一些配置，会长期更新。 为了控制文章的篇幅，我将 Mac 使用配置分成了两篇： Mac 配置教程-日常篇 Mac 配置教程-开发篇 系统配置记录一些 Mac 系统配置方面的技巧，让使用起来更方便。 快捷键整理 Ctrl 多用于命令行快捷键，Command 多用于图形化快捷键 选中桌面的所有需归档资料，Command+Sshift+n，会将文件归档到一个文件夹下 调度中心设置：右control，显示桌面 触发角 辅助功能-鼠标与控制板-触控板选项-启用拖移 Option+Command+v 类似剪切的功能，就是粘贴后，原来文件会被剪切过来。复制文件后，除了用快捷键，还可以在文件夹空白处右键，然后再按住 「⌥」，原本的「粘贴项目」就变成了「将项目移动到这里」 删除文件： Command+Delete 工具栏添加垃圾箱，然后选择待删除文件，点击垃圾箱即可删除 复制文件路径：Command+Option+c 按住 Option 很多菜单会发生些小变化 emoji 表情：Control + Command + Space Command+Up：回到上一层文件夹 Command+Down：如果是文件夹就进入文件夹，如果是文件就打开 Enter：选中一个文件 Enter，直接改名 锁屏：Ctrl + Command + q 单词，选中，三指，自动翻译单词 临时性切换显示/隐藏：Command+Shift+. Command+Alt+i: Chrome开发者工具，F12功能 终端快捷键 Ctrl + A：移动到行首 Ctrl + E：移动到行尾 Ctrl + K：删除到行尾 Ctrl + U：删除到行头 Ctrl + N：移动到下一行 Ctrl + P：移动到上一行 设置允许「任何来源」的应用有时候会遇到这种错误「报错：无法打开已损坏的安装包」，打开终端，键入命令，输入密码，然后回车： 12sudo spctl --master-disabledefaults write com.apple.LaunchServices LSQuarantine -bool false 打开「安全性与隐私」，发现久违的「任何来源」回来了。 改建为了将外置键盘和Mac键盘的option键、command键保持一致的顺序，做如下修改：设置-键盘-修饰键-选择键盘（选择外设键盘）-调整顺序 Mac系统切换机械键盘win和alt键 使用 Shift 键Shift 键类似于可视模式，比如在某个位置点击光标并按住 Shift 键不松开，再去另一个位置点击一次，就可以选中两次点击位置之间的文本内容。 触控板 四指捏合，展开全部应用 辅助功能-鼠标 开启三指拖拽 参考： 用了那么久 Mac，才知道触控板原来还有这些功能 Mac Split View屏幕分割 长按左上角放大的绿色按钮，然后就会选择放置应用的区域！ 参考： Mac Split View屏幕分割 更改默认文件打开方式两指轻按文件，显示简介中，可以看到打开方式选项。 电池 按住 Option 键并点按菜单栏中的电池图标，以显示电池状态菜单 Tab 键适用于所有控制全键盘控制改为「所有控制」 其他 如何更改 Mac 帐户和个人文件夹的名称 Mac修改账户名称和个人目录后，进不去系统怎么办？ 日常软件分屏软件目前在用的是一款付费软件 magnet，也不贵，6元，感觉还挺好用，下面是它的常用快捷键： spectacle 这款软件时免费的，也可以体验一下： option+command+←：窗口左边停靠 option+command+→：窗口右边停靠 option+command+f：窗口全屏 视频播放器 官宣-IINA播放器 人人影视客户端 截图 腾讯-截图 设定了快捷键为 Ctrl+Shift+a 下载工具qBittorrent： qBittorrent 下载 搜索插键 qBittorrent下载の道 还有一个下载工具，不过没试用过，做个记录：Photon 视频制作 OBS 免费的录屏软件 ArcTime 字幕工具，用来给视频添加字幕，免费。 状态栏图标管理 Dozer 免费开源，brew cask install dozer，足够用了，推荐 vanilla 免费，按住 Command 键，拖动顶部状态栏图标归档之后，就会隐藏图标了。 Bartender：一款非常实用的 Menubar 菜单栏管理工具，付费的 CatchMouseMac双屏时，通过快捷键快速切换到另外一屏。 catchmouse下载 mac下双屏切换 cheatsheet在使用一些软件时，长按 Command 按键，会出现快捷键菜单 官宣-cheatsheet DownieDownie：下载各网站视频且更新频繁； encrypto文件加密软件： encrypto 免费的加密软件 licecap一款用来制作 Gif 动态图片的小软件： licecap官网 manico默认，长按option，显示dock应用，数字快速切换应用。 Mos Mos 鼠标平滑滚动软件，很好用。免费开源 123$ brew cask install mos$ brew update$ brew cask reinstall mos NightOwlNightOwl ：一款让 Mojave 深色模式更加智能的神器，可以将当前开启的某些软件单独设置成「始终显示为浅色」，这样，即使系统在深色模式下，这些被勾选的软件也会依然显示为浅色界面。 PopClip当你在 Mac 上用鼠标选择文字后 PopClip 即会出现。然后即可执行针对内容的特定操作，包括「拷贝」、「复制」以及其它插件操作例如「发送至 Evernote」等。 我安装了扩展： dash 选中，可以启动 Dash 搜索开发文档 terminal: 复制相关代码时，就可以默认直接去终端执行了，可以设置为默认 iTerm2 bing alfred 这几个扩展，可以到这里下载：my-config-files/popclip 参考： popclip扩展官网 PinPoint鼠标指针修改 Pixelmator图片处理软件 snap Snap-Mac平台下的快捷键设置App-在Mac下使用机械键盘！ TyporaTypora：Markdown 编辑器。 Telegram Telegram使用指南 iMazing[Mac/Win]备份/管理iOS设备 iTunes 的替代品 keycastr屏幕上显示你敲击的快捷键，或者也可以设置显示你敲击的任意字母。 How can I show typing keyboard in record screen 官宣-keycastr/keycastr Mac 相关好文 推荐-Mac OS X 配置指南 | Mac OS X Setup Guide 你每天都能用上的 Mac 快捷键 少数派-macOS 上都有哪些既免费、又实用的工具？| 新手问号]]></content>
      <categories>
        <category>ToolsDaily</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim 基础]]></title>
    <url>%2F2018%2F12%2F02%2Ftools-vim-basic%2F</url>
    <content type="text"><![CDATA[Vim 学习系列： Vim 基础 Vim 插件及配置 主要分为三种模式： 一般模式 编辑模式 命令行模式 光标的移动单词级比单纯的逐个字符的移动，效率要高 w or W 向移动到下一单词开头 ★★ b or B 向左移动到单词开头 ★★ 块级 gg文档第一行，相当于1G ★★★ G文档最后一行,&lt;n&gt;G移动到你n行 ★★★ 0 or ^ orhome到行首（第1列） ★★ $ or end到行尾 ★★★ :&lt;N&gt; or &lt;N&gt;gg跳转到第 N 行 ★★ &lt;N&gt;j or &lt;N&gt;↓，向下移动 N 行，同理，也可以实现左右移动 ★★ v or V，字符选择或者行选择 ★★ ctrl-v 长方形选择，牛逼了 ★★ ctrl-f 屏幕向下移动一页 ctrl-b 屏幕向上移动一页 注意，所有命令都可以加一个数字N，表示对后面的命令执行N次，比如&lt;N&gt;G表示移动到第 N 行。 高级移动 &#39;. 跳到最后修改的那一行 gd 跳到当前变量在当前文件的定义处，其实是跳转到当前变量在此文件中第一次出现的地方，不过一般来说，第一次出现的地方也就是变量定义的地方 ★★★ ma 在当前位置做标记，用字母a标记当前光标所在位置，这里a可以是任意字母 :&#39;a 跳到标记a处 ★★ :&#39;. 跳转到最后一次修改的地方(.代表最后一次修改的地方) :&#39;&quot; 上一次编辑文件的地方 :&#39;&#39; 跳转到上次跳转之前的位置 打开文件、查找内容vim中打开文件 :e &lt;filename&gt;，在vim中打开名为filename的文件，如果没有，则创建； 文档内查找 * 向后查找光标当前所在单词 # 向前查找光标当前所在单词 ★★★ /&lt;search&gt; 向后查找指定字符 ?&lt;search&gt; 向后查找指定字符串 n 继续查找下一个 ★★★ N 继续查找上一个 匹配查找vim 中可以使用% 对 (和 )，[ 和 ]，{和 } 进行匹配查找，当光标位于其中一个 符号上时，按下%，光标会跳到与之匹配的另外一个符号上。 括号匹配，程序员必备 文档的修改与保存插入 ctrl-p 插入模式下进行单词补齐，比如有一个变量为michael，那么你只需要敲入部分名之后，就可以按下ctrl-p自动补全了。★★★ a 当前字符后插入 ★★★ I 行首插入 A 行尾插入 o 在下一行插入 ★★★ O 在上一行插入 ★★★ 删除 x 删除当前字符 X 向前删除一个字符，相当于键盘的Back Space。 dd 删除当前行，并将删除内容保存在vim剪贴板 ndd表示删除光标所在的向下n行。★★ dw 删除光标所在位置到下个字的第一个字母 daw 删除一个单词，包括词尾空格，实用，不用将光标移动到单词第一个字母，aw表示a word d&lt;X&gt; 删除指定内容，保存在剪贴板 c&lt;X&gt; 删除指定内容，保存在剪贴板，同时进入insert模式 说明，部分是对操作内容的描述，比如，删除一个单词，可以dw或者de，要复制当前位置到行尾内容，可以输入y$，要删除后面3个字符并插入，就输入c3l。 复制 yy 复制当前行到vim剪贴板 nyy复制光标向下n行 ★★★ y&lt;X&gt; 复制指定内容到剪贴板 粘贴 p 当前位置后粘贴 ★★★ P 在当前位置前粘贴 合并 J 当前行与下一行合并 替换 r&lt;X&gt; 将当前字符替换为X ★★★ :%s/search&gt;/&lt;replace&gt;/ 查找search内容并替换为replace内容，正则表达来替换，这个命令可以消除所有行位多余的空格：:%s/\s\+$// ★★★ &lt;n1&gt;,&lt;n2&gt;s/word1/word2/gc n1/n2都是数字，在n1行和n2行之间寻找word1，替换为word2。c代表confirm，替换前需要你确认，不加就默认全部替换。n2用$表示时，表示搜索到最后一行。★★★ 撤销、重做 u 撤销 ★★★ ctrl-r 重做 ★★★ . 重复前一个操作的意思 ★★★ 保存文件 :wq or ZZ 保存并退出 :x 保存退出 :q! or ZQ 强制推出，不保存 saveas &lt;newfilename&gt; 文件另存为 编辑 ctrl-n or ctrl-p Vim自带的补全（按照全文已有输入）★★★ d$ 从光标处删至当前行尾部 多窗口 :sp 切割窗口 ctrl-w-j或者ctrl-w-↓ 跳转窗口 :q或者ctrl-w-q 关闭当前窗口 重复上一次命令vim有一个特殊的命令.，你可以用它重复执行上一个命令。我感觉有点像EXCEL中的F4命令。 缩进 &gt;&gt; 向右缩进当前行 &lt;&lt; 向左缩进当前行 分屏与标签页分屏方式 :vsplit 缩写vs or ctrl-w v左右分屏 :split 缩写sp or ctrl-w s上下分屏 :diffsplit 缩写:diffs diff模式打开一个分屏，后面可以加上{filename} 窗口跳转 ctrl-w w 激活下一个窗口 ctrl-w j 激活下方窗口 ctrl-w k 激活上方窗口 ctrl-w h 激活左侧窗口 ctrl-w l 激活右侧窗口 关闭分屏12ctrl+w c # 关闭当前窗口 如果是最后一个窗口，无法关闭ctrl+w q # 关闭当前窗口 如果只剩最后一个，则退出Vim 参考： VIM的分屏功能 FAQQ:配置VIM，安装vim-plug插件之后，想要生效通过source ~/.vimrc命令生效配置，就会报错：E492: Not an editor command: Plug123[root@localhost ~]# source .vimrc-bash: .vimrc: line 2: syntax error near unexpected token `(&apos;-bash: .vimrc: line 2: `call plug#begin(&apos;~/.vim/plugged&apos;)&apos; error while running “source .vimrc”原因是，我们.vimrc本身并不是shell文件，而source ~/.vimrc等价于./.vimrc，当然后校验shell语法了。看了StackOverflow上的解答才清楚的。 可以通过输入$vim直接进入vim的命令模式，执行下面命令 1:source ~/.vimrc 注意，我这里.vimrc的位置就是位于~目录下，你可以:source /path/to/.vimrc 或者编辑完.vimrc文件，直接：1:so $MYVIMRC Q:从Win上复制文件时，常常因为换行符出错1:set fileformat=unix linux的文件换行符为\n，但windows却非要把\r\n作为换行符，所以，vim在解析从windows拷贝到linux的的vimrc时，因为遇到无法解析的\r，所以报错。 vim E492: Not an editor command: ^M(使用VIM打开文件一直提示错误) 最后周末放假好好折腾了一下，安装插键可以参考这篇文章： Vim 插键及配置 附上我的 Vim 配置文件链接 参考 wklken一些vim个性化配置 dofy-Github-Vim 实操教程（Learn Vim） 系列基础入门 wxnacy-Vim 练级手册 wxnacy-Vim 专辑 archlinux-Vim (简体中文)) kawabangga-Vim系列教程 进阶用法]]></content>
      <categories>
        <category>ToolsDev</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim 插件及配置]]></title>
    <url>%2F2018%2F12%2F02%2Ftools-vim-plugin-config%2F</url>
    <content type="text"><![CDATA[编辑器之神 —— Vim Vim 学习系列： Vim 基础 Vim 插件及配置 平日使用 vim 经常编辑文件，想想使用时的痛点，决定研究一下插件的使用。 Vim的扩展通常也被成为bundle或插件。 软件版本： Mac OS X 10.14.1 vim 8.1 插件安装-Vundle众多文章中都提到Vundle，那我就选用它好了！ 有一个 Vim 的插键网站，专门有相关插键的配置介绍：VimAwesome 1.将Vundle下载到本地，后面下载的插件也将会下载到~/.vim/bundle路径下。1git clone https://github.com/gmarik/Vundle.vim.git ~/.vim/bundle/Vundle.vim 2.插件配置，将如下的内容粘贴到~/.vimrc的顶部(前提是，你本身.vimrc里一开始没有什么其他内容)。12345678910111213141516171819202122232425262728293031323334353637383940414243set nocompatible &quot; be iMproved, requiredfiletype off &quot; required&quot; set the runtime path to include Vundle and initializeset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()&quot; alternatively, pass a path where Vundle should install plugins&quot;call vundle#begin(&apos;~/some/path/here&apos;)&quot; let Vundle manage Vundle, requiredPlugin &apos;VundleVim/Vundle.vim&apos;&quot; The following are examples of different formats supported.&quot; Keep Plugin commands between vundle#begin/end.&quot; plugin on GitHub repo&quot; Plugin &apos;tpope/vim-fugitive&apos;&quot; plugin from http://vim-scripts.org/vim/scripts.html&quot; Plugin &apos;L9&apos;&quot; Git plugin not hosted on GitHub&quot; Plugin &apos;git://git.wincent.com/command-t.git&apos;&quot; git repos on your local machine (i.e. when working on your own plugin)&quot; Plugin &apos;file:///home/gmarik/path/to/plugin&apos;&quot; The sparkup vim script is in a subdirectory of this repo called vim.&quot; Pass the path to set the runtimepath properly.&quot; Plugin &apos;rstacruz/sparkup&apos;, &#123;&apos;rtp&apos;: &apos;vim/&apos;&#125;&quot; Install L9 and avoid a Naming conflict if you&apos;ve already installed a&quot; different version somewhere else.&quot; Plugin &apos;ascenator/L9&apos;, &#123;&apos;name&apos;: &apos;newL9&apos;&#125;&quot; All of your Plugins must be added before the following linecall vundle#end() &quot; requiredfiletype plugin indent on &quot; required&quot; To ignore plugin indent changes, instead use:&quot;filetype plugin on&quot;&quot; Brief help&quot; :PluginList - lists configured plugins&quot; :PluginInstall - installs plugins; append `!` to update or just :PluginUpdate&quot; :PluginSearch foo - searches for foo; append `!` to refresh local cache&quot; :PluginClean - confirms removal of unused plugins; append `!` to auto-approve removal&quot;&quot; see :h vundle for more details or wiki for FAQ&quot; Put your non-Plugin stuff after this line 3.安装插件将需要安装的插键放入.vimrc文件中即可，例如：12Plugin &apos;scrooloose/nerdtree&apos;&quot;Plugin &apos;scrooloose/nerdtree&apos; &quot; 如果暂时不启用，就将该插件注释掉 打开vim，然后输入： 123vim # 打开 vim:PluginInstall:PluginList # 查看已安装插键列表 4.升级与卸载插件12# 注释下面这段话# Plugin &apos;Valloric/YouCompleteMe&apos; 然后 12:PluginUpdate # 这个命令本身可以一键升级所有插件:PlugginClean 参考： How to unInstall plugin? 5.帮助文档1:h vundle NERDTree1234567891011Plugin &apos;scrooloose/nerdtree&apos;&quot;F2开启和关闭树&quot;map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;let NERDTreeChDirMode=1&quot;显示书签&quot;let NERDTreeShowBookmarks=1&quot;设置忽略文件类型&quot;let NERDTreeIgnore=[&apos;\~$&apos;, &apos;\.pyc$&apos;, &apos;\.swp$&apos;]&quot;窗口大小&quot;let NERDTreeWinSize=25 python-mode1Plugin &apos;klen/python-mode&apos; &quot; https://vimawesome.com/plugin/python-mode 编写 Python 文件保存时，就会进行语法检查了：1234567let g:pymode_rope = 1let g:pymode_rope_completion = 1let g:pymode_rope_completion_bind = &apos;&lt;C-p&gt;&apos; &quot;为了自动补全有效，需要将 set paste 设置不启用let g:pymode_rope_goto_definition_bind = &apos;&lt;C-c&gt;g&apos;let g:pymode_python = &apos;python&apos; &quot; 默认检查 Python2&quot;Autofix PEP8 errorsnnoremap &lt;leader&gt;f :PymodeLintAuto&lt;CR&gt; 快捷键：12K 显示内置函数文档&lt;leader&gt;r 运行 python 文件 # let mapleader=&quot;, &quot; &quot; 设置 leader 为空格，那么`,+r`就可以运行 python 文件了 参考： 油管-python-mode Can’t get the jedi-vim plugin to work 解决了 python-mode 不自动补全的问题 python-mode/doc/pymode.txt vim-airline一个状态栏美化工具，颜控必备。附带功能可以一目了然的区分各种编辑状态。 12Plugin &apos;vim-airline/vim-airline&apos; &quot;https://github.com/vim-airlin e/vim-airlinePlugin &apos;vim-airline/vim-airline-themes&apos; &quot; https://github.com/v im-airline/vim-airline-themes https://github.com/vim-airline/vi m-airline/wiki/Screenshots 主题预览 To use solarized dark, set :AirlineTheme solarized and add the following to your .vimrc: let g:airline_solarized_bg=’dark’ 配置： 12345let g:airline_powerline_fonts = 1let g:airline_theme=&apos;deus&apos;let g:Powerline_symbols=&apos;fancy&apos;let Powerline_symbols=&apos;fancy&apos;set t_Co=256 &quot; 状态栏就有颜色了 Yggdroot/indentLine安装：1Plugin &apos;Yggdroot/indentLine&apos; 配置：12let g:indentLine_enabled = 1let g:indentLine_color_term = 239 为了这个插件能够有效果，也是折腾了半天。在 CentOS 平台是正常的，但是在 Mac 上的缩进线显示不正确，为何会这样呢？SOF-Why is apple vim compiled WITHOUT conceal feature?，原来 Mac 上自带的 Vim 版本虽然是8.0版本，但是没有concel这个 Feature ，而indentLine插件要显示对齐线依赖这个，坚线和星号在使用 conceal 功能。 那么该怎么添加这个特性呢？搜了一圈，可以重新安装 Vim，可以参考这篇文章安装 Vim。 经过安装设置之后，可以通过vim --version|grep con或者:echo has(&quot;conceal&quot;)查看是否已经具有 conceal 特性： rking/ag.vimag 的语法：1ag [FILE-TYPE] [OPTIONS] PATTERN [PATH] ag 这个 vim 插键主要是基于这个项目 ggreer/the_silver_searcher 1ag --list-file-types # 查看支持自定义哪些文件类型 安装了这个插键后，在 vim 的命令模式下，可以使用:Ag [options] {pattern} [{directory}]搜索了。 majutsushi/tagbar安装 vim 插键之前，机器本身需要ctags：123456# ubuntusudo apt-get install ctags# centossudo yum install ctags# macbrew install ctags 在这时使用 vim-tagbar 插件可以帮你快速了解当前文件中的类、方法等。1Plugin &apos;majutsushi/tagbar&apos; &quot; https://github.com/majutsushi/tagbar 配置：1nmap &lt;F8&gt; :TagbarToggle&lt;CR&gt; 关于 tagbar 的使用，看查看这篇文章 wklken-大纲式导航 YouCompleteMe目前主要涉及的是 Python 开发，所以，YCM 目前没有配置，如下仅供参考。1Plugin &apos;Valloric/YouCompleteMe&apos; 123456sudo apt-get install build-essential cmakesudo apt-get install python-dev python3-devcd ~/.vim/bundle/YouCompleteMe./install.py --allcp ~/.vim/bundle/YouCompleteMe/third_party/ycmd/examples/.ycm_extra_conf.py ~/.vim/ 123&quot;YouCompleteMe配置相关let g:ycm_server_python_interpreter=&apos;/usr/bin/python&apos;let g:ycm_global_ycm_extra_conf=&apos;~/.vim/.ycm_extra_conf.py&apos; 主题安装主题的方法比较简单，例如需要安装molokai主题，手动安装则按照如下步骤操作： 从 https://github.com/fatih/molokai 下载molokai.vim文件，放入~/.vim/colors中 然后在~/.vimrc文件中加入行colorscheme molokai即可。 因为我在 VSCode 和 Iterm2 中都采用了 Dracula 的主题，因此，vim 主题我也同样偏爱它，可以采用插键的方式安装：12Plugin &apos;dracula/vim&apos;:PluginInstall 然后在~/.vimrc文件中加入行colorscheme dracula即可。 主题相关的命令： 123:colorscheme &quot;查看当前主题:colorscheme space tab &quot;列出所有主题:colorscheme your-theme &quot;切换主题 设置vim为了让vim使用起来更加得心应手，先做一些简单的配置。 编辑VIM配置文件，可能一开始没有这个文件，不过没关系，直接vi ~/.vimrc保存这个文件即可。 今天学习到&lt;leader&gt; 这个概念，很强大，快捷键很方便！ nnoremap 将一个组合快捷键映射为另一个快捷键。 关于leader以及其他map知识，可以查看如下文章： 提高 Vim 使用效率的 12 个技巧 【Vim】使用map自定义快捷键 个人vim配置参考多人的配置，打造属于自己的Vim配置，这个配置不涉及插件的设置，因为常常生产环境是网络不通的，要迅速配置能用：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647let mapleader=&quot;,&quot; &quot; 设置 leaderlet g:mapleader = &apos;,&apos;&quot; 分屏窗口移动, Smart way to move between windowsmap &lt;C-j&gt; &lt;C-W&gt;jmap &lt;C-k&gt; &lt;C-W&gt;kmap &lt;C-h&gt; &lt;C-W&gt;hmap &lt;C-l&gt; &lt;C-W&gt;l&quot; Go to home and end using capitalized directions&quot; H和L跳转到行首行末, 实在不想按0和$, 太远noremap H ^noremap L $&quot; 命令行模式增强，ctrl - a到行首， -e 到行尾cnoremap &lt;C-a&gt; &lt;Home&gt;cnoremap &lt;C-e&gt; &lt;End&gt;&quot; 去掉搜索高亮noremap &lt;silent&gt;&lt;leader&gt;/ :nohls&lt;CR&gt;&quot; 快速保存和退出&quot; Quickly close the current windownnoremap &lt;leader&gt;q :q&lt;CR&gt;&quot; Quickly save the current filennoremap &lt;leader&gt;w :w&lt;CR&gt;syntax on &quot; 自动语法高亮set cursorline &quot; 突出显示当前行set encoding=utf-8set fileencoding=utf-8set fileformat=unix &quot;从Win上复制文件时，避免换行符错误set hlsearch &quot; 搜索时高亮显示被找到的文本set ignorecase smartcase &quot; 搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感set incsearch &quot; 输入搜索内容时就显示搜索结果set laststatus=2 &quot; 显示状态栏 (默认值为 1, 无法显示状态栏)set magic &quot; 设置魔术set nocompatible &quot; 关闭 vi 兼容模式set number &quot; 显示行号set paste &quot; 解决拷贝的时遇到注释会自动注释后续所有行的问题set ruler &quot; 打开状态栏标尺set shiftwidth=4 &quot; 设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 4set softtabstop=4 &quot; 使得按退格键时可以一次删掉 4 个空格set smartindent &quot; 开启新行时使用智能自动缩进set tabstop=4 &quot; 设定 tab 长度为 4set ambiwidth=double &quot; 设置为双字宽显示，否则无法完整显示如:☆ vim配置文件中的注释，末尾用&quot;隔开即可。保留注释，对于了解配置内容有利。 vim配置参考 Michael728/my-config-files 个人总结的配置文件 wklken/k-vim Mac OS X 配置指南-vim 同时也有关于 macOS 介绍 强大的vim配置文件，让编程更随意 有vim配置的中文注释 FAQ1. github访问速度慢，下载插件失败 ubuntu上解决访问github慢的方法 2. mac上iterm2中, tmux里面鼠标复制, 无法选中一行内容然后你会发现你想复制terminal上的东西的时候，死活复制不了，这时按住 Option (Alt)键就行了。 ubuntu tmux复制粘贴总结 参考 pytlab-优雅的在终端中编写Python 同时介绍了 Tmux 和 Vim 的配置 那些离了就活不了的 VIM 插件 介绍了一些经典的插键 阮一峰-Vim 配置入门 YouCompleteMe 安装配置方法 知乎-Vim 8.0 正式发布 提到了 Vim 编译安装的一些好教程]]></content>
      <categories>
        <category>ToolsDev</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Vim</tag>
        <tag>Plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用教程笔记]]></title>
    <url>%2F2018%2F11%2F24%2Fgit-advance%2F</url>
    <content type="text"><![CDATA[虽然之前写过一篇入门文章Git入门私房菜，但是工作中接触到的 Git 命令还有一些。有时候遇到一些小功能，就上网查一下，本文就针对用到的知识点做个全面的总结。 需要先在 Github 上创建个属于你的仓库，本文仓库名以 michalel-git 为例。 地址为： `git@github.com:Michael728/michael-git.git` Git 安装Git下载地址 Windows安装时需要注意在Configuring the line ending conversions界面，选择Checkout as-is,commit as -s，避免Windows的换行符问题。如果忘记设置，可以使用如下命令后期设置： 1git config --global core.autocrlf false 参考： GitHub 第一坑：换行符自动转换 Git 配置可以通过 git config -l 查看配置。 设置 Git 账号12git config --global user.name &quot;michael728&quot;git config --global user.email &quot;649168982@qq.com&quot; Git 配置别名git config文件来轻松为每一个命令设置别名。例如： 1234git config --global alias.co checkoutgit config --global alias.br branchgit config --global alias.ci commitgit config --global alias.st status 如果你想要执行外包命令，而不是一个 Git 子命令，可以在命令前面加 ！ 符号。 演示将git visual定义为gitk的别名： 1git config --global alias.visual &apos;!gitk&apos; 设置命令的别名，可以提高操作效率。查看.gitconfig文件vim ~/.gitconfig： 123456789101112131415161718192021222324[user] name = xxx email = xxx[i18n] commitencoding = utf-8 logoutputencoding = utf-8[core] quotepath = false[filter &quot;lfs&quot;] clean = git-lfs clean -- %f smudge = git-lfs smudge -- %f process = git-lfs filter-process required = true[alias] co = checkout br = branch c = commit s = status unstage = reset HEAD -- last = log -1 HEAD lg = log --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit --date=relative[color] ui = true 我们可以体验一个log的别名命令设置： 1lg = log --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit --date=relative 这是超厉害的别名缩写命令，试试现在的 git lg 有多酷炫吧！ Git 帮助文档授人以鱼不如授人以渔，先知道怎么通过帮助文档查看常用命令的说明吧： 12git helpgit help &lt;cmd&gt; 创建 Git 本地仓库已有远端仓库，创建本地仓库123456git clone git@github.com:Michael728/michael-git.gitcd michael-gittouch README.mdgit add README.mdgit commit -m &quot;add README&quot;git push -u origin master 已存在文件夹123456cd micahel-gitgit initgit remote add origin git@github.com:Michael728/michael-git.gitgit add .git commitgit push -u origin master 已存在 Git 仓库1234cd existing_repogit remote add origin git@github.com:Michael728/michael-git.gitgit push -u origin --all # --all 表示 Push all branches，-u 选项指定了一个默认主机git push -u origin --tags # --tags All refs under refs/tags are pushed 将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。 参考： git push 的 -u 参数具体适合含义？ Git远程操作详解 git clone1git clone [-b br_name] url git@github.com:Michael728/michael-git.git 克隆的时候，可以指定下载远端的分支、自定义本地仓库的名字。如果不加分支名参数，git clone 命令会默认自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（其实是仓库的默认分支）。而且，默认远程仓库设置别名为 origin。 git add这是个多功能命令: 可以用它开始跟踪新文件 把已跟踪的文件放到暂存区 还能用于合并时把有冲突的文件标记为已解决状态，这个是在解决冲突时会用到的功能 git commit提交的操作，当你前面采用add命令将文件添加到暂存区跟踪后，需要通过commit将暂存区的内容提交到当前分支。 1git commit -m &quot;test&quot; 当一些已追踪的文件修改了，常常需要git add file，然后在git commit -m &quot;xxxx&quot;，其实这两个步骤可以合二为一：1git commit -am &quot;test&quot; 这么写个人觉得挺好，可以有效避免有些懒人git add .的方式，将一切文件都添加到了暂存区，导致最后多余文件提交入库。 git push语法： 1git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。 当想要将master分支推送到origin服务器上： 1git push origin master 将本地分支test推送到远端时可以重命名： 1git push origin test:remote-test 利用该用法，还可以推送空分支到远端，实现远端分支的删除： 123git push origin :remote-test# 和如下命令等同git push origin --delete remote-test git rm从 Git 中移除某个文件，就必须从已跟踪的文件清单中删除（从暂存区域移除文件），然后提交。可以使用git rm命令完成此项工作，并连带从工作目录中删除指定的文件。 当我们先把某文件从 Git 库中删除（亦即从暂存区移除），但仍然希望保留在当前工作目录中。比如当你忘记在.gitignore文件中将一些文件忽略，但是却不小心把大的日志文件添加到暂存区域时，这一做法很有用： 12# --cached 将 README 文件从暂存区移除，但是工作区目录仍然保留git rm --cached README git checkout切换到某个历史版本： 1git checkout &lt;commit id&gt; 在 Git 中从当前分支创建并检出新分支的命令是： 1git checkout -b new-br 这个命令实际是： 1git checkout -b new-br current-br 在本地创建并切换到远端的分支： 12git branch -va # 查看本地+远程分支列表git checkout -b dev origin/dev 还可以可以在checkout命令中使用Hash值作为起点创建分支： 1git checkout -b name-of-branch &lt;commit id&gt; 除了有“切换”的意思，checkout还有一个撤销的作用。 举个例子，假设我们在一个分支开发一个小功能，刚写完一半，这时候需求变了，而且是大变化，之前写的代码完全用不了，好在你刚写，甚至都没有 git add 进暂存区，这个时候很简单的一个操作就直接把原文件还原： 1git checkout &lt;filename&gt; 参考：在git中checkout历史版本 git log1git log --pretty=oneline # 检查提交日志，都在一行：&lt;commit id&gt; &lt;message&gt; 查看某人的提交： 1git log --author=michael 一个常用的选项是-p，用来显示每次提交的内容差异，也可以加上-2或者-n2来仅显示最近两次提交： 12git log -p -2git log -n1 --format=format:%h # 查看当前分支最新的 commit id 缩略值 列出最近两周内的提交： 1git log --since=2.weeks git log命令全解析，打log还能这么随心所欲！ git-scm 2.3 Git 基础 - 查看提交历史 git diffgit diff本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 若要查看已暂存的将要添加到下次提交里的内容和上次提交的内容的变化，可以用git diff --staged git branch新建develop分支：1git branch develop 切换分支：复习一下checkout的用法 1git checkout develop 新建并切换到develop分支：1git checkout -b develop 将分支develop推送到远程仓库origin：1git push origin develop 如果想给远程的分支取名为develop2，可以：1git push origin develop:develop2 不建议这么操作易混乱，还是本地分支名和远程分支名保持一致比较好。 关联本地分支和远程分支：创建本地分支并切换到分支：git checkout -b tools-dev 创建远程分支：git push origin tools-dev 本地分支推送到远程服务器时，远程分支自动创建，推送本地分支到远程： 1git push --set-upstream &lt;remote-name&gt; &lt;local-branch-name&gt;:&lt;remote-branch-name&gt; &lt;remote-name&gt;：远程 Git 服务器名称，一般为origin &lt;local-branch-name&gt;：本地分支名称 &lt;remote-branch-name&gt;：远程分支名称 一般情况下，本地分支和远程分支名称相同，所以可简化为： 1git push --set-upstream &lt;remote-name&gt; &lt;branch-name&gt; --set-upstream参数用来关联本地分支和远程分支 参考： Git创建远程分支 Git远程操作详解 查看本地分支：1git branch 查看远程分支：1git branch -r 删除本地分支：12git branch -d developgit branch -D develop（强制删除） 删除远程分支：123git push origin :remote-test# 和如下命令等同git push origin --delete remote-test 撤销操作1git commit --amend 如果已经提交完了（已经commit）了，发现漏掉几个文件没有添加，或者提交信息（-m)写错了，可以运行带有--amend选项的提交命令重新提交。 这个命令会将暂存区的文件提交。文本编辑器编辑后，会覆盖原来的提交信息。 取消暂存文件1git reset HEAD &lt;file&gt; 撤销对文件的修改1git checkout -- &lt;file&gt; 你需要知道 git checkout -- [file] 是一个危险的命令，这很重要. 远程仓库的使用查看远程仓库1git remote -v 如果想查看远程仓库更多的信息，可以使用git remote show &lt;remote-name&gt;命令。 远程仓库的移除与重命名 12git remote rename &lt;old-remote-name&gt; &lt;new-remote-name&gt;git remote rename pb paul 如果因为一些原因要移除一个远程仓库，可以使用git remote rm &lt;remote-name&gt;。 添加一个新的远程 Git 仓库，同时指定一个可以轻松引用的简写：1git remote add &lt;remote-name&gt; &lt;url&gt; 这里的remote-name常常取名为origin。所以，常见的origin其实是一个你 Git 仓库跟踪的远程仓库的简写。 拉取远端仓库有但你本地没有的信息：1git fetch &lt;remote-name&gt; 如果你使用clone命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以origin为缩写。 Tag列出标签12git tag # 列出所有标签git tag -l &apos;v1.8*&apos; # 列出以 v1.8 开头的所有标签 创建标签Git使用两种主要类型的标签： 附注（annotated）标签 轻量（ightweight）标签 前者会包括一些注释信息，来进一步解释这个 tag 的作用，而后者就仅仅只是一个 tag 的名字 附注标签1git tag -a v1.4 -m &apos;my version 1.4&apos; 通过git show &lt;tag-name&gt;命令可以看到标签信息 轻量标签1git tag v1.4 没用-a、-m的参数，只需要提供标签名字 删除标签1git tag -d &lt;tagname&gt; 补打标签假设忘记给项目打标签，可以在之后加上：基于某历史节点的commit id补打Tag： 1git tag -a v1.2 &lt;commit id&gt; 共享标签默认情况下，git push命令并不会传送标签到远程服务器上。在创建完标签后你必须显示地推送标签到共享服务器上。这个过程就像共享远程分支一样，可以运行git push origin [tagname] 如果想要一次性推送很多标签，也可以使用--tags选项的git push： 1git push origin --tags 检出标签1git checkout -b &lt;new-br&gt; &lt;tagname&gt; 参考： The Junior Git 6 Git 基础 - 打标签 使用场景新特性开发，创建临时分支，再合并到主干123456789#创建特性分支git checkout -b featureA……#提交之前，先checkout到master分支，更新一下git co mastergit pull#切到特性分支，在本地与最新的master分支合并git co featureAgit rebase -i master 参考： 聊下git rebase -i 本地仓库关联远程仓库：已有本地仓库，需要关联远端仓库，分两步：第一步，在Github上新建一个仓库test；第二步：将本地仓库与Github上的test项目进行关联，切换到本地仓库目录：git remote add origin git@github.com:xx/test.git什么意思？远程仓库的地址为：`git@github.com:xx/test.git`，而origin是给这项目的远程仓库起的名字，是的，名字你可以随便取，只不过大家公认的只有一个远程仓库时名字就是origin，为什么要给远程仓库取名字？因为我们可能一个项目有多个远程仓库，比如，Github一个，比如公司一个，这样的话，提交的时候可以提交到不同的远程仓库就需要指定不同的仓库名字了。 查看我们当前项目有哪些远程仓库可以执行如下命令： 1git remote -v 接下来，本地的仓库可以向远程仓库进行代码提交了： 1git push origin master 在代码提交之前，西安设置自己的用户名和邮箱，这些信息会出现在所有的commit记录里： 12git config --global user.name &quot;xxx&quot;git config --global user.email &quot;xx@mail.com&quot; 二分查找，傻瓜式定位bug场景：定位Bug，当前版本有Bug，上个版本没有，两个版本之前有上千次commit二分查找，N个patch只需要测试log2N次（8k个path仅需测试13次）可以实现测试自动化，自动查找问题patchgit bisect：自动定位，不必找原作者 同时负责多个Bug的修改 更新远程仓库代码 1git fetch 以origin/master为基础创建分支 1git checkout -b fix/bug23 origin/master 修改完 1git commit 推送前更新一下代码，看看别人是否有修改 1git fetch 有修改的话rebase一下 1git rebase origin/master 生成patch 1git format-patch origin/master 发送patch或者也可以使用request pull 12send email OR Request pull[maintainer接收后] 分支使用已经完成，可以删除了 1git branch -D fix/bug23 想知道某行代码谁修改的阅读代码时，想知道某行代码是谁修改的？ 找到对应commit id 1git blame src/xxx.c 查看具体提交的内容 1git show &lt;commit id&gt; 远端仓库会退到历史版本 查找commit id通过git log查找想要会退到的历史版本的commit id 本地执行回退 1git reset --hard [commit id] 强制推送 1git push -f 参考：git 远程仓库版本的回退以及git reset 几种常用方式记录 突然插入bugifx，回退工作目录git stash保存所有工作内容 cherry-pick将某一提交点的修改拿到当前分支上：git cherry-pick 哈希值 基本的团队协作流程多人协作下的分支管理规范很重要，就跟代码规范一样重要。 以下就跟大家推荐一种我们内部在使用的一种分支管理流程 Git Flow。 Gti FlowGit Flow 是一种比较成熟的分支管理流程，我们先看一张图能清晰的描述他整个的工作流程： 大部分情况下都会拥有两个分支 master 和 develop，他们的职责分别是: master：永远处在即将发布(production-ready)状态 develop：最新的开发状态 确切的说 master、develop 分支大部分情况下都会保持一致，只有在上线前的测试阶段develop 比 master 的代码要多，一旦测试没问题，准备发布了，这时候会将 develop 合并到master 上。 但是，我们发布之后又会进行下一版本的功能开发，开发中间可能又会遇到需要紧急修复 bug，一个功能开发完成之后突然需求变动了等情况，所以 Git Flow 除了以上 master 和 develop两个主要分支以外，还提出了以下三个辅助分支： feature: 开发新功能的分支, 基于 develop, 完成后 merge 回 develop release: 准备要发布版本的分支, 用来修复 bug，基于 develop，完成后 merge 回develop 和 master hotfix: 修复 master 上的问题, 等不及 release 版本就必须马上上线. 基于 master, 完成后merge 回 master 和 develop 什么意思呢？举个例子，假设我们已经有 master 和 develop 两个分支了，这个时候我们准备做一个功能A，第一步我们要做的，就是基于 develop 分支新建个分支： 1git branch feature/A 看到了吧，其实就是一个规范，规定了所有开发的功能分支都以 feature 为前缀。但是这个时候做着做着发现线上有一个紧急的 bug 需要修复，那赶紧停下手头的工作，立刻切换到 master 分支，然后再此基础上新建一个分支： 1git branch hotfix/B 代表新建了一个紧急修复分支，修复完成之后直接合并到 develop 和 master ，然后发布。然后再切回我们的 feature/A 分支继续着我们的开发，如果开发完了，那么合并回 develop 分支，然后在 develop 分支属于测试环境，跟后端对接并且测试的差不多了，感觉可以发布到正式环境了，这个时候再新建一个 release 分支： 1git branch release/1.0 这个时候所有的 api、数据等都是正式环境，然后在这个分支上进行最后的测试，发现 bug 直接进行修改，直到测试 ok 达到了发布的标准，最后把该分支合并到 develop 和 master 然后进行发布。 以上就是 Git Flow 的概念与大概流程，看起来很复杂，但是对于人数比较多的团队协作现实开发中确实会遇到这么复杂的情况，是目前很流行的一套分支管理流程，但是有人会问每次都要各种操作，合并来合并去，有点麻烦，哈哈，这点 Git Flow 早就想到了，为此还专门推出了一个 Git Flow 的工具，并且是开源的： GitHub 开源地址： https://github.com/nvie/gitflow 简单点来说，就是这个工具帮我们省下了很多步骤，比如我们当前处于 master 分支，如果想要开发一个新的功能，第一步切换到 develop 分支，第二步新建一个以 feature 开头的分支名，有了 Git Flow 直接如下操作完成了： 1git flow feature start A 这个分支完成之后，需要合并到 develop 分支，然而直接进行如下操作就行： 1git flow feature finish A 如果是 hotfix 或者 release 分支甚至会自动帮你合并到 develop、master 两个分支。 想必大家已经了解了这个工具的具体作用，具体安装与用法我就不多提了，感兴趣的可以看我下我之前写过的一篇博客： http://stormzhang.com/git/2014/01/29/git-flow/ 详细演示下怎么给一个项目发起 Pull Request(PR)： 第一步，找到你想发起 PR 的项目，点击右上角的 Fork 按钮，然后该项目就出现在了你自己账号的 Repository 里。 第二步，把fork的项目 clone 到本地，然后修改的 bug 也好，想要新增的功能也好，总之把自己做的代码改动开发完，接着，把自己做的代码改动 push 到 你自己的 GitHub 上去。 第三步，点击你 Fork 过来的项目主页的 Pull requests 页面，点击右上角的New pull request。页面自动会比较该项目与原有项目的不同之处，最顶部声明了是源仓库的分支与你fork过来的分支的对比。同样的我写好标题和描述，然后我们点击中间的 Create pull request 按钮，至此我们就成功给该项目提交了一个 PR。然后就等着项目原作者 review 你的代码，并且决定会不会接受你的 PR，如果接受，那么恭喜你，你已经是该项目的贡献者之一了。 Git FAQgit merge和git rebase的区别12git checkout mastergit merge featureA 其实 rebase 命令也是合并的意思，上面的需求我们一样可以如下操作： 12git checkout mastergit rebase featureA rebase 跟 merge 的区别你们可以理解成有两个书架，你需要把两个书架的书整理到一起去，第一种做法是 merge ，比较粗鲁暴力，就直接腾出一块地方把另一个书架的书全部放进去，虽然暴力，但是这种做法你可以知道哪些书是来自另一个书架的；第二种做法就是rebase ，他会把两个书架的书先进行比较，按照购书的时间来给他重新排序，然后重新放置好，这样做的好处就是合并之后的书架看起来很有逻辑，但是你很难清晰的知道哪些书来自哪个书架的。 只能说各有好处的，不同的团队根据不同的需要以及不同的习惯来选择就好。 rebase 和 merge的另一个区别是rebase 的冲突是一个一个解决，如果有十个冲突，先解决第一个，然后用命令 12git add -ugit rebase --continue 继续后才会出现第二个冲突，直到所有冲突解决完，而merge 是所有的冲突都会显示出来。另外如果rebase过程中，你想中途退出，恢复rebase前的代码则可以用命令 1git rebase --abort 关于git rebase还有很多知识点： 聊下git rebase -i git merge 和 git rebase 小结 Git Community Book 中文版-rebase 压缩多个Commit 合并多个 Commit git branch -r与git branch -a的区别？ git branch -r只显示远端分支， git branch -a 显示本地分支和远程分支 发现好用的开源项目-GithubGitHub 其中一个最重要的作用就是发现全世界最优秀的开源项目，你没事的时候刷刷微博、知乎，人家没事的时候刷刷 GitHub ，看看最近有哪些流行的项目，久而久之，这差距就越来越大，那么如何发现优秀的开源项目呢？ 关注一些活跃的大牛 Explore菜单下的Trending，看到最近的一些热门开源项目，很多人主动获取开源项目的最好的途径，可以选择“当天热门”，“一周之内热门”和“一月之内热门”来查看，并且，可以分语言来查看。 Search，按照Most Stars来筛选。 除此之外，GitHub 的 Search 还有一些小技巧，比如你想搜索的结果中 star 数大于1000的，那么可以这样搜索：android http stars:&gt;1000 有些人如果习惯用 Google 进行搜索，那么想搜索 GitHub 上的结果，不妨前面加 GitHub 关键字就ok了，比如我在 google 里输入 GitHub android http ，每个关键字用空格隔开。 福利大放送GitHub 上影响力很大，同时又对你们很有用的项目： free-programming-books: 这个项目整理了所有跟编程相关的免费书籍，而且全球多国语言版的都有，中文版的在这里 free-programming-books-zh ob-my-zsh: 俗话说，不会用 shell 的程序员不是真正的程序员。oh-my-zsh 毫无疑问就是目前最流行，最酷炫的 shell awesome: GitHub 上有各种 awesome 系列，简单来说就是这个系列搜罗整理了 GitHub 上各领域的资源大汇总，比如有 awesome-android, awesome-ios, awesome-java, awesome-python 等等等，就不截图了，你们自行去感受。 github-cheat-sheet: GitHub 的使用有各种技巧，只不过基本的就够我们用了，但是如果你对 GitHub 超级感兴趣，想更多的了解 GitHub 的使用技巧，那么这个项目就刚好是你需要的，每个 GitHub 粉都应该知道这个项目。 LearningNotes：这是一份非常详细的面试资料，涉及 Android、Java、设计模式、算法等等等，你能想到的，你不能想到的基本都包含了，可以说是适应于任何准备面试的 Android 开发者，看完这个之后别说你还不知道怎么面试！ GitHub 上优秀开源项目真的是一大堆，就不一一推荐了，授人以鱼不如授人以渔，请大家自行主动发掘自己需要的开源项目吧，不管是应用在实际项目上，还是对源码的学习，都是提升自己工作效率与技能的很重要的一个渠道，总有一天，你会突然意识到，原来不知不觉你已经走了这么远！ 最后 Git使用教程笔记 Pro Git 中文 Git常用命令备忘]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【笔记】快速上手 Linux，玩转典型应用]]></title>
    <url>%2F2018%2F11%2F18%2Fnote-linux-basic-system%2F</url>
    <content type="text"><![CDATA[工作近1年多，真正转来开发这边还没7个月，很多基础都不扎实，看了个视频课程，做做笔记： 概要 详细链接]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Linux</tag>
        <tag>System</tag>
        <tag>Mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【计划】阅读]]></title>
    <url>%2F2018%2F11%2F16%2Fplan-reading%2F</url>
    <content type="text"><![CDATA[Reading Great Code 文章中提到了，要想变成更优秀的程序员，需要去阅读、理解和欣赏优秀的代码。可见，阅读的重要性。 那我就给想要阅读的书籍列个清单，督促一下自己吧： 2018技术 Python Cookbook-在线中文版 非技术 黑客与画家]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Plan</tag>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【总结】写作、阅读、工作等日常积累]]></title>
    <url>%2F2018%2F11%2F16%2Fhabit-writing-reading-working%2F</url>
    <content type="text"><![CDATA[习惯是在习惯中养成的。 本文主要介绍一些平日里在生活、工作当中一些看到的值得学习的习惯以及个人的一些经验想法总结等，会长期更新。 写作 写作的时候在中文和英文之间加空格，来源 除非是完整的英文句子，否则按照全局语言使用中文标点 中文各数字之间需要增加空格，来源 数字各单位之间需要增加空，例如SSD 一共有 20 TB 全形标点各其他字符之间不加空格，例如 我买了一部新 iPhone，还行 ✔️ 正确 我买了一部新 iPhone ，还行 ❎ 错误 千万不要同时用段首缩排和段间距 来源 目前大陆用的是弯引号，而台湾、香港用的是直角引号。对引号的使用使用方式也有所区别，大陆是先用双引号“ ”，内部如需再引用，再用单引号‘’，在香港和台湾都规定的是先用单引号「」，内部如需要引用，再用双引号『』 来源 []：内的内容意思是：可写可不写; {}：那就必须要在{}内给出的选择里选一个; &lt;&gt;：表示必选 来源 阅读 学习不一定要一大段时间，可以挤时间。 碎片时间不能碎片学习，要碎片化时间系统化学习。 看书不一定要背住，不管记不记得住，要坚持看！无法清晰记住的，将来也会变成「隐性记忆」。 好书多读几遍，读纸质书，细度时做好笔记、划出重点；一个月后，扫读；半年后，忆读。 以上内容，参考自infoQ-佛系程序员的月薪五万指南 专注 有一个明确的目标、易于实现的小目标，将有助于专注的高效率的完成一件小事。 只设定一个「优先级最高德事」，其他所有事情不再重要，只集中精力做一件事！ 「2/8」原则，可能有80%的事情都没那么重要，只需投入20%的时间，而剩下的20%的重要事情，则需要投入80%的时间。 来源：如何集中精力 早起 要适应早起，首先要明确早起的目的，要知道第二天的行动清单，最重要的几件事 准备好一杯水，让你保持清醒，而不是回到床上 坚持每天同一时间起床，形成生物钟 早起，慢慢养成一个一个好的习惯 感悟 「难的事情你不去做，那你的价值能够体现在哪儿？」–油管-吴晓波专访京东创始人 刘强东《十年二十人》 「纠结就是窝里斗，嫉妒就是对自己不满 ​​​​」– 网络]]></content>
      <categories>
        <category>Habit</category>
      </categories>
      <tags>
        <tag>Habit</tag>
        <tag>Writing</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些做的不错的广告视频]]></title>
    <url>%2F2018%2F11%2F11%2Fvideo-demo%2F</url>
    <content type="text"><![CDATA[需要做的仅仅是超越昨日的自己！ 20181111-【Nike - Dream Crazy】 20181227- 西方餐桌礼仪 How to improve your etiquette manners[doge] 一个将西方餐桌礼仪正确、错误行为对比的小视频]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Video</tag>
        <tag>广告</tag>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打造性感好用的VS Code编辑器]]></title>
    <url>%2F2018%2F10%2F28%2Ftools-vscode%2F</url>
    <content type="text"><![CDATA[官网： https://code.visualstudio.com/ 主命令框F1或Ctrl+Shift+P: 打开命令面板。在打开的输入框内，可以输入任何命令，例如： 按一下 Backspace会进入到 Ctrl+P 模式 在Ctrl+P下输入&gt;可以进入Ctrl+Shift+P模式 在 Ctrl+P 窗口下还可以: 直接输入文件名，跳转到文件 ?列出当前可执行的动作 !显示 Errors或 Warnings，也可以Ctrl+Shift+M :跳转到行数，也可以 Ctrl+G 直接进入 @跳转到symbol（搜索变量或者函数），也可以 Ctrl+Shift+O 直接进入 @根据分类跳转symbol，查找属性或函数，也可以 Ctrl+Shift+O 后输入:进入 #根据名字查找 symbol，也可以 Ctrl+T 常用快捷键编辑器与窗口管理 打开一个新窗口： Ctrl+Shift+N 关闭窗口： Ctrl+Shift+W 同时打开多个编辑器（查看多个文件） 切出一个新的编辑器（最多 3 个） Ctrl+\，也可以按住 Ctrl 鼠标点击 Explorer 里的文件名 左中右 3 个编辑器的快捷键 Ctrl+1 Ctrl+2 Ctrl+3 编辑器换位置， Ctrl+k然后按 Left或 Right 代码编辑格式调整 对python文件进行代码格式化操作时，会提示安装autopep8 代码格式化： Shift+Alt+F，或 Ctrl+Shift+P 后输入 format code 代码行缩进: Ctrl+[ 、 Ctrl+] 在当前行下边插入一行 Ctrl+Enter 在当前行上方插入一行 Ctrl+Shift+Enter 上下移动一行： Alt+Up 或 Alt+Down 向上向下复制一行： Shift+Alt+Up 或 Shift+Alt+Down 光标相关 移动到定义处： F12 定义处缩略图：只看一眼而不跳转过去:Alt+F12 移动到文件结尾： Ctrl+End 移动到文件开头： Ctrl+Home 下面两个功能和alt+↑/↓配合，很方便的移动代码块： 选择从光标到行尾：Shift+End 选择从行首到光标处： Shift+Home 这两个功能很爽，可以同时编辑一些变量名： 多行编辑(列编辑)：Ctrl+Alt+Down/Up或者Alt+Shift+鼠标左键， 同时选中所有匹配： Ctrl+Shift+L Ctrl+D 下一个匹配的也被选中 (在 sublime 中是删除当前行，后面自定义快键键中，设置与 Ctrl+Shift+K 互换了) 回退上一个光标操作： Ctrl+U 删除光标右侧的所有字： Ctrl+Delete 扩展/缩小选取范围： Shift+Alt+Left 和 Shift+Alt+Right 移动到后半个括号： Ctrl+Shift+] 重构代码 查看函数引用和批量休修改函数名，好用： 重命名：比如要修改一个方法名，可以选中后按 F2，输入新的名字，回车，会发现所有的文件都修改了 找到所有的引用： Shift+F12 同时修改本文件中所有匹配的： Ctrl+F12 跳转到下一个 Error 或 Warning：当有多个错误时可以按 F8逐个跳转 查看 diff： 在 explorer 里选择文件右键 Set file to compare，然后需要对比的文件上右键选择 Compare with file_name_you_chose 查找替换 查找:Ctrl+F 查找替换:Ctrl+H 整个文件夹中查找:Ctrl+Shift+F 显示相关 全屏：F11 zoomIn/zoomOut：Ctrl +/- 侧边栏显/隐：Ctrl+B 显示资源管理器:Ctrl+Shift+E 显示搜索:Ctrl+Shift+F 显示 Git:Ctrl+Shift+G 显示 Debug:Ctrl+Shift+D 显示 Output:Ctrl+Shift+U 其他自动保存：File -&gt; AutoSave ，或者 Ctrl+Shift+P，输入 auto VS Code 中文注释显示乱码怎么办？https://www.zhihu.com/question/34415763/answer/60444047将设置中的”files.autoGuessEncoding”项的值改为true即可。 我的配置12345678910111213141516171819202122232425262728&#123; &quot;workbench.iconTheme&quot;: &quot;vscode-icons&quot;, &quot;files.autoSave&quot;: &quot;onWindowChange&quot;, // 设置保存时，自动将Python代码的一些空格给trim掉； &quot;files.trimTrailingWhitespace&quot;: true, // 将一些编译后而不想在编辑器里看到的文件隐藏； &quot;files.exclude&quot;: &#123; &quot;.vs*&quot;: true, &quot;*.*~&quot;: true, &quot;*.pyc&quot;: true, &quot;*/*.pyc&quot;: true &#125;, &quot;terminal.integrated.rendererType&quot;: &quot;dom&quot;, &quot;terminal.integrated.shell.windows&quot;: &quot;C:\\Program Files\\Git\\bin\\bash.exe&quot;, &quot;python.formatting.autopep8Args&quot;: [ &quot;--max-line-length=100&quot; ], &quot;editor.formatOnSave&quot;: true, &quot;python.linting.pylintEnabled&quot;: true, &quot;python.linting.pylintArgs&quot;: [ &quot;--include-naming-hint=n&quot;, &quot;--disable=W0311&quot;, &quot;--disable=C0103&quot;, &quot;--disable=E1101&quot; ], &quot;files.eol&quot;: &quot;\n&quot;, &quot;editor.wordWrap&quot;: &quot;on&quot;&#125; 常用扩展VS Code扩展商店：https://marketplace.visualstudio.com/vscode 主题可以来主题商城选择： 切换主题的快捷键：ctrl+k,ctrl+t One Dark Pro Atom One Dark FlatUI Material Icon Theme: 图标主题 vscode-icons VSCode Great Icons Dracula Official：主题，推荐 bookmarks：ctrl+alt+l快速跳转，图标设置 开发扩展 AutoFileNmae:auto complete file name，自动补全文件的名字 code runner:ctrl+alt+n Guides:显示代码对其辅助线 gitlens:显示代码每一行的最新修改人 Beautify:显示js/json/css美化，按F1 Prettier - Code formatter Path Intellisense: 路径匹配 Auto Rename Tag：自动修改标签 Color Highlight:写csss时，颜色值会增加对应的颜色背景显示 Vetur：VUE扩展 open in browser:alt+b选择浏览器预览文件 Rainbow Brackets：有颜色的显示括号匹配 Settings Sync: 同步配置 下面介绍一下怎么设置同步：ctrl+shift+p，输入sync，会看到相关选项，选择update/upload settings，然后会输入https://github.com/settings/tokens中设置的key。具体的用法，Settings Sync的扩展主页介绍的很详细了：https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync FAQ如何设置中文界面 设置中文界面 Microsoft/vscode-tips-and-tricks language-pack 参考 Visual Studio Code 简明使用教程-w3cschool Microsoft Visual Studio Code 中文手册 VS Code 配置 VSCode配置备忘 Getting Started with Python in VS Code Visual Studio Code初探 使用Python virtualenv时如何设置VS code 学会用好 Visual Studio Code]]></content>
      <categories>
        <category>ToolsDev</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 安装 CICD 利器 Jenkins]]></title>
    <url>%2F2018%2F10%2F11%2Fcicd-jenkins-01%2F</url>
    <content type="text"><![CDATA[环境准备安装JDK安装Oracle JDK Jenkins 自身采用 Java 开发，所以要必须安装 JDK； 博客园-Linux安装JDK 1234export JAVA_HOME=/usr/java/jdk1.8.0_171export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 创建软连接： 1ln -s /usr/local/java/jdk1.8.0_171/bin/java /usr/bin/java 注意：Java版本不能是gcj，会导致Jenkins有问题，centos7搭建jenkins小记文章中提到的java版本问题导致CentOS下的Jenkins有问题。 安装openjdk的方法1yum -y install java-1.8.0-openjdk java-1.8.0-openjdk-devel 参考： Centos7安装OpenJDK8 OpenJDK官网 安装Git1yum install git 规避磁盘过满问题1.方法1：创建软连接，准备较大空间 /data挂在了较大空间，然后在其中创建相关目录： 12mkdir -p /data/jenkinsln -s /data/jenkins/ /var/lib/jenkins 2.方法2：丢弃构建 设置构建最大保留天数或者保留个数，实现自动删除构建结果。 参考： Jenkins服务器磁盘空间管理策略 CentOS离线安装-推荐1234## http://pkg.jenkins-ci.org/redhat-stable/wget http://pkg.jenkins-ci.org/redhat/jenkins-2.39-1.1.noarch.rpm ## 下载(也可以Windows下载再转过来)sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key ## 导入公钥，发现离线安装，不需要导入公钥就能安装rpm -ih jenkins-2.7.2-1.1.noarch.rpm 自动安装完成之后： /usr/lib/jenkins/jenkins.war WAR包 /etc/sysconfig/jenkins 配置文件 /var/lib/jenkins/ 默认的JENKINS_HOME目录 /var/log/jenkins/jenkins.log Jenkins日志文件 启动Jenkins: 12sudo systemctl enable jenkins # 开机自启动Jenkinssudo systemctl start jenkins # 启动Jenkins 查看服务细节： 1systemctl status jenkins.service 验证Jenkins Server访问链接： 1telnet &lt;ip&gt; 8080 如果访问有问题，需要把防火墙关了： 12systemctl stop firewalldsystemctl disable firewalld.service #重启不自动开启 通过如下两个命令查看防火墙是否关闭： 12systemctl list-unit-files|grep firewalld.serviceiptables -t nat -S 在线安装1234567# 添加Jenkins源sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.reposudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.keyyum repolist # Update your package manager list to get the latest packages# 安装yum install java-1.8.0-openjdk jenkinsservice jenkins start # 启动 基于Tomcat安装 在Tomcat官网下载tar包 将tar包拷贝至/usr/local目录并解压：cd /usr/local/ &amp;&amp; tar zxvf apache-tomcat-9.0.12.tar.gz 访问jenkins官网下载长期维护版本的jenkins.war拷贝至/usr/local/apache-tomcat-9.0.12/webapps，启动tomcat：cd /usr/local/apache-tomcat-9.0.12 访问：http://ip:8080/jenkins 管理员密码访问：1cat /root/.jenkins/secrets/initialAdminPassword 基于这种方式安装的Jenkins位置处于/root/.jenkins，因此，为了避免Job占用空间过大，需要执行如下命令创建软连接： 1ln -s /data/jenkins_jobs/ /root/.jenkins/jobs Jenkins设置为了不因为权限出现各种问题，这里直接使用root 123## sudo vim /etc/sysconfig/jenkinsJENKINS_USER=&quot;root&quot; ## 原值 &quot;jenkins&quot; 必须修改，否则权限不足JENKINS_PORT=&quot;8080&quot; ## 原值 &quot;8080&quot; 可以不修改 修改目录权限 123chown -R root:root /var/lib/jenkinschown -R root:root /var/cache/jenkinschown -R root:root /var/log/jenkins Centos安装参考： How to install Jenkins on CentOS 7 Jenkins 持续集成综合实战 CentOS 7 安装 Jenkins-提到配置权限 以root用户运行jenkins中shell命令 CentOS 安装 Jenkins ken的杂谈-CentOS 7 下Jenkins安装部署教程 Ubuntu 下载https://pkg.jenkins.io/debian/jenkins.io.key apt-key add jenkins.io.key 以上两步，可以合二为一： 1wget -q -O - https://pkg.jenkins.io/debian/jenkins-ci.org.key | sudo apt-key add - sh -c &#39;echo deb http://pkg.jenkins.io/debian-stable binary/ &gt; /etc/apt/sources.list.d/jenkins.list&#39; apt-get update apt-get install jenkins /etc/init.d/jenkins start。或者service start jenkins。启动Jenkins。 通过：http://{ip}:8080 访问jenkins。 cat /var/lib/jenkins/secrets/initialAdminPassword得到默认密码填入下面的密码框中 安装好之后，可以修改相关配置改变默认端口： /etc/default/jenkins Ubuntu安装参考： how to change port number for Jenkins installation In Ubuntu 12.04 How to install Jenkins on Ubuntu 16.04 Jenkins master优化增加同时打开文件句柄数增加同时打开文件句柄数，linux默认一个进程能同时打开的文件句柄是1024个，在jenkins master肯定是不够的，需要调整成65535 CentOS系统，修改/etc/security/limits.conf，在文件最后增加一行: 1root - nofile 65535 重启后生效，可以通过命令ulimit -a查看 设置tomcat 日志循环，限制日志的大小https://stackoverflow.com/questions/8342336/how-to-set-maximum-number-of-rolls-and-maximum-log-size-for-tomcat Jenkisn配置Jenkins用户admin账号初始密码： 1cat /var/lib/jenkins/secrets/initialAdminPassword Jenkins使用 – 用户设置 Jenkins使用Jenkins关闭、重启、重载http://localhost:8080/[exit/restart/reload] 参考： Jenkins的关闭、重启 Ubuntu 16安装、配置Jenkins实践 Jenkins Job指定执行节点 关联job，进入job的配置页面，勾选Restrict where this project can be run 利用了标签的功能 参考： Jenkins使用教程之管理节点 Jenkins升级可以通过系统管理(System management)–&gt; 系统信息(System Info)查找.war的文件 1executable-war /usr/lib/jenkins/jenkins.war 先列出官网地址：https://jenkins.io/download/ 升级之前，停止Jenkins服务（记得备份原来的jenkins.war，以防万一） 1http://jenkinsIP:port/exit 从官网下载最新的war包，然后替换掉上面路径下的war。 替换完成后，重启： 12systecmctl start jenkins # centosservice jenkins start # ubunutu 参考： Jenkins技巧：如何更新Jenkins到最新版本 Jenkins插件 dashboard view：Dashboard-view自定义jenkins任务集视图 Workspace Cleanup Plugin：这个插件可以再每次build之前清空workspace Monitoring：监控一些机器的状态信息了 Folders View：新建任务时，支持创建文件夹。 SSH Slaves：添加节点时，可以采用SSH方式链接； PostBuildScript：根据 Build 状态执行脚本 Post Build Task Pipeline：必须 【请勾选】 Build Pipeline Plugin：用于创建pipline视图 Configuration Slicing：主要功能是可以批量设置job的属性，比如设置保留多少天的构建记录，神器之一，有效解决Jenkins磁盘过满的问题 Multijob plugin：配置Multijob必备的插件； Timestamper Build Timeout plugin：构建超时插件 Folders：可嵌套地定义文件夹来级别 views / jobs Custom Tools Plugin Git plugin：Git插件 【请勾选】 Git Parameter GitLab Gitlab Hook Plugin Gitlab Authentication plugin Node and Label parameter plugin Publish Over SSH Groovy plugins：并发任务解决 Windows Slaves Plugin：连接Windows Slaves，默认安装了 Matrix Authorization Strategy Plugin：矩阵形式认证策略插件，默认安装了 插件使用参考： jenkins常用一些插件 thoughtworks-第二话：Jenkins必备插件安装 Jenkins常用插件介绍 小团队持续集成之实践【6】 - Jenkins - 安装与插件篇 Jenkins持续集成平台搭建 Jenkins SlaveSlave机器上需要安装好git、配置好Java环境（尤其是一些类似JAVA_HOME的变量）。 通过SSH连接node–推荐 先安装SSH Slaves插件，这样在新增节点时，ssh配置将更加友好。 点击 Credentials， 点击 Jenkins -&gt; Global credentials -&gt; Add Credentials，Username 和 Password 表示执行机的账号和密码。 新建节点，「启动方式」 选择 Launch slave agents via SSH。Credentials 选择刚刚新建的钥匙，Host Key Verification Strategy 选择 Manually trusted Key Verification Stragegy。 最后Launch agent即可； 通过JNLP连接node该方法比较麻烦，不详细介绍了。 注意：需要下载两个文件到agent机器上： agent.jar slave-agent.jnlp 参考： 两种常见挂载Jenkins slave节点的方法 Jenkins : 安装 master 和 slave Jenkins FAQQ1: 忽略Jenkins升级提醒对于轻微强迫症的我来说，看着升级提醒，还不能叉掉，实在忍不了，Google之后，有解决方法： 1234Manage Jenkins =&gt; Configure System =&gt; Administrative monitors configuration系统管理-》系统设置-》管理监控配置去掉“Jenkins更新通知”UnCheck &quot;Jenkins Update Notification&quot; and apply How to disable displaying “New version of Jenkins (2.62) is available for download (changelog)”? Q2: Cannot run program “java”: error=2, No such file or directory虽然登录到master机器或者执行机上，java都配置好了，但是仍然遇到了错误，后来看到一篇博客中提到的方法，在usr/bin下创建了一个Java的软连接，就解决了。 1ln -s /usr/java/jdk1.8.0_171/bin/java /usr/bin enkins cannot run program mvn error 2 - No such file or directory Posted by Echo Yuan on July 2 Q3: jenkins.JenkinsException: Error in request. Possibly authentication failed [500]: Internal Server Error在JJB项目中，发生了上面的错误，定位问题了半天，发现可能是Jenkins本身出问题了，而不是项目出问题。以前运行OK的Jenkins怎么突然发生这个问题了呢？可能是如下原因造成： var/lib/jenkins/jobs：目录下Job占据过多空间。在Jenkins中的节点管理里查看master机器的剩余磁盘空间`也可以观察到。 1du -ah --max-depth=1 /etc/rc.local是啥？ 参考： 【Jenkins学习 】解决jenkins运行磁盘满的问题 Q4: starting jenkins bash /usr/bin/java permission denied解决办法主要分了两步： 将原本位于/root/buildbox/javaxxx/下的目录移到了/usr/java/下，重新配置java环境； 在vim /etc/init.d/jenkins中的candidates字段补充上java路径/usr/java/jdk1.8.0_151/bin/java。 参考： Jenkins在Linux下的安装与配置 启动jenkins服务错误 Jenkins fails when running “service start jenkins” Q5: 执行Jenkins服务器界面运行一段时间后就会卡死，界面显示空白原因：tomcat的日志（/home/apache-tomcat-8.0.30/logs）查看catalina.out日志，得知是java虚拟机内存空间溢出。解决：到后台tomcat的bin目录下，修改 tomcat的启动脚本：startup.sh，在最上面添加 export JAVA_OPTS=“-XX:MaxPermSize=1024m -Xms1024m -Xmx3096m” Q6: 构建完成后需要清除workspace需要安装“Workspace Cleanup Plugin插件”，在构建任务配置时，可以在“增加构建后操作步骤”中选择Delete workspace when build is done Q7: Linux环境变量问题，没有加载/etc/profile文件，获取不到需要的环境变量。添加节点时，Prefix Start Slave Command 选择输入 source /etc/profile &amp;&amp; 加一个前置动作。注意&amp;&amp;之后要有空格！！！ Q8：Jenkins定时构建用法Jenkins定时构建 原文链接 CICD-Jenkins搭建笔记一]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
        <tag>Jenkins</tag>
        <tag>CICD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些有趣的博客]]></title>
    <url>%2F2018%2F09%2F16%2Fblog-interesting%2F</url>
    <content type="text"><![CDATA[总有一些博主是勤奋总结的，比公众号要有营养的多，这里列个清单吧： Python国内 Python之禅 卡瓦邦噶 SRE TaoBeier-moelove CICD wklken 刘江的博客 David Dai 小戴，扇贝网后端工程师，Python 和 Go 栖迟于一丘 对 Python 相关源码进行了分析 忘归 Python 和 Go 美图 莫凡Python 除了机器学习方面，还有 Linux 方面总结 国外 kennethreitz requests 库的作者 RealPython 一个国外的 Python 学习网站，分享一下有趣的 Tricks lepture-Japan Full Stack Python life is short - you need Python 主要介绍了 Python 一些小技巧，卡片式展示 doughellmann 知名python程序员，博客涵盖大量库 [The Invent with Python Blog](https://inventwithpython.com/blog/ Paul Ganssle python-dateutil 的作者 JamesDjango 核心团队的成员 The Standard Python Library Python 标准模块的介绍 DevOps Vnimos’s blog-OpenStack DevOps 博主介绍了很多这方面的文章 杜屹东的博客-好像是一位专门从事 DevOps 的前辈，从他博客中一篇文章，突然理解了 DevOps 的「含义」 Web 晚晴幽草 geekplux 后端开发 Nicol 一个喜欢总结，朝架构师方向努力的开发者 Linux 骏马金龙 LINUX大棚 海底苍鹰(tank) 金步国作品集 这个博主记载了一些 Linux 的文章，算比较老，但是比较经典 安全 安全-nMask 数学 谢益辉-RStudio Matrix67-数学爱好者 ML 谭升-AI pytlab-计算化学 运维 海底苍鹰 张文兵博客 设计 丁宇 一个在日本工作的中国设计师，博客挺有趣 综合 dirtysalt D大 龙哥盟 图拉鼎 无聊小博 心理学 刘未鹏-mindhacks 艺术 易 象 辞 道卬 参考 栖迟于一丘-整理、分享]]></content>
      <categories>
        <category>Habit</category>
      </categories>
      <tags>
        <tag>资源</tag>
        <tag>Blog</tag>
        <tag>博客</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GitBook+Github编写文档书籍]]></title>
    <url>%2F2018%2F09%2F08%2Ftools-gitbook-hackpythonista-notebook%2F</url>
    <content type="text"><![CDATA[Books are to mankind what memory is to the individuanl. 书之于人类，犹如记忆于之个人。 最近看到了python-web-guide这样的文档以及explore python，觉得知识体系还是用这种方式全面组织比较系统一点，因此，放假在家也搞一下gitbook吧！ 欢迎访问我的第一本GitBook-HackPythonista，目前内容有待丰富，囧 鉴于已有相当多的文档介绍了Git，本文仅做简要笔记，同时记录一下遇到的坑。 gitbook基本使用 全局安装 gitbook 1sudo npm install gitbook-cli -g 安装完成，执行gitbook -V查看版本信息； gitbook常用命令 12345678910111213gitbook init //初始化目录文件gitbook help //列出gitbook所有的命令gitbook --help //输出gitbook-cli的帮助信息gitbook build //生成静态网页gitbook serve //生成静态网页并运行服务器gitbook build --gitbook=2.0.1 //生成时指定gitbook的版本, 本地没有会先下载gitbook ls //列出本地所有的gitbook版本gitbook ls-remote //列出远程可用的gitbook版本gitbook fetch 标签/版本号 //安装对应的gitbook版本gitbook update //更新到gitbook的最新版本gitbook uninstall 2.0.1 //卸载对应的gitbook版本gitbook build --log=debug //指定log的级别gitbook builid --debug //输出错误信息 与github集成，参考文章chengweiBlog-GitHub 集成 安装gitbook插键，参考文章chengweiBlog-book.json 在书籍根目录创建book.json:1234567891011121314151617181920212223&#123; &quot;gitbook&quot;: &quot;3.2.3&quot;, &quot;language&quot;: &quot;zh&quot;, &quot;description&quot;: &quot;Michael翔技术栈NoteBook&quot;, &quot;plugins&quot;: [ &quot;disqus@0.1.0&quot;, &quot;anchor-navigation-ex&quot;, &quot;-lunr&quot;, &quot;-search&quot;, &quot;search-pro-kui&quot; ], &quot;pluginsConfig&quot;: &#123; &quot;disqus&quot;: &#123; &quot;shortName&quot;: &quot;HackPythonista&quot; &#125;, &quot;anchor-navigation-ex&quot;: &#123; &quot;isShowTocTitleIcon&quot;: true, &quot;tocLevel1Icon&quot;: &quot;fa fa-hand-o-right&quot;, &quot;tocLevel2Icon&quot;: &quot;fa fa-hand-o-right&quot;, &quot;tocLevel3Icon&quot;: &quot;fa fa-hand-o-right&quot; &#125; &#125;&#125; gitbook插键disqus插键按照前面参考文章安装disqus插键时，使用命令npm install gitbook-plugin-disqus会默认安装disqus的最新版本，然后hexo serve时，就会报错： 123info: loading plugin &quot;disqus&quot;... ERRORError: GitBook doesn&apos;t satisfy the requirements of this plugin: &gt;=4.0.0-alpha 想要尝试升级gitbook的版本，通过gitbook ls-remote查看可以安装的版本，然后利用gitbook fetch 4.0.0-alpha.6安装，尽管我用gitbook uninstall 3.2.3卸载了旧版本，安装之后不明白为何还是使用的3.2.3的稳定版本，后来用尝试创建软连接解决依然存在问题，没继续升级gitbook版本； 查看disqus-plugin文档没有解决，查看disqus项目issue，有人给出了答案，“1.0.1”版本需要gitbook的版本”&gt;=4.0.0-alpha”，可以通过&quot;plugins&quot;: [&quot;disqus@0.1.0&quot;]的方式，指定安装旧版本的disqus插键解决这个问题。 后来看到disqus插键官网文档，发现明明有写这些的，自己没注意到，文档多重要： 我们也可以通过@符号来指定插件的版本号，如：”plugins1@0.1.1“, 这个特性在使用一个旧版本的gitbook时是非常有用的 PSnpm安装指定版本：1npm install jquery@3.0.0 如果加上-g参数，表示安装到全局目录中 参考 gitbook的使用和常用插件 npm 安装指定版本 用github写开源书籍 zhangjikai-更多插件介绍 gitbook-plugin-anchor-navigation-ex]]></content>
      <categories>
        <category>ToolsDev</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Gitbook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作中常用的 Linux 命令]]></title>
    <url>%2F2018%2F07%2F05%2Flinux-useful-commands-in-work%2F</url>
    <content type="text"><![CDATA[awk示例： env变量值如下，需要获得pkg_url的链接值： 1&#123;&quot;name&quot;: &quot;michael&quot;, &quot;sex&quot;: &quot;male&quot;, &quot;pkg_url&quot;: &quot;www.github.com&quot;, &quot;number&quot;: &quot;888&quot;&#125; 123pkg_url=$(echo $env | awk -F &quot;pkg_url\&quot;: \&quot;&quot; &apos;&#123;print $2&#125;&apos; | awk -F &quot;\&quot;,&quot; &apos;&#123;print $1&#125;&apos;)echo $pkg_urlwww.github.com -F 指定分隔规则，因为分隔规则中包含了双引号，所以需要用转义符号。 1234567# 格式$ awk 动作 文件名# 示例$ awk &apos;&#123;print $0&#125;&apos; demo.txtecho &apos;hello:michael:xiang&apos;|awk -F &apos;:&apos; &apos;&#123;print $1&#125;&apos; awk print函数 printf+awk完美结合 AWK 简明教程 awk 入门教程 basenamebasename命令用于打印目录或者文件的基本名称 1234[root@HGH1000059721 test]# basename a.tar .tar #后缀：可选参数，指定要去除的文件后缀字符串。a[root@HGH1000059721 test]# basename /tmp/test/a.tar #不带后缀，获取文件名a.tar 参考： basename cp将目录src复制到dest目录下，复制好后，dest/src: 1cp -r src dest 将目录src下的内容复制到dest目录下： 1cp -r src/* dest 复制文件，覆盖不询问： 1cp -nrf a.txt b.txt 系统默认给cp命令设置了别名cp -i，所以，复制时有冲突需要确认，使用如下方式即可不改变别名，也实现默认覆盖：1/bin/cp xx yy 参考： Linux命令详解之—cp命令 Linux命令命令大全-cp命令 Linux 使用 cp 命令强制覆盖功能 crontab12345678910# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed 在以上各个字段中，还可以使用以下特殊字符： 星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。 逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9” 中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6” 正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。 任务执行文件所在位置：1/var/spool/cron/crontabs 命令参数： -u user：用来设定某个用户的crontab服务；file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入 -e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。 -l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。 -r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。 -i：在删除用户的crontab文件时给确认提示 每隔2分钟执行/tmp/test.sh脚本：12crontab -e # 使用crontab -e命令，编辑的是/var/spool/cron下对应用户的 cron 文件*/2 * * * * /tmp/test.sh 第星期六、星期日的时10分重启smb-也就是每周六、周日：110 1 * * 6,0 /etc/init.d/smb restart &gt;&gt; /tmp/run.log 2&gt;&amp;1 实例4：每隔两天的上午8点到11点的第3和第15分钟执行：13,15 8-11 */2 * * myCommand 实例5：清理httpd服务日志超过3天的内容：10 5 * * * /usr/bin/find /var/log/httpd/ -type f -mtime +3 -exec rm -rf &#123;&#125; \; 实例6：通过正则清理指定文件夹的内容12#update-20181122: clean dir +120 days0 6 * * * find /data/michael -maxdepth 7 -type d -mtime +120 -regextype posix-egrep -regex &apos;.*/[0-9]&#123;2&#125;/[0-9]&#123;6&#125;$&apos; -exec rm -rf &#123;&#125; \; 启动 / 停止 / 重启 crontab123$ /etc/init.d/crond start$ /etc/init.d/crond stop$ /etc/init.d/crond restart 查看日志1$ tail -f /var/log/cron 参考： 如何查看crontab的日志记录 runoob-Linux Crontab 定时任务 LinuxTools-crontab 定时任务 推荐 每天一个linux命令（50）：crontab命令 date选项：不加: 显示当前的时间.-d &lt;字符串&gt;：显示字符串所指的日期与时间。字符串前后必须加上双引号；-s &lt;字符串&gt;：根据字符串来设置日期与时间。字符串前后必须加上双引号；-u：显示GMT；–help：在线帮助；–version：显示版本信息。 参数 &lt;+时间日期格式&gt;：指定显示时使用的日期时间格式。就是格式化字符串处理.当需要用到空格时要使用双引号,如&quot;+%Y-%m-%d %H:%M:%S&quot;. 一般,%Y %m %d %H %M %S 是最基本的. 使用星期月份时也会用到%a %b 示例1234VERSION=$(date +%Y%m%d%H%M%S) #20180410192702 #date后面有空格time=$(date &quot;+%Y-%m-%d %H:%M:%S&quot;) #时间格式中有空格，需要加引号» date &quot;+%Y-%m-%d %T %a %A&quot;2018-06-04 11:31:25 Mon Monday 参考： Shell中date命令用法 df通过df命令很容易发现那个磁盘的存储空间快没了。查看挂载状态和硬盘使用量信息：1df -hT digdig 和 nslookup 作用有些类似，都是DNS查询工具。dig，其实是一个缩写，即 Domain Information Groper。 查看域名的信息。一般一个域名都会绑定到多个 IP 上，ping 命令只能一次看到一个 ip，这个可以看到域名解析的信息。1dig baidu.com 可能机器上没有这个命令，可以如下方式安装：1yum install -y bind-utils 参考： 《dig挖出DNS的秘密》-linux命令五分钟系列之三十四 Linux 大棚 xindoo-csdn-我常用的一些linux命令 dudu命令可以显示某个特定目录（默认情况下是当前目录）的磁盘使用情况。这一方法可以判断系统上某个目录下是不是有超大的文件。 查看当前文件夹的文件大小：12du -sh *du -sh /usr/* | sort -rn # 按M大小排序 env查看环境变量值，例：查看带有SVN的环境变量值：1env|grep SVN find实例：定时清理httpd服务日志超过3天的内容： 10 5 * * * /usr/bin/find /var/log/httpd/ -type f -mtime +3 -exec rm -rf &#123;&#125; \; 实例： 通过正则清理指定文件夹的内容12#update-20181122: clean dir +120 days0 6 * * * find /data/michael -maxdepth 7 -type d -mtime +120 -regextype posix-egrep -regex &apos;.*/[0-9]&#123;2&#125;/[0-9]&#123;6&#125;$&apos; -exec rm -rf &#123;&#125; \; 实例：搜索/etc目录下第一层的conf配置文件，文件夹下层的不需要1find /etc/ -maxdepth 1 -name &quot;*.conf&quot; # 最好加上引号 实例：只搜索当前目录，但是不包括.git目录，统计目录数1find . -maxdepth 1 -mindepth 1 -type d | grep -v .git |wc -l 实例：仅列出目录1find . -type d -maxdepth 1 参考： Linux中find常见用法示例 FIND中正则表达式的使用-Linux中find命令基本使用方法 fdiskfdisk -l看到目前系统中所有分区的信息https://blog.csdn.net/cc_net/article/details/2894510 freefree命令可以显示Linux系统中空闲的、已用的物理内存及swap内存,及被内核使用的buffer。在Linux系统监控的工具中，free命令是最经常使用的命令之一。 1free -h -s 2 -t -h 单位会更人性化 -s 每2秒，显示内存使用信息 -t 显示内存总和 12345# 结果 total used free shared buff/cache availableMem: 7.6G 935M 6.1G 9.7M 631M 6.4GSwap: 7.5G 0B 7.5GTotal: 15G 935M 13G total:总计物理内存的大小。 used:已使用多大。 free:可用有多少。 Shared:多个进程共享的内存总额。 Buffers/cached:磁盘缓存的大小 交换分区SWAP，也就是我们通常所说的虚拟内存 从应用程序角度来看，对于应用程序来说，buffers/cached 是等于可用的，因为buffer/cached 是为了提高文件读取的性能，当应用程序需在用到内存的时候，buffer/cached 会很快地被回收。 所以从应用程序的角度来说 可用内存=系统free memory+buffers+cached 我们看linux,只要不用swap的交换空间,就不用担心自己的内存太少.如果常常swap用很多,可能你就要考虑加物理内存了.这也是linux看内存是否够用的标准. +buffers/cache,即对应用程序来说free的内存太少了，也是该考虑优化程序或加内存了 参考： 每天一个linux命令（45）：free 命令 fuserfuser通常被用在诊断系统的“resource busy”问题，通常是在你希望umount指定的挂载点得时候遇到。 如果你希望kill所有正在使用某一指定的file, file system or sockets的进程的时候，你可以使用-k option1fuser –k –i /path/to/your/filename # 加上-i 表示杀死之前，需确认 fuser命令 fuser 命令小结 groups12whoami # 查看用户名groups # 查看当前用户所属组 grep语法：1grep [options] pattern [file] 12# 递归、显示行号、忽略大小写、显示搜到的匹配内容上下2行 搜索范围是当前目录下grep -rni &apos;github.com&apos; -C 2 . 12grep &apos;shopbase&apos; /home/admin -r -n --include *.&#123;vm,java&#125; #指定文件后缀grep &apos;shopbase&apos; /home/admin -r -n --exclude *.&#123;vm,java&#125; #反匹配 参考： man-grep Linux查找文件内容（grep） 每天一个linux命令（39）：grep 命令 我的java问题排查工具单 gzipgzip是GNU项目的产物。这个软件下买呢含有下面的工具： gzip ：用来压缩文件 gzcat：用来查看压缩过的文本文件的内容 gunzip:用来解压文件。 12gzip xxxgzip -l &lt;filename&gt; # list compressed file contents head显示前n行内容：1head -n https://www.linuxdaxue.com/linux-command-intro-head.html less在more的时候，我们并没有办法向前面翻，只能往后面看，但若使用了less时，就可以使用 [pageup] [pagedown] 等按键的功能来往前往后翻看文件。 locate12locate GPG-KEY# find /etc -name &apos;*GPG-KEY*&apos; 等同 可能系统没有自带locate命令，可以使用yum install mlocate -y安装，安装结束执行updatedb命令。 ls仅显示目录：1ll -d ls命令显示文件大小，会根据文件大小自己决定单位，M或者Kb或者G1ll -h mountmount可以显示全部挂载情况。 将分区挂载到目录： 1mount /dev/xvde /data Linux mount命令 mkdirmkdir sysadmin/admim_{1,2,3,4,5} 参考： 在Linux中用chattr和lsattr命令管理文件和目录属性 netstat检查端口占用 1netstat -anp|grep 80 linux(redhat,centos)释放被占用端口 rm只删除当前文件夹下的隐藏文件和隐藏文件夹：1rm -rf .* https://blog.csdn.net/ficksong/article/details/52447729 rpm我的系统中安装了那些rpm软件包1rpm -qa 如果要查找所有安装过的包含某个字符串sql的软件包1rpm -qa | grep sql 一个rpm包中的文件安装到那里去了？1rpm -ql 包名 软件包的卸载1rpm -e 参考：http://man.linuxde.net/rpm rpm2cpioRPM 包解压缩：12# 注意，要加上 cpio -div，否则终端会打印多余的内容出来rpm2cpio xxxx.rpm | cpio -div 你的 Linux 下可能没有rpm2cpio这个命令，用过简单指令安装即可： 12sudo apt-get install rpm2cpiosudo yum install rpm2cpio sedeg1：截取日志中的两行之间的内容，同时去掉匹配的首尾行：1cat mock.log |sed -n &apos;/tee/,/find/p&apos; mock.log|sed -n &apos;1!p&apos;|sed -n &apos;$!p&apos;|awk &apos;&#123;print $2,$3&#125;&apos; eg2:1nl passwd|sed &quot;1d;10d&quot; #删除第1行，第10行 eg3:12sed -i -e &quot;1i%define upstream_version $UPSTREAMVERSION\\&quot; *.spec #第一行插入sed -i -e &quot;s/UPSTREAMVERSION/$UPSTREAMVERSION/g&quot; *.spec #替换 参考： SED 简明教程 sed、awk——运维必须掌握的两个工具 看例子学sed 三十分钟学会SED sed命令筛选指定字符串之间的行 SELinux12sestatus [-v] # 查看selinux开启状态getenforce # 查看当前selinux的状态 selinux开启常常影响其他一些服务，比如httpd等，所以，运维往往一般拿到机器就会默认将其关闭。 12setenforce 1 # 设置SELinux 成为enforcing模式setenforce 0 # 设置SELinux 成为permissive模式 不重启关闭selinux的解决办法 开机重启后，上面利用setenforce方式修改的值会失效，所以，开机重启也有效的话，需要修改如下文件： 1/etc/selinux/config # 文件的软链接是/etc/sysconfig/selinux 是 wiki-SELinux Linux 下为何要关闭 SELinux？ 如何开启或关闭SELinux SELinux开启与关闭各参数说明 sort对之前提到的密码文件/etc/passwd根据用户ID进行数值排序。-k和-t参数在对安字段分割的数据进行排序时非常有用。1sort -t &quot;:&quot; -k 3 -n /etc/passwd systemctl 任务 旧指令 新指令 使某服务自动启动 chkconfig –level 3 httpd on systemctl enable httpd.service 使某服务不自动启动 chkconfig –level 3 httpd off systemctl disable httpd.service 检查服务状态 service httpd status systemctl status httpd.service 显示所有已启动的服务 chkconfig –list systemctl list-units –type=service 启动某服务 service httpd start systemctl start httpd.service 停止某服务 service httpd stop systemctl stop httpd.service 重启某服务 service httpd restart systemctl restart httpd.service Linux 设置程序开机自启动 （命令systemctl 和 chkconfig用法区别比较） sha256sum生成文件对应的sha256值： 12sha256sum FusionSphere_Upgrade_6.2.50.4001.tar.gz &gt; a.sha256sum # 校验sha256sum -c &lt;(grep FusionSphere_Upgrade_6.2.50.4001.tar.gz a.sha256sum) # 校验 参考： linux下生成sha256校验文件、使用sha256校验某个文件 tar目前Unix和Linux上最广泛使用的归档工具是 tar 命令。 1tar function [options] object1 object2 …… 首先，创建一个归档文件： 1tar -cvf test.tar test/ test2/ 创建了名为test.tar归档文件，含有 test 和 test2 目录内容。 接着，列出 tar 文件 test.tar 内容（但并不提取文件）： 1tar -tf test.tar 最后用命令提取文件： 1tar -xvzf test.tar tar命令是给整个目录创建归档文件的简便方法 窍门：下载开源软件之后，经常会看到文件名以.tgz结尾。这些事gzip压缩过的tar文件，可以用tar -zxvf filename.tgz来解压 teetee命令用于将数据重定向到文件，另一方面还可以提供一份重定向数据的副本作为后续命令的stdin。简单的说就是把数据重定向到给定文件和屏幕上。 eg1 在终端打印stdout同时重定向到文件中： 1ls | tee out.txt | cat -n eg2 创建daemon.json文件，EOF之间内容作为stdin： 12345tee /etc/docker/daemon.json &lt;&lt; EOF&#123; &quot;insecure-registries&quot; : [ &quot;&quot;, &quot;&quot;]&#125;EOF &lt;&lt; EOF …… EOF的作用是在命令执行过程中用户自定义输入，它类似于起到一个临时文件的作用，只是比使用文件更方便灵活。 EOF妙用： 它的作用就是将两个delimiter之间的内容(Here Document Content 部分) 传递给cmd 作为输入参数。 123cmd &lt;&lt; delimiter Here Document Contentdelimiter 12345[root@ecs-6b86 tmp]# cat &lt;&lt; EOF &gt;tt.sh123123123345345asdfasdsEOF 自定义EOF，比如自定义为michael[root@slave-server opt]# cat &lt;&lt; michael &gt; haha.txt ggggggg44444446666666michael &lt;&lt; 变为 &lt;&lt;-。 使用 &lt;&lt;- 的唯一变化就是Here Document 的内容部分每行前面的 tab (制表符)将会被删除掉，这种用法是为了编写Here Document的时候可以将内容部分进行缩进，方便阅读代码。 有时脚本内容里变量不想被系统环境变量替换掉，可以通过在起始的 delimiter的前后添加 “ 来实现 参考： linux shell 的here document 用法 (cat &lt;&lt; EOF) EOF是什么？ linux shell脚本EOF妙用 tree1tree -FCL 2 FusionUpgrade linux tree命令–显示目录的树形结构 time12345678time nslookup michael.comnslookup: can&apos;t resolve &apos;(null)&apos;: Name does not resolveName: micahel.comAddress 1: 10.248.250.158real 0m 5.00suser 0m 0.00ssys 0m 0.00s time test 判断字符串是否为空，可以通过help test查看 1234-z STRING True if string is empty.-n STRING STRING True if string is not empty. 示例： 12345678910111213#!/bin/shSTRING=&quot;&quot;# -zif [ -z &quot;$STRING&quot; ]; then echo &quot;STRING is empty&quot;fiif [ -n &quot;$STRING&quot; ]; then echo &quot;STRING is not empty&quot;fi# STRING is empty linux shell 中判断字符串为空的正确方法：有趣的示例，强调了需要加引号的重要性 Linux shell 编程 字符串null值 的 条件判断?：解释了，为何加引号，bash的内建命令test在只有一个参数的情况下，只要参数不为空就返回真 tcpdump首先，先用 tcpdump -D 命令列出可以抓包的网络接口：123456789101112$ tcpdump -D1.virbr02.docker03.bluetooth0 (Bluetooth adapter number 0)4.nflog (Linux netfilter log (NFLOG) interface)5.nfqueue (Linux netfilter queue (NFQUEUE) interface)6.usbmon1 (USB bus number 1)7.usbmon2 (USB bus number 2)8.wlp3s09.enp5s010.any (Pseudo-device that captures on all interfaces)11.lo [Loopback] 其中， lo 就是 localhost 。其中特殊接口 any 可用于抓取所有活动的网络接口的数据包。 123456789101112$ sudo tcpdump -i any -c5 -nn icmp port 80 -A -w webserver.pcaptcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes22:10:51.809330 IP 192.168.3.43.22 &gt; 192.168.3.66.50051: Flags [P.], seq 2040167007:2040167203, ack 59350146, win 1432, options [nop,nop,TS val 89942170 ecr 111122685], length 19622:10:51.812472 IP 192.168.3.43.22 &gt; 192.168.3.66.50051: Flags [P.], seq 196:416, ack 1, win 1432, options [nop,nop,TS val 89942173 ecr 111122685], length 22022:10:51.833093 IP 192.168.3.66.50051 &gt; 192.168.3.43.22: Flags [.], ack 0, win 23490, options [nop,nop,TS val 111123121 ecr 89942122], length 022:10:51.833193 IP 192.168.3.43.22 &gt; 192.168.3.66.50051: Flags [P.], seq 416:612, ack 1, win 1432, options [nop,nop,TS val 89942194 ecr 111123121], length 19622:10:51.835541 IP 192.168.3.66.50051 &gt; 192.168.3.43.22: Flags [.], ack 196, win 23487, options [nop,nop,TS val 111123121 ecr 89942170], length 05 packets captured7 packets received by filter0 packets dropped by kernel -c 选项可以用于限制 tcpdump 抓包的数量 用 -n 选项显示 IP 地址，-nn 选项显示端口号 icmp 这里用作过滤条件，只要抓取 ICMP 报文 port 指定端口号，根据端口号来筛选数据包 tcpdump 提供了两个选项可以查看数据包内容，-X 以十六进制打印出数据报文内容，-A 打印数据报文的 ASCII 值 使用 -w 选项来保存数据包而不是在屏幕上显示出抓取的数据包 tcpdump 将数据包保存在二进制文件中，所以不能简单的用文本编辑器去打开它。使用 -r 选项参数来阅读该文件中的报文内容：1tcpdump -nn -r webserver.pcap 用 host 参数只抓取和特定主机相关的数据包：1sudo tcpdump -i any -c5 -nn host 54.204.39.132 可以使用括号来创建更为复杂的过滤规则，但在 shell 中请用引号包含你的过滤规则以防止被识别为 shell 表达式：1$ sudo tcpdump -i any -c5 -nn &quot;port 80 and (src 192.168.122.98 or src 54.204.39.132)&quot; src 抓取源 IP 地址 使用 dst 就是按目的 IP/主机名来筛选数据包 使用 and 以及 or 逻辑操作符来创建过滤规则 参考： 伯乐在线-在 Linux 命令行中使用 tcpdump 抓包 运维之路-NAS存储抓包分析 Huang-tcpdump 常用操作 Tcpdump入门教程示例 9个tcpdump使用实例 unzip1unzip -l demo1-0.1-py2.7.egg 1unzip -o -d /home/sunny myfile.zip 把myfile.zip文件解压到 /home/sunny/-o:不提示的情况下覆盖文件；-d:-d /home/sunny 指明将文件解压缩到/home/sunny目录下； 参考： Linux下的压缩（zip）解压(unzip)缩命令 unzip命令 wc1wc [-clw][--help][--version][文件...] 参数：12345-c或--bytes或--chars 只显示Bytes数。-l或--lines 只显示行数。-w或--words 只显示字数。--help 在线帮助。--version 显示版本信息。 whowho //显示当前登录系统的用户显示标题栏1# who -H 只显示当前用户1# who -m -H wget将远程目录下的全部内容下载到save目录下。-nd参数表示，如果远程目录下也有子目录，会将子目录中的文件下载下来而不创建多余目录。 1wget -r -np -nd -R &quot;index.html*&quot; -P test http://xxx/FusionUpgrade/master/euler/20181101130551/ # 注意，URL末尾需要有/，否则会递归下载的 -r：递归下载，下载指定网页某一目录下（包括子目录）的所有文件 -nd:–-no-directories 不创建目录 -np：–-no-parent 不要追溯到父目录 P:指定下载下来的存放目录，没有会自动创建 -nH:–-no-host-directories 不创建主机目录 示例2： 将远程文件夹原封不动下载下来，并且下载下来的本地路径也是远程目录，而不会创建多级目录。-nH表示不会创建xxx.com目录，--cut-dirs将其余多余层级目录不下载，实现效果下载到本地就只是DLRN_RPMS目录。1wget -r -p -k -np -nH --cut-dirs=4 http://xxx.com/cps/FusionNetwork-for-fc/master/suse/DLRN_RPMS/ 参考： wget 文件下载 wget wget递归下载文件 watch123watch -d &apos;ls -l|grep scf&apos; # 监测当前目录中 scf&apos; 的文件的变化watch -n 10 &apos;cat /proc/loadavg&apos; # 10秒一次输出系统的平均负载watch -n 1 -d netstat -ant # 命令：每隔一秒高亮显示网络链接数的变化情况 参考： watch-命令 systemd service服务 Systemd 入门教程：命令篇 xargs为了快速修改后缀名字 源文件夹下： 12CentOS-base.repo.repo.bakepel.repo.repo.bak 方法一： 1ls *.bak|awk -F. '&#123;print $1&#125;'|xargs -t -i mv &#123;&#125;.repo.repo.bak &#123;&#125;.repo]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zsh+on-my-zsh配置教程指南（程序员必备）]]></title>
    <url>%2F2018%2F03%2F11%2Ftools-zsh-tutorial%2F</url>
    <content type="text"><![CDATA[本文以CentOS 7/Mac 为例，介绍zsh的配置使用教程。 准备查看当前环境shell1echo $SHELL 查看系统自带哪些shell1cat /etc/shells 安装zsh12yum install zsh # CentOSbrew install zsh # mac安装 将zsh设置为默认shell1chsh -s /bin/zsh # CentOS 12345# Mac如下# 在 /etc/shells 文件中加入如下一行/usr/local/bin/zsh# 接着运行chsh -s /usr/local/bin/zsh 可以通过echo $SHELL查看当前默认的shell，如果没有改为/bin/zsh，那么需要重启shell。 oh-my-zsh配置zsh是一件麻烦的事儿，爱折腾的程序猿怎么可能忍受？！于是，oh-my-zsh出现了，有了这个东东，zsh配置起来就方便多了！ 安装oh-my-zsh有若干安装方式，介绍三种：1.自动安装1wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 2.手动安装12git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zshcp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 3.真-手动安装 在oh-my-zsh的github主页，手动将zip包下载下来。 将zip包解压，拷贝至~/.oh-my-zsh目录。此处省略拷贝的操作步骤。 执行cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 三选一即可，适合各种环境下的安装，然后需要source ~./.zshrc将配置生效。以下修改了.zshrc文件之后，都执行一下这个命令。 zsh主题通过如下命令可以查看可用的Theme： 1# ls ~/.oh-my-zsh/themes 如何修改zsh主题呢？编辑~/.zshrc文件，将ZSH_THEME=&quot;candy&quot;,即将主题修改为candy。我采用的steeef。 zsh扩展在~/.zshrc中找到plugins关键字，就可以自定义启用的插件了，系统默认加载git。 git插件命令内容可以参考cat ~/.oh-my-zsh/plugins/git/git.plugin.zsh。 常用的：12345678910111213gapa git add --patchgc! git commit -v --amendgcl git clone --recursivegclean git reset --hard &amp;&amp; git clean -dfxgcm git checkout mastergcmsg git commit -mgco git checkoutgd git diffgdca git diff --cachedgp git pushgrbc git rebase --continuegst git statusgup git pull --rebase 完整列表：https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git extract解压文件用的，所有的压缩文件，都可以直接x filename，不用记忆参数 当然，如果你想要用tar命令，可以使用tar -加tab键，zsh会列出参数的含义。 autojump按照官方文档介绍，需要使用如下命令安装，而不是一些博客中的介绍： 12yum install autojump-zsh # CentOSbrew install autojump # Mac CentOS安装好之后，需要在~/.zshrc中配置一下，除了在plugins中增加autojump之外，还需要添加一行： 1[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh 安装好之后，记得source ~/.zshrc，然后你就可以通过j+目录名快速进行目录跳转。支持目录名的模糊匹配和自动补全。 j -stat：可以查看历史路径库 zsh-autosuggestionszsh-autosuggestions 1git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 在 ~/.zshrc 中配置 1plugins=(其他的插件 zsh-autosuggestions) 因为箭头→不太方便，在.zshrc中自定义补全快捷键为逗号，但是又一次遇到了需要输入逗号的情况，所以，并不太推荐如下修改： 1bindkey &apos;,&apos; autosuggest-accept zsh-syntax-highlightingzsh-syntax-highlighting 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting ~/.zshrc文件中配置： 1plugins=(其他的插件 zsh-syntax-highlighting) git-opengit-open插件可以在你git项目下打开远程仓库浏览项目。 1git clone https://github.com/paulirish/git-open.git $ZSH_CUSTOM/plugins/git-open batbat 代替 catcat 某个文件，可以在终端直接输出文件内容，bat 相比 cat 增加了行号和颜色高亮 👍 1brew install bat 常用快捷键 命令历史记录 一旦在 shell 敲入正确命令并能执行后，shell 就会存储你所敲入命令的历史记录（存放在~/.zsh_history 文件中），方便再次运行之前的命令。可以按方向键↑和↓来查看之前执行过的命令 可以用 r来执行上一条命令 使用 ctrl-r 来搜索命令历史记录 命令别名 可以简化命令输入，在 .zshrc 中添加 alias shortcut=&#39;this is the origin command&#39; 一行就相当于添加了别名 在命令行中输入 alias 可以查看所有的命令别名 使用技巧 连按两次Tab会列出所有的补全列表并直接开始选择，补全项可以使用 ctrl+n/p/f/b上下左右切换 智能跳转，安装了 autojump 之后，zsh 会自动记录你访问过的目录，通过 j 目录名 可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过 hadoop-1.0.0 目录，输入j hado 即可正确跳转。j –stat 可以看你的历史路径库。 命令选项补全。在zsh中只需要键入 tar - 就会列出所有的选项和帮助说明 在当前目录下输入 .. 或 … ，或直接输入当前目录名都可以跳转，你甚至不再需要输入 cd 命令了。在你知道路径的情况下，比如 /usr/local/bin 你可以输入cd /u/l/b 然后按进行补全快速输入 目录浏览和跳转：输入 d，即可列出你在这个会话里访问的目录列表，输入列表前的序号，即可直接跳转。 命令参数补全。键入kill &lt;tab&gt; 就会列出所有的进程名和对应的进程号 更智能的历史命令。在用或者方向上键查找历史命令时，zsh支持限制查找。比如，输入ls,然后再按方向上键，则只会查找用过的ls命令。而此时使用则会仍然按之前的方式查找，忽略 ls 多个终端会话共享历史记录 通配符搜索：ls -l **/*.sh，可以递归显示当前目录下的 shell 文件，文件少时可以代替 find。使用 **/ 来递归搜索 扩展环境变量，输入环境变量然后按 就可以转换成表达的值 在 .zshrc 中添加 setopt HIST_IGNORE_DUPS 可以消除重复记录，也可以利用sort -t &quot;;&quot; -k 2 -u ~/.zsh_history | sort -o ~/.zsh_history手动清除 参考 wting/autojump–官方文档 powerline/fonts Linux 终极 Shell Ubuntu 16.04下安装zsh和oh-my-zsh Ubuntu 下安装oh-my-zsh 掘金-Shell 中的极品– Zsh CentOS 7下autojump无法使用的可能原因 oh-my-zsh配置你的zsh提高shell逼格终极选择 Mac zsh oh-my-zsh 插件推荐 zsh 全程指南-推荐 iterm主题下载 程序员内功系列–iTerm与Zsh篇 Mac 下配置终端环境 iTerm2 + Zsh + Oh My Zsh + tmux 最后 Github-Michael728/my-config-files 附上我的配置文件地址； zsh+on-my-zsh配置教程指南 本文地址]]></content>
      <categories>
        <category>ToolsDev</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Linux</tag>
        <tag>Mac</tag>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观影-完美陌生人-家庭-人性]]></title>
    <url>%2F2017%2F05%2F05%2Fmovie-Perfect-Strangers%2F</url>
    <content type="text"><![CDATA[豆瓣链接-完美陌生人 虽然过于巧合，但是，电影毕竟是电影，这里无需都要那么真实，因为，他的目的对人性的讽刺，夫妻间、朋友间的关系原来那么微妙，充满秘密……就连最后的结局也是精彩，值得推敲，并不是有些评价所说的，“闹掰的怎么和好的那么快”，因为，结尾展示的是平行时空下是什么样的结局！ 这是那一天第一次看这部电影时，我在豆瓣留下的评论，虽然这段时间一直为论文的事情而忙碌，但是，忙里偷闲，把这部之前一直想看的电影看完了，时间不是很长，它却给我留下了极深的印象。尽管是一部意大利的小成本电影，所有的场景基本都是在男主家里，但是，大家通过打来的各种电话，却足以让观众想象到了背后的故事…… 几个家庭的正常聚餐，却因为一个把手机交出来共享电话信息的游戏额支离破碎。以为坚强可靠的友情，也只是你以为的坚强可靠！比如，男主的妻子和男主从小长到大的小伙伴有了私情，甚至还要为此去隆胸；比如，当知道好兄弟是gay时，有人就控制不住的开始接受不了。结局也挺有意思，展示的是如果不玩游戏，是个什么完美的聚餐结局，一片祥和温馨，各回各家，手机里也是传达着各自的秘密…… “不要去可以考验人性，它会让你失望的！”如果可以，给彼此一定的空间，每个人都不是圣人，都会有可能犯错，然而，留给的空间是基于彼此的信任，是彼此都珍视彼此的情况。 人和人之间的关系是脆弱的 这句话真不假，有时候你自以为牢固的关系，可能并不真的像你想象的那样牢固。 男主对他刚刚成年的女儿说的话，令我印象深刻，是一个足够成熟冷静的父亲，在女儿私下打电话给他时（并没有选择打给她的妈妈），女儿询问他关于她要不要去他男友家时，父亲只是告诉了她，去还是不去，是她自己的决定，这可能是她人生中一个重要的时刻！（PS：男主还给她女儿准备了一盒tt），不管现实中是否有这样足够冷静的父亲，至少，电影里这样的一位父亲的做法是值得学习的，作为父亲，其实并不能左右子女的想法，因为他们已经是一个独立的人了，应该尊重，并告知选择可能带来的结果，至于做还是不做，还是要看他们怎么去选择。 Mark一下，不知道这部作品会不会成为我今年的最佳影片了。]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>电影</tag>
        <tag>人性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下利用批命令修改IP设置]]></title>
    <url>%2F2016%2F11%2F14%2Ftools-batch-file-set-ip-mask-gateway%2F</url>
    <content type="text"><![CDATA[因为在实验室需要将网络设置为自动获取IP地址和DNS服务器地址，然而，在宿舍想要登录成功6维BT站，却需要配置静态IP地址。每次切换IP需要输入一串参数，打开网络适配器去设置，很麻烦，下午就花时间解决了一下。 设置静态IP/DNS地址12netsh int ipv4 set address name="以太网" source=static address=222.26.218.27 mask=255.255.255.40 gateway=222.26.218.254netsh int ipv4 set dns name="以太网" source=static address=202.118.66.66 register=primary validate=no 这里需要注意的是，name这个值，是你电脑网络连接的名称，需要到网络适配器中去查看，示意图如下： 大部分name值都是”本地连接”，需要根据你自己的配置修改名称。 ipv4 address:IP地址 mask:子网掩码 gateway:默认网关 dns address:首选DNS服务器 设置动态IP/DNS地址12netsh interface ipv4 set address name="以太网" source=dhcpnetsh interface ipv4 set dnsservers name="以太网" source=dhcp 命令升级版将设置静态IP和动态IP集成到一个bat文件中，方便执行。 注意：执行时，需要管理员权限。 123456789101112131415161718192021222324252627282930@echo offtitle 一件切换IP地址--Michael翔color 0a:beginecho 一键切换IP地址echo 1.切换成静态IP（宿舍）echo 2.切换成动态IPecho.@rem echo. 紧跟着一点，效果是空了一行set /p op=Type optionif "%op%"=="1" goto op1if "%op%"=="2" goto op2:op1echo "你选择了选项1"netsh int ipv4 set address name="以太网" source=static address=222.26.218.16 mask=255.255.255.0 gateway=222.26.218.254netsh int ipv4 set dns name="以太网" source=static address=202.118.66.6 register=primary validate=nogoto exit@rem 这里的go to begin不能少，不然，执行选项1之后，会继续向下执行:op2echo "你选择了选项2"netsh interface ipv4 set address name="以太网" source=dhcpnetsh interface ipv4 set dnsservers name="以太网" source=dhcpgoto exit:Exitpasue 注解：在 SET 命令中添加了两个新命令行开关: 12SET /A expressionSET /P variable=[promptString] /A 命令行开关指定等号右边的字符串为被评估的数字表达式。 /P 命令行开关允许将变量数值设成用户输入的一行输入。读取输入 行之前，显示指定的 promptString。promptString (提示词)可以是空的 命令简介 echo+message如果，要在执行bat命令时，让cmd窗口不一闪而过，在文件末尾添加pause就可以了！例如：echo “hello michael翔” @echo off这个效果是不显示后面的执行命令，关闭回显功能； rem注释命令，类似于在C语言中的/——–/，它并不会被执行，只是起一个注释的作用例如：rem 这里是注释哈！不会执行，但是，会显示此行，如果要关闭回显，加符号@； pause暂停命令。 goto跳转命令。程序指针跳转到指定的标签，从标签后的第一条命令开始继续执行批处理程序。例如：123:1startgoto 1 这里就会循环执行，打卡很多窗口。 set显示、设置或删除变量例如： 12345set a=2set b=aecho %a%echo %b%pasue 这里是设置b为字符串a，如果要将a值赋值给b，应该b=%a%。set a=删除变量 符号简介 @回显关闭，表示不显示@后面的命令。 命令释义文件夹管理 cd 显示当前目录名或改变当前目录。 md 创建目录。 rd 删除一个目录。 dir 显示目录中的文件和子目录列表。 tree 以图形显示驱动器或路径的文件夹结构。 path 为可执行文件显示或设置一个搜索路径。 copy 复制文件和目录树。 文件管理 type 显示文本文件的内容。 copy 将一份或多份文件复制到另一个位置。 del 删除一个或数个文件。 move 移动文件并重命名文件和目录。（Windows XP Home Edition中没有) ren重命名文件。 replace 替换文件。 attrib 显示或更改文件属性。 find 搜索字符串。 fc 比较两个文件或两个文件集并显示它们之间的不同 参考 百科-批处理 How to script a change to a static IP address or DHCP IP address in Windows using a batch file 批处理常用命令总结和WindowsXP下运行命令使用大全及优化 BAT 批处理脚本 教程 Multiple choices menu on batch file? 知道-批处理中set /a和set /p有什么区别，一般怎么用？谢谢回答！ 贴吧-简述一下怎么自己写批处理吧]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>小程序</tag>
        <tag>batch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客建站日志]]></title>
    <url>%2F2016%2F09%2F03%2Fblog-logfile%2F</url>
    <content type="text"><![CDATA[建站笔记 Hexo 搭建 Blog 精简笔记 站点管理 百度统计 建站日志 2019-05-18: 博客增加了「阅读」、「观影」、「一言」页面2019-05-11：博客增加了萌萌的「看板娘」，同时，评论系统改为 Valine2018-11-11：Github搭建的博客，启用https了，做了适配修改，同时升级了Next主题版本。2019-03-03：评论系统从 Disqus 改为了「来必力」2017-04-22：将博客评论由多说变为disqus，尽管需要FQ才能看到，但是没办法，多说要关闭了……2017-04-03：修改了工具总结，添加了几个这段时间发现的好软件2016-09-03：优化了sitemap 、添加了博客内搜索2016-09-03：增加了工具页面http://michaelxiang.me/tools/，激动人心]]></content>
      <categories>
        <category>ToolsDaily</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python正则表达式学习摘要及资料]]></title>
    <url>%2F2016%2F07%2F28%2Fpython-regx%2F</url>
    <content type="text"><![CDATA[摘要 在正则表达式中，如果直接给出字符，就是精确匹配。 {m,n}? 对于前一个字符重复 m到 n 次，并且取尽可能少的情况 在字符串&#39;aaaaaa&#39;中，a{2,4} 会匹配 4 个 a，但 a{2,4}? 只匹配 2 个 a。^表示行的开头，^\d表示必须以数字开头。 $表示行的结束，\d$表示必须以数字结束。 你可能注意到了，py也可以匹配&#39;python&#39;–&gt;py;但是加上^py$就变成了整行匹配，就只能匹配’py’了,匹配&#39;python&#39;时，就什么也得不到。 参考表正则表达式特殊序列 re模块re.compile(pattern[, flags])把正则表达式的模式和标识转化成正则表达式对象，供match() 和search() 这两个函数使用。 re 所定义的 flag 包括：123456re.I 忽略大小写re.L 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境re.M 多行模式re.S 即为’ . ’并且包括换行符在内的任意字符（’ . ’不包括换行符）re.U 表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库re.X 为了增加可读性，忽略空格和’ # ’后面的注释 以下两种用法结果相同：(A)12compiled_pattern = re.compile(pattern) result = compiled_pattern.match(string) (B)1result = re.match(pattern, string) 由于Python的字符串本身也用\转义，所以要特别注意：123s = &apos;ABC\\-001&apos; # Python的字符串 #对应的正则表达式字符串变成： #&apos;ABC\-001&apos; 因此我们强烈建议使用Python的r前缀，就不用考虑转义的问题了123s = r&apos;ABC\-001&apos; # Python的字符串# 对应的正则表达式字符串不变：# &apos;ABC\-001&apos; searchre.search(pattern, string[, flags])在字符串中查找匹配正则表达式模式的位置，返回 MatchObject 的实例，如果没有找到匹配的位置，则返回None。 对于已编译的正则表达式对象来说（re.RegexObject），有以下search 的方法：search (string[, pos[, endpos]])若 regex 是已编译好的正则表达式对象，regex.search(string, 0, 50) 等同于regex.search(string[:50], 0)`。123&gt;&gt;&gt; pattern = re.compile(&quot;a&quot;) &gt;&gt;&gt; pattern.search(&quot;abcde&quot;) # Match at index 0 &gt;&gt;&gt; pattern.search(&quot;abcde&quot;, 1) # No match; matchre.match(pattern, string[, flags])判断 pattern 是否在字符串开头位置匹配。对于 RegexObject，有：match(string[, pos[, endpos]])match() 函数只在字符串的开始位置尝试匹配正则表达式，也就是只报告从位置 0 开始的匹配情况，而 search() 函数是扫描整个字符串来查找匹配。如果想要搜索整个字符串来寻找匹配，应当用 search()。12&gt;&gt;&gt; pattern.match(&apos;bca&apos;,2).group()&apos;a&apos; 虽然，match默认是从开头匹配，但是，如果指定位置，仍然能成功；但是！match也是从指定位置开始匹配，不匹配仍然会失败，这一点就和search有区别啦。 match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。12345test = &apos;用户输入的字符串&apos;if re.match(r&apos;正则表达式&apos;, test): print(&apos;ok&apos;)else: print(&apos;failed&apos;) splitre.split(pattern, string[, maxsplit=0, flags=0])此功能很常用，可以将将字符串匹配正则表达式的部分割开并返回一个列表。对 RegexObject，有函数：split(string[, maxsplit=0]) 对于一个找不到匹配的字符串而言，split 不会对其作出分割 12&gt;&gt;&gt; &apos;a b c&apos;.split(&apos; &apos;)[&apos;a&apos;, &apos;b&apos;, &apos;&apos;, &apos;&apos;, &apos;c&apos;] 这里用字符串自带的split方法就很不灵活。12&gt;&gt;&gt; re.split(r&apos;\s+&apos;, &apos;a b c&apos;)[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 看出差别了吧，很强大！再来一个终极的：12&gt;&gt;&gt; re.split(r&apos;[\s\,\;]+&apos;, &apos;a,b;; c d&apos;)[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;] r&#39;[\s\,\;]+&#39;的正则表达式意思为：空格或者,或者;`出现1次或1次以上都是满足条件的分割符号！所以，最后结果还是很干净。 findallre.findall(pattern, string[, flags]) 在字符串中找到正则表达式所匹配的所有子串，并组成一个列表返回。同样 RegexObject有：findall(string[, pos[, endpos]])1234 #get all content enclosed with [], and return a list &gt;&gt;&gt; pattern=re.compile(r&apos;hh&apos;)&gt;&gt;&gt; pattern.findall(&apos;hhmichaelhh&apos;)[&apos;hh&apos;, &apos;hh&apos;] finditerre.finditer(pattern, string[, flags])和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并组成一个迭代器返回。同样 RegexObject 有：finditer(string[, pos[, endpos]]) subre.sub(pattern, repl, string[, count, flags])在字符串 string 中找到匹配正则表达式pattern的所有子串，用另一个字符串 repl进行替换。如果没有找到匹配 pattern 的串，则返回未被修改的 string。Repl 既可以是字符串也可以是一个函数。 返回值是替换后的新字符串。 对于 RegexObject有：sub(repl, string[, count=0])123456789&gt;&gt;&gt; pattern=re.compile(r&apos;\d&apos;)&gt;&gt;&gt; pattern.sub(&apos;no&apos;,&apos;12hh34hh&apos;)&apos;nonohhnonohh&apos;&gt;&gt;&gt; pattern.sub(&apos;no&apos;,&apos;12hh34hh&apos;,0)&apos;nonohhnonohh&apos;&gt;&gt;&gt; pattern.sub(&apos;no&apos;,&apos;12hh34hh&apos;,count=0)&apos;nonohhnonohh&apos;&gt;&gt;&gt; pattern.sub(&apos;no&apos;,&apos;12hh34hh&apos;,1)&apos;no2hh34hh&apos; 通过上面的例子，可以看出,count是可以缺省的，同时，默认值是0，表示全部替换；否则，就是指定替换几个。 subnre.subn(pattern, repl, string[, count, flags])该函数的功能和 sub() 相同，但它还返回新的字符串以及替换的次数。同样RegexObject有：subn(repl, string[, count=0])12&gt;&gt;&gt; pattern.subn(&apos;no&apos;,&apos;12hh34hh&apos;,count=0)(&apos;nonohhnonohh&apos;, 4) 分组除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如： ^(\d{3})-(\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：1234567891011&gt;&gt;&gt; m = re.match(r&apos;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&apos;, &apos;010-12345&apos;)&gt;&gt;&gt; m&lt;_sre.SRE_Match object; span=(0, 9), match=&apos;010-12345&apos;&gt;&gt;&gt;&gt; m.group(0)&apos;010-12345&apos;&gt;&gt;&gt; m.group(1)&apos;010&apos;&gt;&gt;&gt; m.group(2)&apos;12345&apos;&gt;&gt;&gt; m.groups()(&apos;010&apos;, &apos;12345&apos;) 通过实验，如果不用括号，得到的Match对象课可以使用例如a.group(0)或者a.group()但是，使用a.group(1)就会报错的。 贪婪匹配正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：12&gt;&gt;&gt; re.match(r&apos;^(\d+)(0*)$&apos;, &apos;102300&apos;).groups()(&apos;102300&apos;, &apos;&apos;) 由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。 必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配：12&gt;&gt;&gt; re.match(r&apos;^(\d+?)(0*)$&apos;, &apos;102300&apos;).groups()(&apos;1023&apos;, &apos;00&apos;) SF-正则表达式的贪婪\非贪婪模式怎么理解？ Python正则表达式学习资源 廖雪峰-正则表达式 IBM-使用 Python 模块 re 实现解析小工具 deerchao-则表达式30分钟入门教程 deerchao-正则表达式30分钟入门教程 静觅-爬虫入门七之正则表达式]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在魔都实习生活]]></title>
    <url>%2F2016%2F07%2F25%2Flife-about-intern-in-Shanghai%2F</url>
    <content type="text"><![CDATA[不知不觉，来传说中的“魔都”已经一个多月了，然而，我并没有感受到他的魔力，可能是我还没去发现吧……应该是我还没有动力去发现！ 文章开头的图片拍摄于我和媳妇儿2014年“南游”的时候，当时在外滩附近大楼拍的，现在想想，仿佛过去没多久，事实，白驹过隙，已2年多了:) 记录一下在银联这段时间的生活： 灯火通明的开发中心大楼 园区风景 伙食真是没话说啊，减肥太难，囧 我们小组现在的办公室，据说马上要搬了，不知道那时候我还在不在 来张我的小窝 陪别人去逛的徐家汇那边的恒隆，确实很繁华！ 希望一切安好，珍惜拥有的一切，努力变得更好！]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python--matplotlib绘图可视化知识点整理]]></title>
    <url>%2F2016%2F05%2F14%2Fpython-matplotlib-basic%2F</url>
    <content type="text"><![CDATA[强烈推荐ipython无论你工作在什么项目上，IPython都是值得推荐的。利用ipython --pylab，可以进入PyLab模式，已经导入了matplotlib库与相关软件包（例如Numpy和Scipy)，额可以直接使用相关库的功能。 本文作为学习过程中对matplotlib一些常用知识点的整理，方便查找。 这样IPython配置为使用你所指定的matplotlib GUI后端（TK/wxPython/PyQt/Mac OS X native/GTK)。对于大部分用户而言，默认的后端就已经够用了。Pylab模式还会向IPython引入一大堆模块和函数以提供一种更接近MATLAB的界面。 参考 matplotlib-绘制精美的图表 matplotlib.pyplot.plt参数介绍 12345678import matplotlib.pyplot as pltlabels=&apos;frogs&apos;,&apos;hogs&apos;,&apos;dogs&apos;,&apos;logs&apos;sizes=15,20,45,10colors=&apos;yellowgreen&apos;,&apos;gold&apos;,&apos;lightskyblue&apos;,&apos;lightcoral&apos;explode=0,0.1,0,0plt.pie(sizes,explode=explode,labels=labels,colors=colors,autopct=&apos;%1.1f%%&apos;,shadow=True,startangle=50)plt.axis(&apos;equal&apos;)plt.show() matplotlib图标正常显示中文为了在图表中能够显示中文和负号等，需要下面一段设置：123import matplotlib.pyplot as pltplt.rcParams[&apos;font.sas-serig&apos;]=[&apos;SimHei&apos;] #用来正常显示中文标签plt.rcParams[&apos;axes.unicode_minus&apos;]=False #用来正常显示负号 matplotlib inline和pylab inline可以使用ipython --pylab打开ipython命名窗口。 12%matplotlib inline #notebook模式下%pylab inline #ipython模式下 这两个命令都可以在绘图时，将图片内嵌在交互窗口，而不是弹出一个图片窗口，但是，有一个缺陷：除非将代码一次执行，否则，无法叠加绘图，因为在这两种模式下，是要有plt出现，图片会立马show出来，因此： 推荐在ipython notebook时使用，这样就能很方便的一次编辑完代码，绘图。 为项目设置matplotlib参数在代码执行过程中，有两种方式更改参数： 使用参数字典(rcParams) 调用matplotlib.rc()命令 通过传入关键字元祖，修改参数 如果不想每次使用matplotlib时都在代码部分进行配置，可以修改matplotlib的文件参数。可以用matplot.get_config()命令来找到当前用户的配置文件目录。 配置文件包括以下配置项： axex: 设置坐标轴边界和表面的颜色、坐标刻度值大小和网格的显示backend: 设置目标暑促TkAgg和GTKAggfigure: 控制dpi、边界颜色、图形大小、和子区( subplot)设置font: 字体集（font family）、字体大小和样式设置grid: 设置网格颜色和线性legend: 设置图例和其中的文本的显示line: 设置线条（颜色、线型、宽度等）和标记patch: 是填充2D空间的图形对象，如多边形和圆。控制线宽、颜色和抗锯齿设置等。savefig: 可以对保存的图形进行单独设置。例如，设置渲染的文件的背景为白色。verbose: 设置matplotlib在执行期间信息输出，如silent、helpful、debug和debug-annoying。xticks和yticks: 为x,y轴的主刻度和次刻度设置颜色、大小、方向，以及标签大小。 线条相关属性标记设置用来该表线条的属性 线条风格linestyle或ls 描述 线条风格linestyle或ls 描述 ‘-‘ 实线 ‘:’ 虚线 ‘–’ 破折线 ‘None’,’ ‘,’’ 什么都不画 ‘-.’ 点划线 线条标记 标记maker 描述 标记 描述 ‘o’ 圆圈 ‘.’ 点 ‘D’ 菱形 ‘s’ 正方形 ‘h’ 六边形1 ‘*’ 星号 ‘H’ 六边形2 ‘d’ 小菱形 ‘_’ 水平线 ‘v’ 一角朝下的三角形 ‘8’ 八边形 ‘&lt;’ 一角朝左的三角形 ‘p’ 五边形 ‘&gt;’ 一角朝右的三角形 ‘,’ 像素 ‘^’ 一角朝上的三角形 ‘+’ 加号 ‘\ ‘ 竖线 ‘None’,’’,’ ‘ 无 ‘x’ X 颜色可以通过调用matplotlib.pyplot.colors()得到matplotlib支持的所有颜色。 别名 颜色 别名 颜色 b 蓝色 g 绿色 r 红色 y 黄色 c 青色 k 黑色 m 洋红色 w 白色 如果这两种颜色不够用，还可以通过两种其他方式来定义颜色值： 使用HTML十六进制字符串 color=&#39;eeefff&#39; 使用合法的HTML颜色名字（’red’,’chartreuse’等）。 也可以传入一个归一化到[0,1]的RGB元祖。 color=(0.3,0.3,0.4) 很多方法可以介绍颜色参数，如title()。plt.tilte(&#39;Title in a custom color&#39;,color=&#39;#123456&#39;） 背景色通过向如matplotlib.pyplot.axes()或者matplotlib.pyplot.subplot()这样的方法提供一个axisbg参数，可以指定坐标这的背景色。 subplot(111,axisbg=(0.1843,0.3098,0.3098) 基础如果你向plot()指令提供了一维的数组或列表，那么matplotlib将默认它是一系列的y值，并自动为你生成x的值。默认的x向量从0开始并且具有和y同样的长度，因此x的数据是[0,1,2,3]. 图片来自:绘图: matplotlib核心剖析 确定坐标范围 plt.axis([xmin, xmax, ymin, ymax])上面例子里的axis()命令给定了坐标范围。 xlim(xmin, xmax)和ylim(ymin, ymax)来调整x,y坐标范围123456789101112131415161718%matplotlib inlineimport numpy as npimport matplotlib.pyplot as pltfrom pylab import *x = np.arange(-5.0, 5.0, 0.02)y1 = np.sin(x)plt.figure(1)plt.subplot(211)plt.plot(x, y1)plt.subplot(212)#设置x轴范围xlim(-2.5, 2.5)#设置y轴范围ylim(-1, 1)plt.plot(x, y1) 叠加图用一条指令画多条不同格式的线。123456789import numpy as npimport matplotlib.pyplot as plt# evenly sampled time at 200ms intervalst = np.arange(0., 5., 0.2)# red dashes, blue squares and green trianglesplt.plot(t, t, &apos;r--&apos;, t, t**2, &apos;bs&apos;, t, t**3, &apos;g^&apos;)plt.show() plt.figure()你可以多次使用figure命令来产生多个图，其中，图片号按顺序增加。这里，要注意一个概念当前图和当前坐标。所有绘图操作仅对当前图和当前坐标有效。通常，你并不需要考虑这些事，下面的这个例子为大家演示这一细节。1234567891011121314import matplotlib.pyplot as pltplt.figure(1) # 第一张图plt.subplot(211) # 第一张图中的第一张子图plt.plot([1,2,3])plt.subplot(212) # 第一张图中的第二张子图plt.plot([4,5,6])plt.figure(2) # 第二张图plt.plot([4,5,6]) # 默认创建子图subplot(111)plt.figure(1) # 切换到figure 1 ; 子图subplot(212)仍旧是当前图plt.subplot(211) # 令子图subplot(211)成为figure1的当前图plt.title(&apos;Easy as 1,2,3&apos;) # 添加subplot 211 的标题 figure感觉就是给图像ID，之后可以索引定位到它。 plt.text()添加文字说明 text()可以在图中的任意位置添加文字，并支持LaTex语法 xlable(), ylable()用于添加x轴和y轴标签 title()用于添加图的题目 12345678910111213141516171819import numpy as npimport matplotlib.pyplot as pltmu, sigma = 100, 15x = mu + sigma * np.random.randn(10000)# 数据的直方图n, bins, patches = plt.hist(x, 50, normed=1, facecolor=&apos;g&apos;, alpha=0.75)plt.xlabel(&apos;Smarts&apos;)plt.ylabel(&apos;Probability&apos;)#添加标题plt.title(&apos;Histogram of IQ&apos;)#添加文字plt.text(60, .025, r&apos;$\mu=100,\ \sigma=15$&apos;)plt.axis([40, 160, 0, 0.03])plt.grid(True)plt.show() text中前两个参数感觉应该是文本出现的坐标位置。 plt.annotate()文本注释在数据可视化的过程中，图片中的文字经常被用来注释图中的一些特征。使用annotate()方法可以很方便地添加此类注释。在使用annotate时，要考虑两个点的坐标：被注释的地方xy(x, y)和插入文本的地方xytext(x, y)。[^1] 123456789101112131415import numpy as npimport matplotlib.pyplot as pltax = plt.subplot(111)t = np.arange(0.0, 5.0, 0.01)s = np.cos(2*np.pi*t)line, = plt.plot(t, s, lw=2)plt.annotate(&apos;local max&apos;, xy=(2, 1), xytext=(3, 1.5), arrowprops=dict(facecolor=&apos;black&apos;, shrink=0.05), )plt.ylim(-2,2)plt.show() [^1]:DataHub-Python 数据可视化入门1 plt.xticks()/plt.yticks()设置轴记号现在是明白干嘛用的了，就是人为设置坐标轴的刻度显示的值。 12345678910111213141516171819202122232425262728# 导入 matplotlib 的所有内容（nympy 可以用 np 这个名字来使用）from pylab import *# 创建一个 8 * 6 点（point）的图，并设置分辨率为 80figure(figsize=(8,6), dpi=80)# 创建一个新的 1 * 1 的子图，接下来的图样绘制在其中的第 1 块（也是唯一的一块）subplot(1,1,1)X = np.linspace(-np.pi, np.pi, 256,endpoint=True)C,S = np.cos(X), np.sin(X)# 绘制余弦曲线，使用蓝色的、连续的、宽度为 1 （像素）的线条plot(X, C, color=&quot;blue&quot;, linewidth=1.0, linestyle=&quot;-&quot;)# 绘制正弦曲线，使用绿色的、连续的、宽度为 1 （像素）的线条plot(X, S, color=&quot;r&quot;, lw=4.0, linestyle=&quot;-&quot;)plt.axis([-4,4,-1.2,1.2])# 设置轴记号xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi], [r&apos;$-\pi$&apos;, r&apos;$-\pi/2$&apos;, r&apos;$0$&apos;, r&apos;$+\pi/2$&apos;, r&apos;$+\pi$&apos;])yticks([-1, 0, +1], [r&apos;$-1$&apos;, r&apos;$0$&apos;, r&apos;$+1$&apos;])# 在屏幕上显示show() 当我们设置记号的时候，我们可以同时设置记号的标签。注意这里使用了 LaTeX。[^2] [^2]:Matplotlib 教程 移动脊柱 坐标系1234567ax = gca()ax.spines[&apos;right&apos;].set_color(&apos;none&apos;)ax.spines[&apos;top&apos;].set_color(&apos;none&apos;)ax.xaxis.set_ticks_position(&apos;bottom&apos;)ax.spines[&apos;bottom&apos;].set_position((&apos;data&apos;,0))ax.yaxis.set_ticks_position(&apos;left&apos;)ax.spines[&apos;left&apos;].set_position((&apos;data&apos;,0)) 这个地方确实没看懂，囧，以后再说吧，感觉就是移动了坐标轴的位置。 plt.legend()添加图例1234plot(X, C, color=&quot;blue&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label=&quot;cosine&quot;)plot(X, S, color=&quot;red&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label=&quot;sine&quot;)legend(loc=&apos;upper left&apos;) matplotlib.pyplot使用plt.style.use(&#39;ggplot&#39;)命令，可以作出ggplot风格的图片。 12345678910111213141516171819202122232425# Import necessary packagesimport pandas as pd%matplotlib inlineimport matplotlib.pyplot as pltplt.style.use(&apos;ggplot&apos;)from sklearn import datasetsfrom sklearn import linear_modelimport numpy as np# Load databoston = datasets.load_boston()yb = boston.target.reshape(-1, 1)Xb = boston[&apos;data&apos;][:,5].reshape(-1, 1)# Plot dataplt.scatter(Xb,yb)plt.ylabel(&apos;value of house /1000 ($)&apos;)plt.xlabel(&apos;number of rooms&apos;)# Create linear regression objectregr = linear_model.LinearRegression()# Train the model using the training setsregr.fit( Xb, yb)# Plot outputsplt.scatter(Xb, yb, color=&apos;black&apos;)plt.plot(Xb, regr.predict(Xb), color=&apos;blue&apos;, linewidth=3)plt.show() 给特殊点做注释好吧，又是注释，多个例子参考一下！ 我们希望在 2π/32π/3 的位置给两条函数曲线加上一个注释。首先，我们在对应的函数图像位置上画一个点；然后，向横轴引一条垂线，以虚线标记；最后，写上标签。1234567891011121314151617t = 2*np.pi/3# 作一条垂直于x轴的线段，由数学知识可知，横坐标一致的两个点就在垂直于坐标轴的直线上了。这两个点是起始点。plot([t,t],[0,np.cos(t)], color =&apos;blue&apos;, linewidth=2.5, linestyle=&quot;--&quot;)scatter([t,],[np.cos(t),], 50, color =&apos;blue&apos;)annotate(r&apos;$\sin(\frac&#123;2\pi&#125;&#123;3&#125;)=\frac&#123;\sqrt&#123;3&#125;&#125;&#123;2&#125;$&apos;, xy=(t, np.sin(t)), xycoords=&apos;data&apos;, xytext=(+10, +30), textcoords=&apos;offset points&apos;, fontsize=16, arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;arc3,rad=.2&quot;))plot([t,t],[0,np.sin(t)], color =&apos;red&apos;, linewidth=2.5, linestyle=&quot;--&quot;)scatter([t,],[np.sin(t),], 50, color =&apos;red&apos;)annotate(r&apos;$\cos(\frac&#123;2\pi&#125;&#123;3&#125;)=-\frac&#123;1&#125;&#123;2&#125;$&apos;, xy=(t, np.cos(t)), xycoords=&apos;data&apos;, xytext=(-90, -50), textcoords=&apos;offset points&apos;, fontsize=16, arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;arc3,rad=.2&quot;)) plt.subplot()plt.subplot(2,3,1)表示把图标分割成2*3的网格。也可以简写plt.subplot(231)。其中，第一个参数是行数，第二个参数是列数，第三个参数表示图形的标号。 plt.axes()我们先来看什么是Figure和Axes对象。在matplotlib中，整个图像为一个Figure对象。在Figure对象中可以包含一个，或者多个Axes对象。每个Axes对象都是一个拥有自己坐标系统的绘图区域。其逻辑关系如下[^3][^4]： plt.axes-官方文档 axes() by itself creates a default full subplot(111) window axis. axes(rect, axisbg=’w’) where rect = [left, bottom, width, height] in normalized (0, 1) units. axisbg is the background color for the axis, default white. axes(h) where h is an axes instance makes h the current axis. An Axes instance is returned. rect=[左, 下, 宽, 高] 规定的矩形区域,rect矩形简写，这里的数值都是以figure大小为比例，因此，若是要两个axes并排显示，那么axes[2]的左=axes[1].左+axes[1].宽，这样axes[2]才不会和axes[1]重叠。 show code:1234567891011121314151617181920212223242526272829303132333435http://matplotlib.org/examples/pylab_examples/axes_demo.htmlimport matplotlib.pyplot as pltimport numpy as np# create some data to use for the plotdt = 0.001t = np.arange(0.0, 10.0, dt)r = np.exp(-t[:1000]/0.05) # impulse responsex = np.random.randn(len(t))s = np.convolve(x, r)[:len(x)]*dt # colored noise# the main axes is subplot(111) by defaultplt.plot(t, s)plt.axis([0, 1, 1.1*np.amin(s), 2*np.amax(s)])plt.xlabel(&apos;time (s)&apos;)plt.ylabel(&apos;current (nA)&apos;)plt.title(&apos;Gaussian colored noise&apos;)# this is an inset axes over the main axesa = plt.axes([.65, .6, .2, .2], axisbg=&apos;y&apos;)n, bins, patches = plt.hist(s, 400, normed=1)plt.title(&apos;Probability&apos;)plt.xticks([])plt.yticks([])# this is another inset axes over the main axesa = plt.axes([0.2, 0.6, .2, .2], axisbg=&apos;y&apos;)plt.plot(t[:len(r)], r)plt.title(&apos;Impulse response&apos;)plt.xlim(0, 0.2)plt.xticks([])plt.yticks([])plt.show() [^3]:绘图: matplotlib核心剖析[^4]:python如何调整子图的大小？ pyplot.pie参数 matplotlib.pyplot.pie colors颜色找出matpltlib.pyplot.plot中的colors可以取哪些值？ so-Named colors in matplotlib CSDN-matplotlib学习之（四）设置线条颜色、形状12for name,hex in matplotlib.colors.cnames.iteritems(): print name,hex 打印颜色值和对应的RGB值。 plt.axis(&#39;equal&#39;)避免比例压缩为椭圆 autopct How do I use matplotlib autopct?1autopct enables you to display the percent value using Python string formatting. For example, if autopct=&apos;%.2f&apos;, then for each pie wedge, the format string is &apos;%.2f&apos; and the numerical percent value for that wedge is pct, so the wedge label is set to the string &apos;%.2f&apos;%pct.]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL基础语法笔记教程整理]]></title>
    <url>%2F2016%2F05%2F03%2FSQL%2F</url>
    <content type="text"><![CDATA[最近从图书馆借了本介绍SQL的书，打算复习一下基本语法，记录一下笔记，整理一下思路，以备日后复习之用。 PS：本文适用SQL Server2008语法。 一、关系型数据库和SQL实际上准确的讲，SQL是一门语言，而不是一个数据库。 什么是SQL呢？简而言之，SQL就是维护和使用关系型数据库中的的数据的一种标准的计算机语言。 1.1 SQL语言主要有3个主要的组成部分。 DML(Data Manipulation Language)数据操纵语言。这个模块可以让我们检索、修改、增加、删除数据库中的数据。 DDL(Data Definition Language)数据定义语言。是的我们能够创建和修改数据库本身。如：DDL提供ALTER语句，他让我们可以修改数据库中表的设计。 DCL(Data Control Language)数据控制语言，用于维护数据库的安全。 在SQL术语中，记录(record)和字段(field)实际上就称为行(row)和列(column)。 1.2 主键和外键主键之所以有必要： 首先使你唯一标识表中单独的一行。主键确保了唯一性。 可以很容易的将一个表和另一个表关联。 主键一般就会自动默认创建索引，提高了查询速度。 外键就是说A表中的某个字段，同时是B中的主键，那么这个字段就是A表中的外键。希望A表中的这个外键的值必须是B中已经存在的值。 1.3 数据类型一般来讲，有3中重要的数据类型： 数字(Numeric) 字符(Character) 以及日期/时间(Date/Time) bit是数字型，它只允许两个值，0和1。 字符类型区别[^1]：[^1]:varchar和Nvarchar区别 类型 长度 说明 char 固定长度 nchar 固定长度 处理unicode数据类型(所有的字符使用两个字节表示) varchar 可变长度 效率没char高 灵活 nvarchar 可变长度 处理unicode数据类型(所有的字符使用两个字节表示) 1字节=8位 bit就是位，也叫比特位，是计算机表示数据最小的单位。 byte就是字节，1byte=8bit，1byte就是1B； 一个字符=2字节； 1.3 空值空值不等于空格或空白。使用NULL表示空值。 二、简单增删改查2.1 查（列名有空格的情况）12SELECT [ last name]FROM Customers 用方括号将有空格的列名括起来。PS: MySql中用重音符`（~）按键。Oracle用双引号。 查询顺序,SQL执行顺序^2：123456Select -1&gt;选择列,-2&gt;distinct,-3&gt;top 1&gt;…From 表 2&gt;…Where 条件 3&gt;…Group by 列 4&gt;…Having 筛选条件 6&gt;…Order by 列 2.2 增123456INSERT INTO tablename(columnlist)VALUES(RowValues1)(RowValues2)(repeat any number of times) 2.3 改123UPDATE tableSET column1=expression1,column2=expression2(repeat any number of times)WHERE condition 2.4 删123DELETEFROM tableWHERE condition 删除前可以验证一下：1234SELECT COUNT（*）FROM tableWHERE condition 如果想要删除所有的行，可以：1DELETE FROM table 或者1TRUNCATE TABLE table TRUNCATE TABLE优势在于速度更快，但是不提供记录事务的结果。另外一个不同点是，TRUNCATE TABLE重新设置了用于自增型的列的当前值，DELETE不会。 三、别名关键字：AS 3.1 计算字段使用计算字段可以做如下的事情： 选择特定的单词或者数值 对单个或者多个列进行计算 把列和直接量组合在一起。 3.2 直接量这个直接量和表中的数据没有任何关系，就是为了说明所用，下面这种类型的表达式就叫做直接量(literal value)。 12SELECT &apos;直接量&apos; AS `类型`,firstname,lastname FROM `customers` ; 如图，结果中直接量就在一列中了。 3.3 算数运算例子1：12SELECT num*price AS totalFROM orders 例子2：12SELECT firstname+&apos; &apos;+lastname AS &apos;fullname&apos;FROM users 在MySql中连接要是用CONCAT函数：123SELECT OrderID,FirstName,LastName,CONCAT(FirstName,&apos; &apos;,LastName) AS &apos;fullname&apos;FROM orders 3.4 别名1）列的别名12SELECT firstname AS fnFROM customers 2） 表的别名12SELECT firstname FROM customers AS cu 说明： 列的别名是为了显示用的，别名会作为查询结果的表头，不能在WHERE中使用列的别名，会出错！！！ 表的别名确实是为了方便操作用的，可以在WHERE中使用列的别名进行！ 四、使用函数函数要有一组圆括号跟在关键字后边，圆括号告诉我们，这是一个函数！ 4.1 字符函数LEFT&amp;RIGHT LEFT(CharacterValue,NumberOfCharacters)含义：选择CharacterValue字段的左边NumberOfCharacters几个字符。ps:RIGHT是右边几个字符。 LTRIM&amp;RTRIM LTRIM(CharacterValue) 可以删除左边开始的空格。RTRIM作用类似。 SUBSTRINGSUBSTRING(CharacterValue,StartPositon,NumberOfCharacters)含义：选择从开始位置（包括），N个长度的字符。12SELECT SUBSTRING(&apos;thewhitegoat&apos;,4,5) AS &apos;The Answer&apos; 返回：white 4.2 日期/时间函数GETDATE1SELECT GETDATE() 返回当前日期和时间。PS：在MySql中，等价函数是NOW，在Oracle中是CURRENT_DATE。 DATEPART能够分析具体的日期，并且返回诸如该日期是该月中的第几天，或者该年份中的第几周等信息。1DATEPART(datepart,DateValue) datepart可以是许多不同的值，如下都是有效值： year quarter month dayofyear day week weekday hour minute second DATEDIFF可以让我们得到任意两个日期之间相差的天数（或周数、月数等）。1DATEDIFF(datepart1,startdate1,startdate2) DATEDIFF Function Expression Resulting Value DATEDIFF(day,’7/8/2009’,’8/14/2009’) 37 DATEDIFF(week,’7/8/2009’,’8/14/2009’) 5 DATEDIFF(month,’7/8/2009’,’8/14/2009’) 1 DATEDIFF(year,’7/8/2009’,’8/14/2009’) 0 PS:MySql中，DATEDIFF函数只允许我们计算两个日期之间的天数，如果想要得到一个正数，结束的日期通常要作为第一个参数:1DATEDIFF(enddate,startdate) Oracle中没有等价函数 4.3 数值函数ROUND允许我们四舍五入。1ROUND(numericvalue,decimalpalaces) RAND用来产生随机数1RAND([seed]) 没有参数时，它会返回0-1之间的一个随机数。1SELECT RAND() AS &apos;Random Value&apos; 可选参数seed有的情况下，每次将返回相同的值。这让我想起了Python中的Random包。看来很多时候，一些东西是共通的啊。 PIPI()函数如果想要对它保留两位小数，可以通过复合函数进行：1SELECT ROUND(PI(),2) 将会返回：3.14 4.4 转换函数CAST函数允许我们把数据从一种类型转换成另一种类型。1CAST(expression AS DateType) 例子：123SELECT &apos;2009-04-11&apos; AS &apos;Original Date&apos;,CAST(&apos;2009--04-11&apos; AS DATETIME) AS &apos;Converted Date&apos; ISNULL函数，很有用可以把NULL值转换成一个有意义的值。123SELECT Description,ISNULL(Color,&apos;Unknown&apos;) AS &apos;Color&apos;FROM Products 五、排序函数5.1 添加排序123SELECT columnlistFROM tablelistORDER BY columnlist 默认是升序，ASC，因此，上面等价于：123SELECT columnlistFROM tablelistORDER BY columnlist ASC 5.2 降序使用DESC关键字：123SELECT columnlistFROM tablelistORDER BY columnlist DESC 5.3 根据多列12345SELECT FirstName,LastNameFROM CustomersORDER BY LastName, FirstName 注意：列的顺序很重要，首先按照LastName排序，然后按照FirstName排序。 5.4 根据计算字段123SELECT LastName+&apos;,&apos;+FirstName AS &apos;Name&apos;FROM CustomersORDER BY Name 因此，从这儿可以知道，列别名不可以用在WHERE中，但可以用在ORDER BY中。例子123SELECT FirstName,LastNameFROM CustomersORDER BY LastName+FirstName AS &apos;Name&apos; 5.5 排序补充内容当数据升序时，出现顺序是如下： NULL-&gt;数字-&gt;字符注意：此时，该列中的数字其实是按照字符来算的，因此，升序时，23也是排在5之前的。 六、基于列的逻辑-CASE6.1 IF-THEN-ELSE逻辑包含列和CASE表达式的SELECT语句，大概如下：12345SELECT column1,column2,CaseExpressionFROM table 6.2 CASE-简单格式1234567SELECT CASE ColumnOrExpressionWHEN value1 THEN result1WHEN value2 THEN result2(repeat WHEN-THEN any number of times)[ELSE DefaultResult]END CASE表达式对于把不好理解的值转换成有意义的描述是很有用的。12345678SELECT CASE CategoryCodeWHEN &apos;F&apos; THEN &apos;Fruit&apos;WHEN &apos;V&apos; THEN &apos;Vegetable&apos;ELSE &apos;other&apos;END AS &apos;Category&apos;,ProductDescription As &apos;Description&apos;FROM Products 6.3 CASE-查询格式1234567SELECT CASE WHEN condition1 THEN result1WHEN condition2 THEN result2(repeat WHEN-THEN any number of times)[ELSE DefaultResult]END 这种格式允许在关键字WHEN后边放置较为复杂的条件表达式。 相关问题： StackOverFlow-SQL Server: CASE WHEN OR THEN ELSE END =&gt; the OR is not supported 七、基于行的逻辑7.1 应用查询条件终于派到WHERE出场了，注意写法顺序，再写一遍：123456Select -1&gt;选择列,-2&gt;distinct,-3&gt;top 1&gt;…From 表 2&gt;…Where 条件 3&gt;…Group by 列 4&gt;…Having 筛选条件 6&gt;…Order by 列 7.2 限制行-TOP1234SELECT TOP Number ColumnlistFROM table 7.3 TOP和ORDER BY结合关键字TOP的另一个用途是，把它和ORDER BY子句结合起来，基于特定分类，得到带有最大值的一定数量的行。 假设你想看到Shakespeare所著的销量最多的书。1234567SELECT TOP1Title AS &apos;Book Title&apos;,CurrentMonthSales AS &apos;Quantuty Sold&apos;FROM BooksWHERE Author=&apos;Shakespeare&apos;ORDER BY CurrentMonthSales DESC ps: 学会利用google搜索，例如，我想要知道oracle中类似top作用的关键字是什么，可以： 八、布尔逻辑关键字：AND/OR/NOT/BETWEEN/IN/IS/NULL 8.1 OROR子句意味着，如果确定任意条件为真，那么就该选中该行。1234SELECT userid,name,phoneFROM usersWHERE age&lt;18OR age&gt;60 8.2 使用圆括号1234567SELECT CustomerName,Sate,QuantityPurchasedFROM OrdersWHERE State =&apos;IL&apos;OR State=&apos;CA&apos;AND QuantityPurchased&gt;8 本来想要的结果是对来自IL或者CA的客户，同时，只看数量大于8的订单。但是上面执行的结果不是这样的，因为，SQL总是会先处理AND操作符！！！然后才会处理OR操作符。所以，上述语句中，先看到AND并执行如下的条件12State= &apos;CA&apos;AND QuantityPurchased&gt;8 因此，要用括号来规定顺序：1234567SELECT CustomerName,Sate,QuantityPurchasedFROM OrdersWHERE (State =&apos;IL&apos;OR State=&apos;CA&apos;)AND QuantityPurchased&gt;8 8.3 NOT操作符NOT操作符表示对后边的内容否定或者取反。123SELECT CustomerName,StateFROM OrdersWHERE NOT (State=&apos;IL&apos; OR Sate=&apos;NY&apos;) 这个其实可以用AND改写的！！！NOT操作符在逻辑上不是必须的。 8.4 BETWEEN操作符12345SELECT CustomerName,Sate,QuantityPurchasedFROM OrdersWHERE QuantityPurchased BETWEEN 8 AND 10 8.5 IN操作符假设你想看到IL或者NY的行：1234SELECT *FROM OrdersWHERE State=&apos;IL&apos;OR State=&apos;CA&apos; 可以改写成：123SELECT *FROM OrdersWHERE State IN (&apos;IL&apos;,&apos;CA&apos;) 8.9 布尔逻辑-IS NULL为了将某字段NULL值的行或0的行包括进来：1234SELECT *FROM ProductsWHERE weight=0OR weight IS NULL 或者123SELECT *FROM ProductsWHERE ISNULL(weight,0)=0 九、模糊匹配9.1 LIKE和%搭配%通配符可以表示任意的字符，它可以表示0个，1个，任意多个字符。 9.2 通配符除了%以外，还有下划线（_）、方括号起来的characterlist，以及用方括号括起来的脱字符号（^）加上characterlist。 下划线表示一个字符 [characterlist]表示括号中字符的任意一个 [^characterlist]表示不能是括号中字符的任意一个例子：12345SELECT FirstName,LastNameFROM ActorsWHERE FirstName LIKE &apos;[CM]ARY&apos; 检索以C或者M开头并以ARY结尾的所有行。 9.3 按照读音匹配SOUNDEX和DIFFERENCE 十、汇总数据10.1消除重复使用DISTINCT12SELECT DISTINCE name,ageFROM users 如果age不同，即使name相同，那么这一行就不会被删除重复。 10.2 聚合函数COUNT\SUM\AVG\MIN\MAX，他们提供了对分组数据进行计数、求和、取平均值、取最小值和最大值等方法。12345SELECT AVG(Grade) AS &apos;Average Quiz Score&apos;MIN(Grade) AS &apos;Minimum Quiz Score&apos;FROM GradesWHERE GradeType=&apos;Quiz&apos; COUNT函数可以有3中不同方式使用它。1.COUNT函数可以用来返回所有选中行的数目，而不管任何特定列的值。例如：下面语句返回GradeType为’HomeWork’的所有行的数目：1234SELECT COUNT(*) AS &apos;Count of Homework Rows&apos;FROM GradesWHERE GradeType=&apos;HomeWork&apos; 这种*方式，会计数所有行的个数，即使其中有NULL。 2.第二种方式指定具体的列1234SELECT COUNT(Grades) AS &apos;Count of Homework Rows&apos;FROM GradesWHERE GradeType=&apos;HomeWork&apos; 第一种方式返回3，这一种方式返回2，为什么？？？因为，这种方式要满足Grades这一列有值，NULL值的行不会计数。 3.使用关键字DISTINCT。123SELECT COUNT(DISTINCT FeeType) AS &apos;Number of Fee Types&apos;FROM Fees 这条语句计数了FeeType列唯一值的个数。 10.3 分组数据-GROUP BY123456SELECTGradeType AS &apos;Grade Type&apos;,AVG(Grade)AS &apos;Average Grade&apos;FROM GradesGROUP BY GradeTypeORDER BY GradeType 感觉像EXCEL中的分类汇总功能。如果想把Grade为NULL值的当做0，那么可以用：123456SELECTGradeType AS &apos;Grade Type&apos;,AVG(ISNULL(Grade,0))AS &apos;Average Grade&apos;FROM GradesGROUP BY GradeTypeORDER BY GradeType GROUP BY子句中的列的顺序是没有意义的； ORDER BY子句中的列的顺序是有意义的。 10.4 基于聚合查询条件-HAVING当针对带GROUP BY的一条SELECT语句应用任何查询条件时，人们必须要问查询条件是应用于单独的行还是整个组。 实际上，WHERE子句是单独的执行查询条件。SQL提供了一个名为HAVING的关键字，它允许对组级别使用查询条件。例子：查看选修了类型为选修“A”，平均成绩在70分以上的学生姓名，平均成绩。12345678SELECT Name,AVG(ISNULL(Grades,0)) AS &apos;Average Grades&apos;FROM GradesWHERE GradeType=&apos;A&apos;GROUP BY NameHAVING AVG(ISNULL(Grades,0))&gt;70ORDER BY Name 修要修类型为A，那么，这是这对行的查询，因此这里要用WHERE。但是，还要筛选平均成绩，那么，这是一个平均值，建立在聚合函数上的，并不是单独的行，这就需要用到关键字HAVING。需要先将Student分组，然后把查询结果应用到基于全组的一个聚合统计上。 WHERE只保证我们选择了GradeType是A的行，HAVING保证平均成绩至少70分以上。 注意：如果想要在结果中添加GradeType的值，如果直接在SELECT后边添加这个列，将会出错。这是因为，所有列都必须要么出现在GROUP BY中，要么包含在一个聚合函数中。123456789SELECT Name,GradeType,AVG(ISNULL(Grades,0)) AS &apos;Average Grades&apos;FROM GradesWHERE GradeType=&apos;A&apos;GROUP BY Name,GradeTypeHAVING AVG(ISNULL(Grades,0))&gt;70ORDER BY Name 十一、组合表11.1 内连接来组合表-Inner Join通过书中的描述，我感觉内连接更像是用来将主键表、外键表连接起来的工具。例如：A表： userid name age 1 michael 26 2 hhh 25 3 xiang 20 B表： orderid userid num price 1 1 2 3 2 2 6 6 3 1 5 5 如上表格，那么要连接这两个表格，查询订单1的客户姓名，年龄，订单号：方式一：1234SELECT name,age,orderidFROM A,BWHERE A.userid=B.useridAND orderid=1 方式二，使用现在的内连接实现：12345SELECT name,age,orderidFROM AINNER JOIN BON A.userid=B.useridAND orderid=1 ON关键字指定两个表如何准确的连接。 内连接中表的顺序：FROM 子句指定了A表，INNER JOIN 子句指定B表，我们调换A,B顺序，所得到的结果相同的!只是显示列的顺序可能会不同而已。 不建议使用方式一的格式。关键字INNER JOIN ON的优点在于显示地表示了连接的逻辑，那是它们唯一的用途。WEHERE的含义不够明显。因为它是条件的意思啊，不是连接的！ 11.2 外连接外连接分为左连接（LEFT OUTER JOIN)、右连接(RIGHT OUTER JOIN)、全连接（FULL OUTER JOIN)。 OUTER是可以省略的。 左连接（LEFT JOIN)12345SELECT name,age,orderidFROM ALEFT JOIN BON A.userid=B.useridAND orderid=1 外连接的强大之处在于，主表中的数据必然都会保留，从表中列没有值的情况，用NULL补充。 LEFT JOIN 左边的表为主表，右边的表为从表。 11.3 自连接自连接必然用到表的别名。1234SELECT A.name,B.name as ManagerNameFROM worker as ALEFT JOIN worker as BON A.managerid=B.id 11.4 创建视图123CREATE VIEW ViewName ASSelectStatement[WITH CHECK OPTION] 视图中不能包含ORDER BY子句。 [WITH CHECK OPTION]表示对视图进行UPDATE,INSERT,DELETE操作时任然保证了视图定义时的条件表达式。 删除视图：1DROP VIEW ViewName 修改视图：12ALTER VIEW ViewName ASSelectStatement 视图的优点 简化用户的操作 使用户以多角度看待同一数据 对重构数据库提供了一定程度的逻辑独立性 对机密数据提供安全保护 十二、补充12.1 子查询可以用3种主要的方式来指定子查询，总结如下： 当子查询是tablelist的一部分时，它指定了一个数据源。 当子查询是condition的一部分时，它成为查询条件的一部分。 当子查询是columnlist的一部分时，它创建了一个单个的计算的列。 12.2 索引索引是一种物理结构，可以为数据库表中任意的列添加索引。 索引的目的是，当SQL语句中包含该列的是偶，可以加速数据的检索。 索引的缺点是，在数据库中，索引需要更多的存储硬盘。另一个负面因素是，索引通常会降低相关的列数据更新速度。这是因为，任何时候插入或者修改一行记录时，索引都必须重新计算该列中的值的正确的排列顺序。 可以对任意的列进行索引，但是只能指定一个列作为主键。指定一个列作为主键意味着两件事情：首先这个列成为了索引，其次保证这列包含唯一的值。12CREATE INDEX Index2ON MyTable (ColumnFour) 删除一个索引：12DROP INDX Index2ON MyTable 参考： SQL总结（一）基本查询 SQL Server 常用高级语法笔记 史上最全的SQL Server复习笔记一]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜狗输入法使用技巧整理]]></title>
    <url>%2F2015%2F12%2F28%2Ftools-sougoupinyin%2F</url>
    <content type="text"><![CDATA[现在的输入法有很多，但是，哪个最好呢？不必纠结，自己用着顺手的才是最好！ 自己选择搜狗输入法的原因很简单，因为，它支持的平台多，同时，各个平台更新也很积极。从兼容性的角度考虑，还是最后选择了搜狗。至于搜狗启动的广告之类，其实不怕麻烦，是可以在设置里选择不弹出的。 作为每天使用最多的输入法，我觉得，花点时间了解它一下还是值得的，你说呢？毕竟是与我们共同作战的小伙伴啊！ 输入罗马数字+计算器属性设置-&gt;高级 需要输入罗马数字时，采用：v+”数字”，然后可以看见候选数字中有罗马数字了。 v+计算式子 就能直接获得结果 输入法截图右击输入法进入搜狗工具箱。按键-&gt;扩展功能快捷键 设置截图快捷键之后，就可以通过快捷键快速截图了！这样需要截图的时候就不需要开qq！足以应付日常的截图功能了，至于专业的，还是找专业截图的工具好了…… 自定义短语属性设置-&gt;高级-&gt;自定义短语如图，可以通过设置自定义短语，从而达到快速输入一些短语的功能。例如：设置缩写qq对应短语’你的qq邮箱’,那么下次在你需要输入QQ邮箱的时候，只需要输入qq就能显示邮箱候选了。 鼠标手势没想到，搜狗输入法鼠标手势也有，再方便不过了。可以通过扩展箱安装。如果担心鼠标手势和某些应用程序内的手势冲突，可以通过设置来定义在某些程序里边不启用鼠标手势。PS：现在已经喜欢上搜狗鼠标手势的全局缩小，全局最大化的功能了。浏览器一下子可以快速最小化和最大化呢。防止boss突袭。 手写输入通过扩展工具箱里的首席输入扩展，可以在遇到陌生字时，手写输入。 Tab拆字辅助码笔画笔画筛选用于输入单字时，用笔顺来快速定位该字。使用方法是输入一个字或多个字后，按下tab键（tab键如果是翻页的话也不受影响），然后用h横、s 竖、p撇、n捺、z折依次输入第一个字的笔顺，一直找到该字为止。五个笔顺的规则同上面的笔画输入的规则。要退出笔画筛选模式，只需删掉已经输入的笔画辅助码即可。 例如，快速定位【珍】字，输入了zhen后，按下【tab】，然后输入珍的前两笔【hh】，就可定位该字。 或者输入一个不怎么用的词：威赫（wei he），这个词不在第一页，这种情况下不要翻页。输入weihe，然后按tab键，会进入一个笔画模式，你可以用横撇竖点（hpsd）定位到字。这里，“威”字笔顺是横、撇、横、撇点、撇、横、斜钩、撇、点，所以你输入weihe之后，按一下tab，然后输入hp，看看是不是把第一个字是威的提到前 面了？如果还不够精确，可以继续输入下面的笔画，一般输入3笔左右就够了，然后按0只显示单字，选中威之后再选下一个。 Tab拆字辅助码拼音拆字辅助码让你快速的定位到一个单字，使用方法如下：想输入一个汉字【娴】，但是非常靠后，找不到，那么输入【xian】，然后按下【tab】键，在输入【娴】的两部分【女】【闲】的首字母nx，就可以看到只剩下【娴】字了。输入的顺序为xian+tab+nx。 难字按u键进行偏旁和笔画输入U模式是专门为输入不会读的字所设计的。在输入u键后，然后依次输入一个字的笔顺，笔顺为：h横、s竖、p撇、n捺、z折，就可以得到该字，同时小键盘上的1、2、3、4、5也代表h、s、p、n、z。这里的笔顺规则与普通手机上的五笔画输入是完全一样的。其中点也可以用d来输入。由于双拼占用了u键，智能ABC的笔画规则不是五笔画，所以双拼和智能ABC下都没有u键模式。 对于只认识偏旁部首，不清楚字音的字，像“黏”、“亓”等，我们可以这样输入：u+偏旁部首的读音，或者u+字的顺序笔画。对于即清楚字形，又清楚字音的，只是候选位置比较靠后的字，比如“幂”、“祎”等，我们可以这样输入： 读音+tab键+偏旁的读音首字母，例如“幂”字的偏旁是“秃宝盖”，对应的字母就是“t”，“祎”字的偏旁部首对应的读音分别是“s”（示补旁）、“w”（韦）。对于只知道读音，不清楚怎么写的字，我们可以这样输入： 比如“耄”，我们知道它是“耄耋”中的一个字，可以输入maodie，然后按“[”键，上屏当前候选第一个字； 比如“餮”，我们知道它是“饕餮”中的一个字，可以输入taotie，然后按“]”键，上屏当前候选第二个字； 生活小技巧（农历，诗句等） 键入rq选择1得到××××年××月××日格式时间，选择2得到××××-××-××格式时间，选择3得到例如二〇〇八年三月三十一日的时间 键入llysc选择2得到：离离原上草，一岁一枯荣。野火烧不尽，春风吹又生。远芳侵古道，晴翠接荒城。又送王孙去，萋萋满别情。 比较常用的特殊符号，如↑之类 键入pai选择3得到π 键入aerfa选择2得到希腊字母α，依此类推 键入wjx选择3、4分别得到☆和★ 键入sjt、xjt、zjt、yjt分别得到↑、↓、←和→ 键入sjx选择3、4分别得到△和▲ 参考： 搜狗输入法使用实用技巧分享 拼音输入法有哪些鲜为人知的技巧？]]></content>
      <categories>
        <category>ToolsDaily</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>输入法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遗传算法GA(Genetic Algorithm)入门知识梳理]]></title>
    <url>%2F2015%2F12%2F24%2Falgorithm-GA-basic%2F</url>
    <content type="text"><![CDATA[一、遗传算法进化论背景知识作为遗传算法生物背景的介绍，下面内容了解即可： 种群(Population)：生物的进化以群体的形式进行，这样的一个群体称为种群。 个体：组成种群的单个生物。 基因 ( Gene ) ：一个遗传因子。 染色体 ( Chromosome ) ：包含一组的基因。 生存竞争，适者生存：对环境适应度高的、牛B的个体参与繁殖的机会比较多，后代就会越来越多。适应度低的个体参与繁殖的机会比较少，后代就会越来越少。 遗传与变异：新个体会遗传父母双方各一部分的基因，同时有一定的概率发生基因变异。 简单说来就是：繁殖过程，会发生基因交叉( Crossover ) ，基因突变 ( Mutation ) ，适应度( Fitness )低的个体会被逐步淘汰，而适应度高的个体会越来越多。那么经过N代的自然选择后，保存下来的个体都是适应度很高的，其中很可能包含史上产生的适应度最高的那个个体。 二、遗传算法思想GA的组成: 编码（产生初始种群） 适应度函数 遗传算子（选择、交叉、变异） 运行参数 借鉴生物进化论，遗传算法将要解决的问题模拟成一个生物进化的过程，通过复制、交叉、突变等操作产生下一代的解，并逐步淘汰掉适应度函数值低的解，增加适应度函数值高的解。这样进化N代后就很有可能会进化出适应度函数值很高的个体。 举个例子，使用遗传算法解决“0-1背包问题”的思路：0-1背包的解可以编码为一串0-1字符串（0：不取，1：取） ；首先，随机产生M个0-1字符串，然后评价这些0-1字符串作为0-1背包问题的解的优劣；然后，随机选择一些字符串通过交叉、突变等操作产生下一代的M个字符串，而且较优的解被选中的概率要比较高。这样经过G代的进化后就可能会产生出0-1背包问题的一个“近似最优解”。 2.1 编码需要将问题的解编码成字符串的形式才能使用遗传算法。最简单的一种编码方式是二进制编码，即将问题的解编码成二进制位数组的形式。例如，问题的解是整数，那么可以将其编码成二进制位数组的形式。将0-1字符串作为0-1背包问题的解就属于二进制编码。 基因在一定能够意义上包含了它所代表的问题的解。基因的编码方式有很多，这也取决于要解决的问题本身。常见的编码方式有： 二进制编码，基因用0或1表示（常用于解决01背包问题） 如：基因A：00100011010 (代表一个个体的染色体) 互换编码（用于解决排序问题，如旅行商问题和调度问题） 如旅行商问题中，一串基因编码用来表示遍历的城市顺序，如：234517986，表示九个城市中，先经过城市2，再经过城市3，依此类推。 树形编码（用于遗传规划中的演化编程或者表示） 如,问题：给定了很多组输入和输出。请你为这些输入输出选择一个函数，使得这个函数把每个输入尽可能近地映射为输出。 编码方法：基因就是树形结构中的一些函数。 值编码 （二进制编码不好用时，解决复杂的数值问题） 在值编码中，每个基因就是一串取值。这些取值可以是与问题有关任何值：整数，实数，字符或者其他一些更复杂的东西。 2.2 适应度函数适应度函数 ( Fitness Function )：用于评价某个染色体的适应度，用f(x)表示。有时需要区分染色体的适应度函数与问题的目标函数。例如：0-1背包问题的目标函数是所取得物品价值，但将物品价值作为染色体的适应度函数可能并不一定适合。适应度函数与目标函数是正相关的，可对目标函数作一些变形来得到适应度函数。 遗传算子：遗传算法有3个最基本的操作：选择，交叉，变异。 2.3 选择选择一些染色体来产生下一代。一种常用的选择策略是 “比例选择”，也就是个体被选中的概率与其适应度函数值成正比。假设群体的个体总数是M，那么那么一个体Xi被选中的概率为f(Xi)/( f(X1) + f(X2) + …….. + f(Xn) ) 。比例选择实现算法就是所谓的“轮盘赌算法”( Roulette Wheel Selection )。 123456789101112131415161718192021222324252627282930313233轮盘赌算法/** 按设定的概率，随机选中一个个体* P[i]表示第i个个体被选中的概率*/int RWS()&#123;m =0;r =Random(0,1); //r为0至1的随机数for(i=1;i&lt;=N; i++)&#123;/* 产生的随机数在m~m+P[i]间则认为选中了i* 因此i被选中的概率是P[i]*/m = m + P[i];if(r&lt;=m) return i; 2.4 交叉所谓交叉运算，是指对两个相互配对的染色体依据交叉概率按某种方式相互交换其部分基因，从而形成两个新的个体。交叉运算在GA中起关键作用，是产生新个体的主要方法。 2.4.1 2条染色体交换部分基因，来构造下一代的2条新的染色体。例如：交叉前： 00000|011100000000|10000 11100|000001111110|00101 交叉后： 00000|000001111110|10000 11100|011100000000|00101 染色体交叉是以一定的概率发生的，这个概率记为Pc 。 2.4.2 双交叉点法 （用于二进制编码）选择两个交叉点,子代基因在两个交叉点间部分来自一个父代基因,其余部分来自于另外一个父代基因. 如： 交叉前： 01 |0010| 11 11 |0111| 01 交叉后： 11 |0010| 01 01 |0111| 11 2.4.3. 基于“ 与/或 ”交叉法 （用于二进制编码）对父代按位”与”逻辑运算产生一子代A;按位”或”逻辑运算产生另一子代B。该交叉策略在解背包问题中效果较好 . 如： 交叉前： 01001011 11011101 交叉后： 01001001 11011111 还有其他交叉方法，参考遗传算法学习心得 2.5 变异变异是指依据变异概率将个体编码串中的某些基因值用其它基因值来替换，从而形成一个新的个体。GA中的变异运算是产生新个体的辅助方法，它决定了GA的局部搜索能力，同时保持种群的多样性。交叉运算和变异运算的相互配合，共同完成对搜索空间的全局搜索和局部搜索。 注：变异概率Pm不能太小，这样降低全局搜索能力；也不能太大，Pm &gt; 0.5，这时GA退化为随机搜索。 在繁殖过程，新产生的染色体中的基因会以一定的概率出错，称为变异。变异发生的概率记为Pm 。 2.5.1. 基本位变异算子 （用于二进制编码）基本位变异算子是指对个体编码串随机指定的某一位或某几位基因作变异运算。对于基本遗传算法中用二进制编码符号串所表示的个体，若需要进行变异操作的某一基因座上的原有基因值为0，则变异操作将其变为1；反之，若原有基因值为1，则变异操作将其变为0。 变异前： 000001110000000010000 变异后： 000001110000100010000 2.5.2. 逆转变异算子（用于互换编码）在个体中随机挑选两个逆转点，再将两个逆转点间的基因交换。 如： 变异前： 1346798205 变异后： 1246798305 2.6 运行参数GA运行时选择的参数应该视解决的具体问题而定，到目前为止，还没有一个适用于GA所有应用领域的关于算法参数的理论。下面是一般情况下使用GA时推荐的参数： 2.6.1 交叉率交叉率一般来说应该比较大，推荐使用80％-95％。 2.6.2 变异率变异率一般来说应该比较小，一般使用0.5％-1％最好。 2.6.3 种群的规模种群规模指的是群体中个体的个数。实验发现，比较大的种群的规模并不能优化遗传算法的结果。种群的大小推荐使用20-30，一些研究表明，种群规模 的大小取决于编码的方法，具体的说就是编码串（Encoded String）的大小。也就是说，如果说采用32位为基因编码的时候种群的规模大小最好为32的话，那么当采用16位为基因编码时种群的规模相应应变为原 来的两倍。 2.6.4 遗传运算的终止进化代数个人的想法是，设定一个计数器，如果连续N代出现的最优个体的适应度都一样时，（严格的说应该是，连续N代子代种群的最优个体适应度都&lt;=父代最优个性的适应度）可以终止运算。 三、SGA（基本遗传算法）的伪代码SGA（基本遗传算法）中采用轮盘赌选择方法 3.1算法流程图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960基本遗传算法伪代码/** Pc：交叉发生的概率* Pm：变异发生的概率* M：种群规模* G：终止进化的代数* Tf：进化产生的任何一个个体的适应度函数超过Tf，则可以终止进化过程*/初始化Pm，Pc，M，G，Tf等参数。随机产生第一代种群Popdo&#123; 计算种群Pop中每一个体的适应度F(i)。 初始化空种群newPop do &#123; 根据适应度以比例选择算法从种群Pop中选出2个个体 if ( random ( 0 , 1 ) &lt; Pc ) &#123; 对2个个体按交叉概率Pc执行交叉操作 &#125; if ( random ( 0 , 1 ) &lt; Pm ) &#123; 对2个个体按变异概率Pm执行变异操作 &#125;将2个新个体加入种群newPop中&#125; until ( M个子代被创建 )用newPop取代Pop&#125;until ( 任何染色体得分超过Tf， 或繁殖代数超过G ) 四、基本遗传算法的优化下面的方法可优化遗传算法的性能。 4.1 灾变遗传算法的局部搜索能力较强，但是很容易陷入局部极值。引用网上的一段原话: “那么如何解决遗传算法容易陷入局部极值的问题呢？让我们来看看大自然提供的方案。 六千五百万年以前，恐龙和灵长类动物并存，恐龙在地球上占绝对统 治地位，如果恐龙没有灭绝灵长类动物是绝没有可能统治地球的。正是恐龙的灭绝才使灵长类动物有了充分进化的余地，事实上地球至少经历了5次物种大灭绝，每 次物种灭绝都给更加高级的生物提供了充分进化的余地。所以要跳出局部极值就必须杀死当前所有的优秀个体，从而让远离当前极值的点有充分的进化余地。这就是灾变的思想。” 灾变就是杀掉最优秀的个体，这样才可能产生更优秀的物种。那何时进行灾变，灾变次数又如何设定？ 何时进行灾变，可以采用灾变倒计数的方式。如果n代还没有出现比之前更优秀的个体时，可以发生灾变。灾变次数可以这样来确定，如果若干次灾变后产生的个体的适应度与没灾变前的一样，可停止灾变。 4.2 精英主义(Elitist Strategy)选择：当利用交叉和变异产生新的一代时，我们有很大的可能把在某个中间步骤中得到的最优解丢失。 精英主义的思想是,在每一次产生新的一代时，首先把当前最优解原封不动的复制到新的一代中。然后按照前面所说的那样做就行。精英主义方法可以大幅提高运算速度，因为它可以防止丢失掉找到的最好的解。 精英主义是基本遗传算法的一种优化。为了防止进化过程中产生的最优解被交叉和变异所破坏，可以将每一代中的最优解原封不动的复制到下一代中。 4.3 矛盾由上面看来,灾变与精英主义之间似乎存在着矛盾.前者是将产生的最优个体杀掉,而后者是将最优秀个体基因直接保存到下一代. 应该辩证地看待它们之间的矛盾,两者其实是可以共存的.我们在每一代进行交叉运算时,均直接把最优秀的个体复制到下一代;但当连续N代,都没有更优 秀的个体出现时,便可以猜想可能陷入局部最优解了,这样可以采用灾变的手段.可以说,精英主义是伴随的每一代的,但灾变却不需要经常发生,否则算法可能下 降为随机搜索了. 当然,每个算法中不一定要用精英主义和灾变的手段,应该根据具体的问题而定 4.4 插入操作：可在3个基本操作的基础上增加一个插入操作。插入操作将染色体中的某个随机的片段移位到另一个随机的位置。 五、GA算法特点5.1 遗传算法的优点: 群体搜索，易于并行化处理； 不是盲目穷举，而是启发式搜索； 适应度函数不受连续、可微等条件的约束，适用范围很广。 容易实现。一旦有了一个遗传算法的程序，如果想解决一个新的问题，只需针对新的问题重新进行基因编码就行；如果编码方法也相同，那只需要改变一下适应度函数就可以了。 5.2 遗传算法的缺点: 全局搜索能力不强,很容易陷入局部最优解跳不出来；(可结合SA进行改进,因为SA在理率上是100%得到全局最优的,但搜索代价高) 将遗传算法用于解决各种实际问题后，人们发现遣传算法也会由于各种原因过早向目标函数的局部最优解收敛，从而很难找到全局最优解。其中有些是由于目标函数的特性造成的，例如函数具有欺骗性，不满足构造模块假说等等；另外一些则是由于算法设计不当。为此，不断有人对遗传算法提出各种各样的改进方案。例如：针对原先的定长二进制编码方案；提出了动态编码、实数编码等改进方案；针对按比例的选择机制，提出了竞争选择、按续挑选等改进方案；针对原先的一点交算子，提出了两点交、多点交、均匀交等算子；针对原先遗传算法各控制参数在进化过程中不变的情况，提出了退化遗传算法、自适应遗传算法等。另外，针对不同问题还出现了分布式遗传算法、并行遗传算法等等。 六、遗传算法的实例参考：参考文献都是干货！！！参考文献都是干货！！！参考文献都是干货！！！ 遗传算法入门-博客园-苍梧本文主要参考，推荐！感谢作者~ 经典算法研究系列：七、深入浅出遗传算法July大神写的，通俗易懂，推荐！！！ HELLO，遗传算法！博主语言轻松，用python描述了遗传算法求解一个函数最大值的例子。 遗传算法理论基础与简单应用实例博主总结整理的内容，挺不错的，文中的链接有实例应用。 遗传算法入门到掌握（一） CSDN-GA代码下载袋鼠跳的例子来描述了GA算法，帮助理解GA。 非常好的理解遗传算法的例子求下述二元函数的最大值的例子 遗传算法学习心得 本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python数据分析入门之pandas总结基础]]></title>
    <url>%2F2015%2F12%2F23%2Fpython-pandas-basic%2F</url>
    <content type="text"><![CDATA[Pandas–“大熊猫”基础SeriesSeries: pandas的长枪(数据表中的一列或一行,观测向量,一维数组…) 12345678Series1 = pd.Series(np.random.randn(4))print Series1,type(Series1) print Series1.indexprint Series1.values 输出结果： 12345678910111213140 -0.6762561 0.5330142 -0.9352123 -0.940822dtype: float64 &lt;class &apos;pandas.core.series.Series&apos;&gt;Int64Index([0, 1, 2, 3], dtype=&apos;int64&apos;)[-0.67625578 0.53301431 -0.93521212 -0.94082195] np.random.randn() 正态分布相关。函数说明 Series⽀持过滤的原理就如同NumPy1234print Series1&gt;0 print Series1[Series1&gt;0] 输出结果如下： 12345678910111213140 0.0304801 0.0727462 -0.1866073 -1.412244dtype: float64 &lt;class &apos;pandas.core.series.Series&apos;&gt;Int64Index([0, 1, 2, 3], dtype=&apos;int64&apos;)[ 0.03048042 0.07274621 -0.18660749 -1.41224432] 我发现，逻辑表达式，获得的值就是True或者False。要先取得值，还是要X[y]的形式。 当然也支持广播Broadcasting什么是broadcasting,暂时我也不太清楚，看个栗子： 1234print Series1*2 print Series1+5 输出结果如下： 123456789101112131415161718190 0.060961 1 0.145492 2 -0.373215 3 -2.824489 dtype: float64 0 5.030480 1 5.072746 2 4.813393 3 3.587756 dtype: float64 以及Universal Functionnumpy.frompyfunc(out,nin,nout) 返回的是一个函数，nin是输入的参数个数，nout是函数返回的对象的个数函数说明 在序列上就使用行标，而不是创建1个2列的数据表，能够轻松辨别哪是数据，哪是元数据这句话的意思，我的理解是序列尽量是一列，不用去创建2列，这样子，使用index就能指定数据了 12345678910Series2 = pd.Series(Series1.values,index=[&apos;norm_&apos;+unicode(i) for i in xrange(4)])print Series2,type(Series2)print Series2.indexprint type(Series2.index)print Series2.values 输出结果如下，可以看到，它是通过修改了index值的样式，并没有创建2列。 12345678910111213141516norm_0 -0.676256norm_1 0.533014norm_2 -0.935212norm_3 -0.940822dtype: float64 &lt;class &apos;pandas.core.series.Series&apos;&gt;Index([u&apos;norm_0&apos;, u&apos;norm_1&apos;, u&apos;norm_2&apos;, u&apos;norm_3&apos;], dtype=&apos;object&apos;)&lt;class &apos;pandas.core.index.Index&apos;&gt;[-0.67625578 0.53301431 -0.93521212 -0.94082195] 虽然行是有顺序的，但是仍然能够通过行级的index来访问到数据： （当然也不尽然像Ordered Dict，因为⾏索引甚⾄可以重复，不推荐重复的行索引不代表不能用） 12print Series2[[&apos;norm_0&apos;,&apos;norm_3&apos;]] 可以看到，读取数据时，确实要采用X[y]的格式。这里X[[y]]是因为，它要读取两个数据，指定的是这两个数据的index值，将index值存放进list中，然后读取。输出结果如下： 123456norm_0 -0.676256norm_3 -0.940822dtype: float64 再比如： 1234print &apos;norm_0&apos; in Series2print &apos;norm_6&apos; in Series2 输出结果： 1234TrueFalse 逻辑表达式的输出结果，布尔型值。 从Key不重复的Ordered Dict或者从Dict来定义Series就不需要担心行索引重复：12345678910Series3_Dict = &#123;&quot;Japan&quot;:&quot;Tokyo&quot;,&quot;S.Korea&quot;:&quot;Seoul&quot;,&quot;China&quot;:&quot;Beijing&quot;&#125;Series3_pdSeries = pd.Series(Series3_Dict)print Series3_pdSeriesprint Series3_pdSeries.valuesprint Series3_pdSeries.index 输出结果： 123456789101112China BeijingJapan TokyoS.Korea Seouldtype: object[&apos;Beijing&apos; &apos;Tokyo&apos; &apos;Seoul&apos;]Index([u&apos;China&apos;, u&apos;Japan&apos;, u&apos;S.Korea&apos;], dtype=&apos;object&apos;) 通过上面的输出结果就知道了，输出结果是无序的，和输入顺序无关。 想让序列按你的排序⽅式保存？就算有缺失值都毫无问题 1234567891011121314Series4_IndexList = [&quot;Japan&quot;,&quot;China&quot;,&quot;Singapore&quot;,&quot;S.Korea&quot;]Series4_pdSeries = pd.Series( Series3_Dict ,index = Series4_IndexList)print Series4_pdSeriesprint Series4_pdSeries.valuesprint Series4_pdSeries.indexprint Series4_pdSeries.isnull()print Series4_pdSeries.notnull() 上面这样的输出就会按照list中定义的顺序输出结果。 整个序列级别的元数据信息：name 当数据序列以及index本身有了名字，就可以更方便的进行后续的数据关联啦！ 这里我感觉就是列名的作用。下面举例： 1234print Series4_pdSeries.nameprint Series4_pdSeries.index.name 很显然，输出的结果都是None，因为我们还没指定name嘛！ 123456Series4_pdSeries.name = &quot;Capital Series&quot;Series4_pdSeries.index.name = &quot;Nation&quot;print Series4_pdSeries 输出结果： 123456789101112NationJapan TokyoChina BeijingSingapore NaNS.Korea SeoulName: Capital Series, dtype: object “字典”？不是的，⾏index可以重复，尽管不推荐。 12345678Series5_IndexList = [&apos;A&apos;,&apos;B&apos;,&apos;B&apos;,&apos;C&apos;]Series5 = pd.Series(Series1.values,index = Series5_IndexList)print Series5print Series5[[&apos;B&apos;,&apos;A&apos;]] 输出结果： 123456789101112131415161718A 0.030480B 0.072746B -0.186607C -1.412244dtype: float64B 0.072746B -0.186607A 0.030480dtype: float64 我们可以看出，Series[‘B’]输出了两个值，所以index值尽量不要重复呀！ DataFrameDataFrame：pandas的战锤(数据表，⼆维数组) Series的有序集合，就像R的DataFrame一样方便。 仔细想想，绝大部分的数据形式都可以表现为DataFrame。 从NumPy二维数组、从文件或者从数据库定义：数据虽好，勿忘列名123456dataNumPy = np.asarray([(&apos;Japan&apos;,&apos;Tokyo&apos;,4000),(&apos;S.Korea&apos;,&apos;Seoul&apos;,1300),(&apos;China&apos;,&apos;Beijing&apos;,9100)])DF1 = pd.DataFrame(dataNumPy,columns=[&apos;nation&apos;,&apos;capital&apos;,&apos;GDP&apos;])DF1 这里DataFrame中的columns应该就是列名的意思。现在看print的结果，是不是很舒服啊！Excel的样式嘛 等长的列数据保存在一个字典里（JSON）：很不幸，字典key是无序的123456dataDict = &#123;&apos;nation&apos;:[&apos;Japan&apos;,&apos;S.Korea&apos;,&apos;China&apos;],&apos;capital&apos;:[&apos;Tokyo&apos;,&apos;Seoul&apos;,&apos;Beijing&apos;],&apos;GDP&apos;:[4900,1300,9100]&#125;DF2 = pd.DataFrame(dataDict)DF2 输出结果可以发现，无序的！ 1234567 GDP capital nation0 4900 Tokyo Japan1 1300 Seoul S.Korea2 9100 Beijing China PS:由于懒得截图放过来，这里没有了边框线。 从另一个DataFrame定义DataFrame：啊，强迫症犯了！1234DF21 = pd.DataFrame(DF2,columns=[&apos;nation&apos;,&apos;capital&apos;,&apos;GDP&apos;])DF21 很明显，这里是利用DF2定义DF21，还通过指定cloumns改变了列名的顺序。 1234DF22 = pd.DataFrame(DF2,columns=[&apos;nation&apos;,&apos;capital&apos;,&apos;GDP&apos;],index = [2,0,1])DF22 很明显，这里定义了columns的顺序，还定义了index的顺序。 12345678nation capital GDP2 China Beijing 91000 Japan Tokyo 49001 S.Korea Seoul 1300 从DataFrame中取出列？两种方法（与JavaScript完全一致！）OMG，囧，我竟然都快忘了js语法了，现在想起了，但是对象的属性既可以obj.x也可以obj[x]。 ‘.’的写法容易与其他预留关键字产生冲突 ‘[ ]’的写法最安全。 从DataFrame中取出行？（至少）两种⽅法： 方法1和方法2： 1234print DF22[0:1] #给出的实际是DataFrameprint DF22.ix[0] #通过对应Index给出⾏,**ix**好爽。 输出结果： 123456789101112 nation capital GDP2 China Beijing 9100nation Japancapital TokyoGDP 4900Name: 0, dtype: object 方法3 像NumPy切片一样的终极招式：iloc ： 1234print DF22.iloc[0,:] #第一个参数是第几行，第二个参数是列。这里呢，就是第0行，全部列print DF22.iloc[:,0] #根据上面的描述，这里是全部行，第0列 输出结果，验证一下： 12345678910111213141516nation Chinacapital BeijingGDP 9100Name: 2, dtype: object2 China0 Japan1 S.KoreaName: nation, dtype: object 动态增加列列，但是无法用”.”的方式，只能用”[]”举个栗子说明一下就明白了： 1234DF22[&apos;population&apos;] = [1600,130,55]DF22 输出结果： 12345678nation capital GDP population2 China Beijing 9100 16000 Japan Tokyo 4900 1301 S.Korea Seoul 1300 55 Index：行级索引Index：pandas进⾏数据操纵的鬼牌（行级索引） ⾏级索引是： 元数据 可能由真实数据产生，因此可以视作数据 可以由多重索引也就是多个列组合而成 可以和列名进行交换，也可以进行堆叠和展开，达到Excel透视表效果 Index有四种…哦不，很多种写法，⼀些重要的索引类型包括： pd.Index（普通） Int64Index（数值型索引） MultiIndex（多重索引，在数据操纵中更详细描述） DatetimeIndex（以时间格式作为索引） PeriodIndex （含周期的时间格式作为索引） 直接定义普通索引，长得就和普通的Series⼀样12345678index_names = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]Series_for_Index = pd.Series(index_names)print pd.Index(index_names)print pd.Index(Series_for_Index) 输出结果： 1234Index([u&apos;a&apos;, u&apos;b&apos;, u&apos;c&apos;], dtype=&apos;object&apos;)Index([u&apos;a&apos;, u&apos;b&apos;, u&apos;c&apos;], dtype=&apos;object&apos;) 可惜Immutable，牢记！ 不可变！举例如下：此处挖坑啊。不明白…… 12345678index_names = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;] index0 = pd.Index(index_names) print index0.get_values() index0[2] = &apos;d&apos; 输出结果如下： 1234567891011121314151617181920212223242526272829303132[&apos;a&apos; &apos;b&apos; &apos;c&apos;]---------------------------------------------------------------------------TypeError Traceback (most recent call last)&lt;ipython-input-36-f34da0a8623c&gt; in &lt;module&gt;() 2 index0 = pd.Index(index_names) 3 print index0.get_values()----&gt; 4 index0[2] = &apos;d&apos;C:\Anaconda\lib\site-packages\pandas\core\index.pyc in __setitem__(self, key, value) 1055 1056 def __setitem__(self, key, value):-&gt; 1057 raise TypeError(&quot;Indexes does not support mutable operations&quot;) 1058 1059 def __getitem__(self, key):TypeError: Indexes does not support mutable operations 扔进去一个含有多元组的List，就有了MultiIndex可惜，如果这个List Comprehension改成小括号，就不对了。 123456multi1 = pd.Index([(&apos;Row_&apos;+str(x+1),&apos;Col_&apos;+str(y+1)) for x in xrange(4) for y in xrange(4)])multi1.name = [&apos;index1&apos;,&apos;index2&apos;]print multi1 输出结果： 1234MultiIndex(levels=[[u&apos;Row_1&apos;, u&apos;Row_2&apos;, u&apos;Row_3&apos;, u&apos;Row_4&apos;], [u&apos;Col_1&apos;, u&apos;Col_2&apos;, u&apos;Col_3&apos;, u&apos;Col_4&apos;]], labels=[[0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3], [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]]) 对于Series来说，如果拥有了多重Index，数据，变形！下列代码说明： 二重MultiIndex的Series可以unstack()成DataFrame DataFrame可以stack成拥有⼆重MultiIndex的Series 1234data_for_multi1 = pd.Series(xrange(0,16),index=multi1)data_for_multi1 输出结果： 1234567891011121314151617181920212223242526272829Row_1 Col_1 0 Col_2 1 Col_3 2 Col_4 3Row_2 Col_1 4 Col_2 5 Col_3 6 Col_4 7Row_3 Col_1 8 Col_2 9 Col_3 10 Col_4 11Row_4 Col_1 12 Col_2 13 Col_3 14 Col_4 15dtype: int32 看到输出结果，好像明白了点，有点类似Excel汇总一样。不过，日后还得查点资料 二重MultiIndex的Series可以unstack()成DataFrame12data_for_multi1.unstack() DataFrame可以stack成拥有⼆重MultiIndex的Series12data_for_multi1.unstack().stack() 输出结果： 12345678910111213141516171819202122232425262728293031323334Row_1 Col_1 0 Col_2 1 Col_3 2 Col_4 3Row_2 Col_1 4 Col_2 5 Col_3 6 Col_4 7Row_3 Col_1 8 Col_2 9 Col_3 10 Col_4 11Row_4 Col_1 12 Col_2 13 Col_3 14 Col_4 15dtype: int32 非平衡数据的例子：1234multi2 = pd.Index([(&apos;Row_&apos;+str(x+1),&apos;Col_&apos;+str(y+1)) for x in xrange(5) for y in xrange(x)])multi2 输出结果： 1234MultiIndex(levels=[[u&apos;Row_2&apos;, u&apos;Row_3&apos;, u&apos;Row_4&apos;, u&apos;Row_5&apos;], [u&apos;Col_1&apos;, u&apos;Col_2&apos;, u&apos;Col_3&apos;, u&apos;Col_4&apos;]], labels=[[0, 1, 1, 2, 2, 2, 3, 3, 3, 3], [0, 0, 1, 0, 1, 2, 0, 1, 2, 3]]) 12data_for_multi2 = pd.Series(np.arange(10),index = multi2) data_for_multi2 输出结果： 12345678910111213141516171819202122Row_2 Col_1 0Row_3 Col_1 1 Col_2 2Row_4 Col_1 3 Col_2 4 Col_3 5Row_5 Col_1 6 Col_2 7 Col_3 8 Col_4 9dtype: int32 DateTime标准库如此好⽤，你值得拥有123456import datetimedates = [datetime.datetime(2015,1,1),datetime.datetime(2015,1,8),datetime.datetime(2015,1,30)]pd.DatetimeIndex(dates) 输出结果： 12DatetimeIndex([&apos;2015-01-01&apos;, &apos;2015-01-08&apos;, &apos;2015-01-30&apos;], dtype=&apos;datetime64[ns]&apos;, freq=None, tz=None) 如果你不仅需要时间格式统一，时间频率也要统一的话1234periodindex1 = pd.period_range(&apos;2015-01&apos;,&apos;2015-04&apos;,freq=&apos;M&apos;)print periodindex1 输出结果： 12PeriodIndex([&apos;2015-01&apos;, &apos;2015-02&apos;, &apos;2015-03&apos;, &apos;2015-04&apos;], dtype=&apos;int64&apos;, freq=&apos;M&apos;) 月级精度和日级精度如何转换？有的公司统⼀以1号代表当月，有的公司统一以最后1天代表当⽉，转化起来很麻烦，可以asfreq 1234print periodindex1.asfreq(&apos;D&apos;,how=&apos;start&apos;)print periodindex1.asfreq(&apos;D&apos;,how=&apos;end&apos;) 输出结果： 1234PeriodIndex([&apos;2015-01-01&apos;, &apos;2015-02-01&apos;, &apos;2015-03-01&apos;, &apos;2015-04-01&apos;], dtype=&apos;int64&apos;, freq=&apos;D&apos;)PeriodIndex([&apos;2015-01-31&apos;, &apos;2015-02-28&apos;, &apos;2015-03-31&apos;, &apos;2015-04-30&apos;], dtype=&apos;int64&apos;, freq=&apos;D&apos;) 最后的最后，我要真正把两种频率的时间精度匹配上？12345678periodindex_mon = pd.period_range(&apos;2015-01&apos;,&apos;2015-03&apos;,freq=&apos;M&apos;).asfreq(&apos;D&apos;,how=&apos;start&apos;)periodindex_day = pd.period_range(&apos;2015-01-01&apos;,&apos;2015-03-31&apos;,freq=&apos;D&apos;)print periodindex_monprint periodindex_day 输出结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950PeriodIndex([&apos;2015-01-01&apos;, &apos;2015-02-01&apos;, &apos;2015-03-01&apos;], dtype=&apos;int64&apos;, freq=&apos;D&apos;)PeriodIndex([&apos;2015-01-01&apos;, &apos;2015-01-02&apos;, &apos;2015-01-03&apos;, &apos;2015-01-04&apos;, &apos;2015-01-05&apos;, &apos;2015-01-06&apos;, &apos;2015-01-07&apos;, &apos;2015-01-08&apos;, &apos;2015-01-09&apos;, &apos;2015-01-10&apos;, &apos;2015-01-11&apos;, &apos;2015-01-12&apos;, &apos;2015-01-13&apos;, &apos;2015-01-14&apos;, &apos;2015-01-15&apos;, &apos;2015-01-16&apos;, &apos;2015-01-17&apos;, &apos;2015-01-18&apos;, &apos;2015-01-19&apos;, &apos;2015-01-20&apos;, &apos;2015-01-21&apos;, &apos;2015-01-22&apos;, &apos;2015-01-23&apos;, &apos;2015-01-24&apos;, &apos;2015-01-25&apos;, &apos;2015-01-26&apos;, &apos;2015-01-27&apos;, &apos;2015-01-28&apos;, &apos;2015-01-29&apos;, &apos;2015-01-30&apos;, &apos;2015-01-31&apos;, &apos;2015-02-01&apos;, &apos;2015-02-02&apos;, &apos;2015-02-03&apos;, &apos;2015-02-04&apos;, &apos;2015-02-05&apos;, &apos;2015-02-06&apos;, &apos;2015-02-07&apos;, &apos;2015-02-08&apos;, &apos;2015-02-09&apos;, &apos;2015-02-10&apos;, &apos;2015-02-11&apos;, &apos;2015-02-12&apos;, &apos;2015-02-13&apos;, &apos;2015-02-14&apos;, &apos;2015-02-15&apos;, &apos;2015-02-16&apos;, &apos;2015-02-17&apos;, &apos;2015-02-18&apos;, &apos;2015-02-19&apos;, &apos;2015-02-20&apos;, &apos;2015-02-21&apos;, &apos;2015-02-22&apos;, &apos;2015-02-23&apos;, &apos;2015-02-24&apos;, &apos;2015-02-25&apos;, &apos;2015-02-26&apos;, &apos;2015-02-27&apos;, &apos;2015-02-28&apos;, &apos;2015-03-01&apos;, &apos;2015-03-02&apos;, &apos;2015-03-03&apos;, &apos;2015-03-04&apos;, &apos;2015-03-05&apos;, &apos;2015-03-06&apos;, &apos;2015-03-07&apos;, &apos;2015-03-08&apos;, &apos;2015-03-09&apos;, &apos;2015-03-10&apos;, &apos;2015-03-11&apos;, &apos;2015-03-12&apos;, &apos;2015-03-13&apos;, &apos;2015-03-14&apos;, &apos;2015-03-15&apos;, &apos;2015-03-16&apos;, &apos;2015-03-17&apos;, &apos;2015-03-18&apos;, &apos;2015-03-19&apos;, &apos;2015-03-20&apos;, &apos;2015-03-21&apos;, &apos;2015-03-22&apos;, &apos;2015-03-23&apos;, &apos;2015-03-24&apos;, &apos;2015-03-25&apos;, &apos;2015-03-26&apos;, &apos;2015-03-27&apos;, &apos;2015-03-28&apos;, &apos;2015-03-29&apos;, &apos;2015-03-30&apos;, &apos;2015-03-31&apos;], dtype=&apos;int64&apos;, freq=&apos;D&apos;) 粗粒度数据＋reindex＋ffill/bfill1234full_ts = pd.Series(periodindex_mon,index=periodindex_mon).reindex(periodindex_day,method=&apos;ffill&apos;)full_ts 关于索引，⽅便的操作有？前⾯描述过了，索引有序，重复，但⼀定程度上⼜能通过key来访问，也就是说，某些集合操作都是可以⽀持的。 1234567891011121314151617181920212223242526index1 = pd.Index([&apos;A&apos;,&apos;B&apos;,&apos;B&apos;,&apos;C&apos;,&apos;C&apos;])index2 = pd.Index([&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;,&apos;F&apos;])index3 = pd.Index([&apos;B&apos;,&apos;C&apos;,&apos;A&apos;])print index1.append(index2)print index1.difference(index2)print index1.intersection(index2)print index1.union(index2) # Support unique-value Index wellprint index1.isin(index2)print index1.delete(2)print index1.insert(0,&apos;K&apos;) # Not suggestedprint index3.drop(&apos;A&apos;) # Support unique-value Index wellprint index1.is_monotonic,index2.is_monotonic,index3.is_monotonicprint index1.is_unique,index2.is_unique,index3.is_unique 输出结果： 1234567891011121314151617181920Index([u&apos;A&apos;, u&apos;B&apos;, u&apos;B&apos;, u&apos;C&apos;, u&apos;C&apos;, u&apos;C&apos;, u&apos;D&apos;, u&apos;E&apos;, u&apos;E&apos;, u&apos;F&apos;], dtype=&apos;object&apos;)Index([u&apos;A&apos;, u&apos;B&apos;], dtype=&apos;object&apos;)Index([u&apos;C&apos;, u&apos;C&apos;], dtype=&apos;object&apos;)Index([u&apos;A&apos;, u&apos;B&apos;, u&apos;B&apos;, u&apos;C&apos;, u&apos;C&apos;, u&apos;D&apos;, u&apos;E&apos;, u&apos;E&apos;, u&apos;F&apos;], dtype=&apos;object&apos;)[False False False True True]Index([u&apos;A&apos;, u&apos;B&apos;, u&apos;C&apos;, u&apos;C&apos;], dtype=&apos;object&apos;)Index([u&apos;K&apos;, u&apos;A&apos;, u&apos;B&apos;, u&apos;B&apos;, u&apos;C&apos;, u&apos;C&apos;], dtype=&apos;object&apos;)Index([u&apos;B&apos;, u&apos;C&apos;], dtype=&apos;object&apos;)True True FalseFalse False True 大熊猫世界来去自如：Pandas的I/O老生常谈，从基础来看，我们仍然关心pandas对于与外部数据是如何交互的。 结构化数据输入输出 read_csv与to_csv 是⼀对输⼊输出的⼯具，read_csv直接返回pandas.DataFrame，⽽to_csv只要执行命令即可写文件 read_table：功能类似 read_fwf：操作fixed width file read_excel与to_excel方便的与excel交互 header 表⽰数据中是否存在列名，如果在第0行就写就写0，并且开始读数据时跳过相应的行数，不存在可以写none names 表示要用给定的列名来作为最终的列名 encoding 表⽰数据集的字符编码，通常而言一份数据为了⽅便的进⾏⽂件传输都以utf-8作为标准 这里用的是自己的一个csv数据，因为找不到参考的这个pdf中的数据。 123456cnames=[&apos;经度&apos;,&apos;纬度&apos;]taxidata2 = pd.read_csv(&apos;20140401.csv&apos;,header = 4,names=cnames,encoding=&apos;utf-8&apos;)taxidata2 全部参数的请移步API： http://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_csv.html#pandas.read_csv 这里介绍一些常用的参数： 读取处理： skiprows：跳过⼀定的⾏数 nrows：仅读取⼀定的⾏数 skipfooter：尾部有固定的⾏数永不读取 skip_blank_lines：空⾏跳过 内容处理： sep/delimiter：分隔符很重要，常⻅的有逗号，空格和Tab(‘\t’) na_values：指定应该被当作na_values的数值 thousands：处理数值类型时，每千位分隔符并不统⼀ (1.234.567,89或者1,234,567.89都可能)，此时要把字符串转化为 数字需要指明千位分隔符 收尾处理： index_col：将真实的某列（列的数⺫，甚⾄列名）当作index squeeze：仅读到⼀列时，不再保存为pandas.DataFrame⽽是pandas.Series Excel … ?对于存储着极为规整数据的Excel而言，其实是没必要一定用Excel来存，尽管Pandas也十分友好的提供了I/O接口。 123456taxidata.to_excel(&apos;t0401.xlsx&apos;,encoding=&apos;utf-8&apos;)taxidata_from_excel = pd.read_excel(&apos;t0401.xlsx&apos;,header=0, encoding=&apos;utf-8&apos;)taxidata_from_excel 注意：当你的xls文件行数很多超过65536时，就会遇到错误，解决办法是将写入的格式变为xlsx。excel函数受限制问题 唯一重要的参数：sheetname=k，标志着一个excel的第k个sheet页将会被取出。（从0开始） 半结构化数据JSON：网络传输中常⽤的⼀种数据格式。 仔细看一下，实际上这就是我们平时收集到异源数据的风格是一致的： 列名不能完全匹配 key可能并不唯一 元数据被保存在数据里 1234567891011121314import jsonjson_data = [&#123;&apos;name&apos;:&apos;Wang&apos;,&apos;sal&apos;:50000,&apos;job&apos;:&apos;VP&apos;&#125;,\ &#123;&apos;name&apos;:&apos;Zhang&apos;,&apos;job&apos;:&apos;Manager&apos;,&apos;report&apos;:&apos;VP&apos;&#125;,\ &#123;&apos;name&apos;:&apos;Li&apos;,&apos;sal&apos;:5000,&apos;report&apos;:&apos;IT&apos;&#125;]data_employee = pd.read_json(json.dumps(json_data))data_employee_ri = data_employee.reindex(columns=[&apos;name&apos;,&apos;job&apos;,&apos;sal&apos;,&apos;report&apos;])data_employee_ri 输出结果： 深入Pandas数据操纵在前面部分的基础上，数据会有更多种操纵方式： 通过列名、行index来取数据，结合ix、iloc灵活的获取数据的一个子集（第一部分已经介绍） 按记录拼接（就像Union All）或者关联（join） 方便的统计函数与⾃定义函数映射 排序 缺失值处理 与Excel一样灵活的数据透视表（在第四部分更详细介绍） 数据集整合横向拼接：直接DataFrame12pd.DataFrame([np.random.rand(2),np.random.rand(2),np.random.rand(2)],columns=[&apos;C1&apos;,&apos;C2&apos;]) 横向拼接：Concatenate12pd.concat([data_employee_ri,data_employee_ri,data_employee_ri]) 输出结果 纵向拼接：Merge根据数据列关联，使用on关键字 可以指定一列或多列 可以使⽤left_on和right_on 12pd.merge(data_employee_ri,data_employee_ri,on=&apos;name&apos;) 根据index关联，可以直接使用left_index和right_index TIPS: 增加how关键字，并指定 how = ‘inner’ how = ‘left’ how = ‘right’ how = ‘outer’ 结合how，可以看到merge基本再现了SQL应有的功能，并保持代码整洁 自定义函数映射123456dataNumPy32 = np.asarray([(&apos;Japan&apos;,&apos;Tokyo&apos;,4000),(&apos;S.Korea&apos;,&apos;Seoul&apos;,1300),(&apos;China&apos;,&apos;Beijing&apos;,9100)])DF32 = pd.DataFrame(dataNumPy32,columns=[&apos;nation&apos;,&apos;capital&apos;,&apos;GDP&apos;])DF32 map: 以相同规则将1列数据作1个映射，也就是进行相同函数的处理123456789101112131415161718192021222324def GDP_Factorize(v): fv = np.float64(v) if fv &gt; 6000.0: return &apos;High&apos; elif fv &lt; 2000.0: return &apos;Low&apos; else: return &apos;Medium&apos;DF32[&apos;GDP_Level&apos;] = DF32[&apos;GDP&apos;].map(GDP_Factorize)DF32[&apos;NATION&apos;] = DF32.nation.map(str.upper)DF32 排序 sort: 按⼀列或者多列的值进行行级排序 sort_index: 根据index⾥的取值进行排序，而且可以根据axis决定是重排行还是列 sort123456dataNumPy33 = np.asarray([(&apos;Japan&apos;,&apos;Tokyo&apos;,4000),(&apos;S.Korea&apos;,&apos;Seoul&apos;,1300),(&apos;China&apos;,&apos;Beijing&apos;,9100)])DF33 = pd.DataFrame(dataNumPy33,columns=[&apos;nation&apos;,&apos;capital&apos;,&apos;GDP&apos;])DF33 12DF33.sort([&apos;capital&apos;,&apos;nation&apos;],ascending=False) ascending是降序的意思。 sort_index12DF33.sort_index(axis=1,ascending=True) 一个好用的功能：Rank12DF33.rank() 缺失数据处理 忽略缺失值：12DF34.mean(skipna=True) 不忽略缺失值的话，估计就不能计算均值了吧。 如果不想忽略缺失值的话，就需要祭出fillna了： 注：这里我在猜想，axis=1是不是就代表从行的角度呢？还是得多读书查资料呀。 “一组”大熊猫：Pandas的groupbygroupby的功能类似SQL的group by关键字： Split-Apply-Combine Split，就是按照规则分组 Apply，通过⼀定的agg函数来获得输⼊pd.Series返回⼀个值的效果 Combine，把结果收集起来 Pandas的groupby的灵活性： 分组的关键字可以来⾃于index，也可以来⾃于真实的列数据 分组规则可以通过⼀列或者多列 没有具体数据，截图看一下吧，方便日后回忆。 分组可以快速实现MapReduce的逻辑 Map: 指定分组的列标签，不同的值就会被扔到不同的分组处理 Reduce: 输入多个值，返回1个值，一般可以通过agg实现，agg能接受1个函数 参考： S1EP3_Pandas.pdf 不知道什么时候存到电脑里的资料，今天发现了它。感谢作者的资料。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Pandas</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂文-2015/12/20]]></title>
    <url>%2F2015%2F12%2F20%2Flife-20151220%2F</url>
    <content type="text"><![CDATA[今天在朋友圈，发现高中同桌q诚当上爸爸了，恭喜。虽然许久都未曾联系，但是还是由衷的内心给予祝福……回想起高中那段时光，真是记忆犹新。 那时为了一道数学难题，可以熬夜到很晚，想解法。那时为了第二天的考试，可以五点多就起床去河边晨读复习古文。那时有很多让自己感觉很用功的例子…… 可是，一切从大学就变了。虽然自己内心一直想努力，可是行动上却没有。事实很残酷，和大多数的人一样，我成为了随波逐流的人群中的一员。回想在海大的四年，多多少少有遗憾。可没有后悔药的。感慨幸运的是，遇到了一群可爱的室友。我们来自五湖四海。重庆娃娃，君。陕西娃娃，贱贱。山东娃娃，全。安徽娃娃，路路。海南娃娃，阿克。江西娃娃，耐克。 可爱的室友们，尽管现在各自奔天涯，不知道彼此都在做些什么……希望一切安好。期待重逢的那天。 上面这些书，本可以在四年里读完，可以读很多倍的数量……原本有很多时间可以自己去折腾感兴趣的技术的…… 时光易逝。 只能说过去的已经过去了。失去的都是人生。珍惜当下，努力创造未来！ 竟然从老同桌晋级为爸爸，想了这么多，其实，归结到内心，还是对自己未来的深深担忧。毕竟，不是自己一个人的人生。女朋友和我一起快五年了。我必须要加油！是的，不能让她，也不能让自己，让家人失望。 眼下的目标就是： 学好python 搞好论文 come on michael！ 晚安，世界]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python机器学习入门资料梳理]]></title>
    <url>%2F2015%2F12%2F16%2Fpython-machine-learning-list%2F</url>
    <content type="text"><![CDATA[在python基本语法入门之后，就要准备选一个研究方向了。Web是自己比较感兴趣的方向，可是，导师这边的数据处理肯定不能由我做主了。paper、peper、paper……真的挺愁人的 还有几个月就要进行春季实习招聘了，加油！总结一下python机器学习方面的资料吧。 1、数据处理1.1 综合 Scipy SciPy is a Python-based ecosystem of open-source software for mathematics, science, and engineering. In particular, these are some of the core packages这里集合着python科学计算的几乎所有核心库，也是一个导航。 Scipy Lecture Notes 极力推荐的一个学习笔记！ Scipy Tutorial scientific-python-lectures Jupyter 1.2 Numpy Numpy Tutorial Index Numpy 遇到Numpy陌生函数，查询用法，推荐！ 1.3 Pandas pandas主页 pandas主页，可以进入它的相关文档教程 pandas documents pandas史上最强参考文档集合 10 Minutes to pandas 十分钟搞定pandas 翻译版 API Reference Index Pandas 遇到陌生函数，查询用法，推荐！ pandas教程-百度经验 1.4 Matplotlib Matplotlib Gallery 提供一些图像例子 Matplotlib Tutorial(译) 翻译原文 matplotlib - 2D and 3D plotting in Python 2、数据可视化2.1 SeabornSeaborn is a Python data visualization library with an emphasis on statistical plots. The library is an excellent resource for common regression and distribution plots 2.2 Plotly Python Library 印刷品质的图片质量啊！ 3、机器算法3.1综合 用python做科学计算 五星推荐的中文学习资料！！！ scikit-learn 3.2 Cluster-聚类算法 Comparing Python Clustering Algorithms 3.3 GA(Genetic Algorithm) Pyevolve documentation]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>整理</tag>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git入门私房菜]]></title>
    <url>%2F2015%2F12%2F07%2Fgit-tutor%2F</url>
    <content type="text"><![CDATA[昨天下午参考廖雪峰的博客和其他一些文章，简单了解了一下传说中的Git，发现常见用法入门还是挺容易上手的，在此做一些笔记，方便以后查阅和复习。 Git安装Linuxsudo apt-get install git命令安装Git Windows官网下载 安装即可，不赘述。 注：安装时注意一步：选择第二项，将git添加到path中。 创建版本库 创建项目文件夹，例如：demo 进入demo目录下：git init命令将这个目录变成git可以管理的仓库（repository）。将仓库建好后，仓库目录下会多了一个.git隐藏文件夹。可以用ls -ah查看隐藏文件。 向库里添加一个readme.txt文件： git add告诉git，要把文件添加到仓库： 1git add readme.txt 执行命令，其实，这一步的作用就是将文件添加到stage（暂存区）。 git add .将所有文件添加到暂存区。 git add -u将所有文件添加暂存区，同时，将删除的文件从仓库中删除。 git commit命令，将文件提交到仓库。 1git commit -m &quot;wrote a readme file&quot; 注：-m是对本次提交的说明，不该偷懒省去。 git status查看当前版本库的状态。 git diff显示具体的尚未缓存的改动记录。 git log记录每次commit的信息。git log --pretty=oneline将每次commit的记录打印成一行，内容精简。 git reset修改命令： git reset HEAD废除这次修改记录，当前文件回到上一次提交的状态。 `git reset –hard [commit id] git rm慎用。这个命令会将所有版本库记录删除。 远程仓库创建SSH Key。在类似C:\Users\xiang_000\.ssh这样的主目录下，查看是否有id_rsa和id_rsa.pub文件。如果有了，直接可以将公钥添加到github账户上。如果没有，打开Shell(windows下的Git Bash): 1ssh-keygen -t rsa -C &quot;youremail@example.com&quot; id_rsa.pub是公钥，可以放心的告诉任何人。 在github的Account settings里，Add SSH Key。 从远程库克隆如果从零开发，推荐的方式是先在github上创建远程仓库。然后，从远程库克隆。 在github创建名为：learngit的新仓库。勾选添加README.md。 git clone克隆一个本地库： 1git clone git@github.com:michael728/learngit.git 添加(关联）远程库如果本地已经有本地仓库了，要和远程的仓库关联起来。在github创建新的repo，名字为：demo。根据github的提示，在本地的demo仓库下运行命令： 1git remote add origin git@github.com:michae728/demo.git` 请千万注意，把上面的michae728替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 将本地库的所有内容推送到远程库上： 1git push -u origin master 把当前本地分支master推送到远程。由于之前远程库是空的，第一次推送master分支时，加上了-u参数。git不但把本地的master分支内容推送到远程新的master分支，还会把本地master分支和远程的master分支关联起来，以后推送或者拉取就可以简化命令。 从现在起，本地提交，可通过命令： 1git push origin master 分享与更新项目git push: git push origin dev表示提交到远程的dev分支。 通常在本地的dev分支推送到远程的dev分支，注意两地分支命名要相同，保证不发生混乱 git pull: git pull origin dev表示拉远程dev分支到本地，并和本地dev分支合并 git fetch(不常用）： git fetch origin dev表示拉远程dev分支到本地，但是，不和本地dev分支合并 git remote: git remote add github git@github.com:michael728/test.git将本地仓库推送到github上名为test的仓库里 分支管理创建于合并分支创建dev分支，然后切换到dev分支： 1git checkout -b dev 相当于下面两条命令：12git branch devgit checkout dev git branch命令用于查看当前分支。当前分支前面会有*: git branch查看本地分支 git branch -a查看本地和远程所有分支 git branch -r查看远程分支 git branch -d删除本地分支 git push :origin dev删除远程dev分支 git checkout master命令用于dev分支完成工作后，切换回master分支。 git merge用于本地的指令。如果当前分支是master，本地另一个分支是dev，用下面命令将分支合并到master： 1git merge dev 后悔药版本回退git log来查询历史记录。git log --pretty=oneline显示精简信息。 git中，HEAD表示当前版本，上一个版本就是HEAD^,上上个版本HEAD^^，上100个版本，写成HEAD~100。 回到上一个版本： 1git reset --hard HEAD^ 或者通过git reset --hard [commit id]回到指定版本号的版本。 git版本的回退速度很快，因为git内部有个指向当前版本的HEAD指针。git仅仅是通过修改HEAD指向就可以完成版本切换的工作。 git reflog用来查看命令历史。通过这个，就可以查到之前的版本号啦！ 工作区和暂存区工作区（Working Directory) 例如我们创建的demo文件夹，他就是一个工作区。 版本库（Repository) 工作区有一个隐藏目录.git，这个不算工作区，它是git的版本库。 git的版本库里存了很多东西，最重要的是称为stage的暂存区，还有git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 说明： git add实际上就是把文件修改添加到暂存区； git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建爱你git版本库是，git自动为我们创建了唯一一个master分支，所以，现在git commit就是往master分支上提交更改。（因为以后还有可能往分支上提交啊！） + `git status`可以查看状态。如果有文件从来没有被添加过，那么它的状态是：`Untracked`。 + 提交成功后，如果没有对工作区做任何修改，那么工作区就是`working directory clean` 管理修改 git diff HEAD -- README.md 命令查看工作区和版本库里最新版本的区别。 撤销修改分为两种情况的修改： 修改了工作区某个文件的内容，想直接丢弃修改： 1git checkout -- filename 注：--前后都有空格。 当修改了工作区内容，同时，添加到了暂存区，分两步： 用命令git reset HEAD filename,回到场景1 用场景1的方法操作。 删除文件当删除了工作区的文件，git知道删除了文件，因此，工作区和版本库就不一致。git status命令会立刻告诉那些文件被删除了。有两个选择： 确实要从版本库里删除该文件，用命令git rm fimename,之后git commit提交。 误删，因为版本库里还有，可以很轻松的把误删的文件恢复到最新版：git checkout -- filename 注：git checkout其实是用版本库里的东西替换工作区的版本。无论工作区是修改还是删除，都可以一键还原。 附件 欢迎来我的博客：Git入门私房菜 参考 廖雪峰git教程 21分钟入门Git]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python入门资料大全(更新ing)]]></title>
    <url>%2F2015%2F12%2F02%2Fpython-files-list%2F</url>
    <content type="text"><![CDATA[一、说明面对网络上纷繁复杂的资料，自己真是眼花缭乱，学的毫无章法，东一榔头西一棒子，这样不仅知识不能成为体系，自己的学习进度也不容易掌握，收效甚微。突然有个想法，就是把自己这几天收藏的资料整理出文章出来，方便自己有章可依…… PS:附上一些python相关的好文： 萧大的编程入门指南知乎获赞无数的编程指南，介绍的不光是一门语言的入门，也是关于编程的入门，谈到了作为一名程序员，应该掌握的一些计算机知识。 Python 编码风格指南中译版（Google SOC）PythonTab中文网二、Python社区Python Tip社区 强烈推荐Python Tip,有刷题挑战赛，同时，也有很多在线教程！练手实操必备！ 啄木鸟社区编程指南社区Co三、入门阶段介绍一些入门的资料，对于有编程经验的同学来讲，入门资料学习并不是很费力。 简明教程 入门教程里，简明教程算是细节介绍相对详细的了，知识面也覆盖的挺全，入门资料的好选择。 笨办法学python坚持看完了，尽管最后几章没去实现（主要是和我现在的需求不一致，不想花精力在那个上面）。有所收获吧，但是，确实是入门的，知识不全面，入门够用，风格特别，采用问答形式，学习过程挺有趣。 Python|Codecademy在线挑战，还没用过，貌似现在对英文资料心里还有种抵触，必须克服！！！ 实验楼python研发工程师包含了Linux/Vim/Git/SQL/Python/Django/Flask等学习课程。 老齐的零基础学Python（第二版）github版本，教程内容覆盖很全，也有实战项目介绍。 廖雪峰python2.7教程现在已经有python3的教程了。 Vamei的的python快速教程话说，我还加入了博主的粉丝群，后来加入了微信群，逗比一枚啊，现在好像去新加坡深造去了！博客文章还是很详细的~ 总结到这儿我已经有乱花渐入迷人眼的感觉了！光是入门就这么多资料，看的过来吗？看完得到猴年马月啊！所以必须痛下决心，选择自己觉得好的就OK！青菜萝卜，各有所爱，别人觉得好的，可能在你这儿就是看着不舒服！好吧，自己就选择简明，笨办法，还有，codecademy!ok,暂时就这样了！ 四、充实阶段入门之后，对于这个语言的细节需要更进一步的了解，那么提升阶段必不可少。同时，对于计算机基础不好的同学，了解计算机及编程相关背景知识也很关键。 《Python基础教程》根据自己学习javascript的经验，一本好的教材真是获益匪浅，它能让你明白很多底层的东西。比如红宝书《js高级程序设计》中关于闭包、原型链的讲解就非常详细！好吧，扯远了，因此，学习python也是一样，光是靠博客，在线文章是不能深入了解它的，选择一门经典教材是你深入了解一门语言的必经之路！当然，也有推荐《Python核心编程（第二版）》的，但是自己只买了《Python基础教程》因此，不做评价了，选中一本经典就可以了！何况自己离吃透它，还有很远的距离的！ MIT计算机科学及编程导论Harvard:计算机科学cs502和3属于计算机入门课，之所以放到这儿，是因为介绍了计算机领域中相关的知识点，了解数据结构相关知识。其中，MIT的导论课老师的知识点是基于Python的，在学习时也能巩固Python。编程入门指南中强烈推荐的的两门公开课。（PS：网易真是良心，这两门课都有中英字幕的视频！） Crossin教室除了python教程之外，还有小程序，练手很好！在第一阶段入门之后，来这里做应用小程序，会找到成就感！除此之外，还有git等其他教程。是个不错的入门练手的地方。 五、升华阶段有了扎实的基础，那么方向的选择显得尤为重要了。是数据分析，是web开发，还是游戏开发。下面暂时分为这三个方面整理一下： 5.1 数据分析利用Python进行数据分析这本书是一本大而全的利用Python数据分析的书，数据分析入门肯定够够的，写的也很详细。书的作者就是开发了用于数据分析的著名开源Python库——pandas的作者！ scientific-python-lectures英文资料，对Python数据分析中要用到的一些库，pandas,numpy,matplotlib等等做了简要介绍。Ipython Notebook形式的资料，示例代码都很全。 Matplotlib Tutorial(译)Python制图的入门资料，强烈推荐！在线版的资料，作者排版也很舒服，示例代码也有，推荐！ 5.2 web开发自强学堂Django基础教程很详细的一个Django教程，作者很详细的介绍了每一步。有问题，作者回复也很详细，推荐！同时，自强学堂上也有很多其他教程，是个不错的网站，收藏！ Django搭建简易博客教程建议和1结合看，1的介绍相对更详细一点。 欢迎进入Flask大型教程项目Flask指南#5.3 游戏开发 用Python和Pygame写游戏-从入门到精通六、 计算机素养《深入理解计算机系统》七、 Python面试题 聊聊Python面试那些事儿 暂时总结到这儿了，和大家分享一下，希望有帮助！]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>List</tag>
        <tag>Python</tag>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo之Next主题优化整理]]></title>
    <url>%2F2015%2F11%2F30%2Fhexo-next-optimize%2F</url>
    <content type="text"><![CDATA[搭建hexo的教程实在太多了，折腾了几天，总算搞定了，现在去看参考文章也是能看懂，不过，官方文档也写的相当详细： Hexo Next Yml语法验证 hexo主题 hexo-theme hexo-github-theme-list 有那些好看的hexo主题？ Next主题添加多说新建站点时会创建多说域名：创建站点完成后在 站点配置文件（不是主题配置文件）中新增 duoshuo_shortname 字段，值设置成上一步中的值。duoshuo_shortname: michael-xox其他主题主题添加多说，参考： http://dev.duoshuo.com/threads/541d3b2b40b5abcd2e4df0e9 http://dev.duoshuo.com/docs/5016427f77cf5fa30500000e hexo命令更新hexo：npm update -g hexo 更新主题：cd 到主题文件夹，执行命令：git pull 更新插件：npm update 因为重装系统的缘故，重新要配置一下环境。简要做个笔记。 Windows下npm安装Hexo失败的解放方案因为国外源网速不好的原因，安装hexo失败，可以采用如下方案：命令搞定HEXO!!!12345678# 添加淘宝源npm install -g cnpm --registry=https://registry.npm.taobao.org# nrm类似包管理器cnpm install nrm -gnrm ls# 使用淘宝nrm use taobaonpm install -g hexo-cli 大功告成！ http://www.codes51.com/itwd/1327882.htmlhttp://www.thinksaas.cn/ask/question/21934/ 安装NEXT1git clone https://github.com/iissnan/hexo-theme-next themes/next 参考：Next配置 优化头像设置编辑 站点配置文件，新增字段 avatar， 值设置成头像的链接地址。avatar: http://i5.tietuku.com/0d972d2b106fc7ea.jpg 网站logo设置 通过网站favicon在线制作制作favicon图片，logo最好设置32*32。 next主题：将图片放在next主题source/images目录下 在next主题配置文件中添加：favicon: images/favicon.ico 添加关于页面hexo new page &quot;about&quot;在source文件夹下就会有about文件夹，编辑index.md，然后进入主题的_config.yml中，menu下的#about注释去掉 添加目录云、标签云页面12hexo new page &quot;tags&quot;hexo new page &quot;categories&quot; 然后设置同上，去掉主题配置文件中的注释，调整菜单顺序 设置侧边栏头像在站点配置文件，不是主题配置文件中，添加：12avatar: url#avatar: /uploads/avatar.jpg 设置网站图标Logo 通过网站favicon在线制作制作favicon图片，logo最好设置32*32。 next主题：将图片放在next主题source/images目录下 在next主题配置文件中添加：favicon: images/favicon.ico或者把favicon.ico放到主题文件夹source文件夹下就可以了-》favicon: /favicon.ico12# Put your favicon.ico into `hexo-site/source/` directory.favicon: /images/favicon.ico 增加打赏功能 hexo博客Next主题添加打赏功能 hexo next 主题添加打赏功能 实现网站的打赏功能 为Hexo博客添加版权说明和打赏功能 设置阅读次数 为NexT主题添加文章阅读量统计功能 为博客文章添加阅读量统计功能-LeanCloud 添加最近访客和多说 动动手指，NexT主题与Hexo更搭哦（基础篇） 动动手指，给你的Hexo站点添加最近访客（多说篇） SEO Hexo NexT 主题SEO优化指南 个人博客SEO实践 Hexo教程(四)-hexo博客被搜索引擎收录 Hexo+nexT主题搭建个人博客 安装sitemap扩展： 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在你的hexo站点的_config.yml添加下面的代码: 12345# hexo sitemap网站地图sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 注意：这个地方的空格要符合语法规范！ 提交sitemap参考next主题官方解答：添加 Google Webmaster tools 验证 配置成功后，hexo编译时会在hexo站点根目录生成sitemap.xml和baidusitemap.xml其中sitemap.xml适合提交给谷歌搜素引擎，baidusitemap.xml适合提交百度搜索引擎。其次，在robots.txt中添加下面的一段代码： 12Sitemap: http://www.arao.me/sitemap.xmlSitemap: http://www.arao.me/baidusitemap.xml 参考这篇文章hexo干货系列：（六）hexo提交搜索引擎（百度+谷歌） 提交sitemap.xml 添加友链在主题配置文件 _config.yml中Sidebar Settings部分添加字段：123456# Blogrollslinks_title: 友情链接links_layout: inlinelinks_icon: link # 设置图标links: Michael翔: http://michaelxiang.me 添加搜索 安装npm install generarot-search 在站点配置文件，不是主题配置文件中，添加：1234# 添加搜索search: path: search.xml field: all 注意：需要在站点配置文件中设置：url: http://michaelxiang.me/，否则搜索的结果点击链接，会跳转到错误页面。 添加背景 参考hexo引用自定义js文件和css样式，在github资源中找到particle.js，将其下载到本地主题文件夹D:\03TBP\TBP\BLOG\themes\next\source\js\src类似这样的文件夹下。 然后在主题layout/_layout.swig中的最后body标签上添加&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particle.js&quot;&gt;&lt;/script&gt; 参考 Hexo博客优化 - Next主题个性化定制-推荐！！！ hexo下新建页面下如何放多个文章？ 玩转Hexo博客之Next 动动手指，不限于NexT主题的Hexo优化（SEO篇） 博客推广——提交搜索引擎SEO Next主题常见问题 主题配置 2017-05-25更新： Hexo搭建个人博客-资料整理标签（空格分隔）： 软件 安装准备Git配置SSH git下载 安装完成之后，配置git环境[^1] [^2]：12git config --global user.name &quot;username&quot;git config --global user.email &quot;username@example.com&quot; [^1]:Hexo 3.1.1 静态博客搭建指南 [^2]:GitHub Pages + Hexo搭建博客 生成公钥：12# C:\Users\xiang\.sshssh-keygen -t rsa -C &quot;username@example.com&quot; 然后在C:\Users\michael\.ssh文件夹下查看id_rsa.pub,复制全部内容，添加到github账户中： 验证成功1ssh -T git@github.com 设置，下次部属时不用密码：12git initgit remote set-url origin SSH对应的url（去github对应博客的download查看） 在github创建博客项目：创建Github Repository：Repository名字必须是你的Github名.github.io，比如我是michael728.github.io Node下载安装 Node官方地址 部署Hexo Hexo官方文档 新建一个文件夹，比如，Blog，然后进入该文件夹下： 12npm install hexo-cli -ghexo version 安装依赖包1npm install 配置站点文件为了能够使Hexo部署到GitHub上，需要安装一个插件：1npm install hexo-deployer-git --save 部署博客的配置：12345678910# Deployment## Docs: http://hexo.io/docs/deployment.html# deploy:# type: git# repo: git@github.com:michael728/michael728.github.io.git # branch: masterdeploy: type: git repo: git@github.com:Michael728/michael728.github.io.git #从github博客项目复制，切换为ssh地址 branch: master Front-matterFront-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说：123title: Hello Worlddate: 2013/7/13 20:46:25--- 比如，在material主题中，在这儿可以通过关键字thumbnail:，填上图片的url地址，设置每篇文章的缩略图 Next主题首先区分两个概念： 主题配置文件 站点配置文件 Next主题下的_config.yml就是主题配置文件，而站点目录下的_config.yml则是站点配置文件 安装： Next-github Next文档 Next作者blog 动动手指，NexT主题与Hexo更搭哦（基础篇） 进入theme文件夹下,执行：1git clone https://github.com/iissnan/hexo-theme-next.git 执行完成之后，在theme文件夹下则会出现next文件夹。 启用Next主题，在站点配置文件中，设置：1theme: next 评论： disqus 主题配置文件中，设置了：1disqus_shortname: michaelxiang 注意：如果有集成评论服务，页面也会带有评论。 若需要关闭的话，请添加字段 comments 并将值设置为 false，如：1234title: 标签date: 2014-12-22 12:39:04type: &quot;tags&quot;comments: false 搜索http://theme-next.iissnan.com/third-party-services.html#search-system添加百度/谷歌/本地 自定义站点内容搜索 1.安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：1$ npm install hexo-generator-searchdb --save 2.编辑 站点配置文件，新增以下内容到任意位置：12345search: path: search.xml field: post format: html limit: 10000 3.编辑 主题配置文件，启用本地搜索功能：123# Local searchlocal_search: enable: true 新建页面举例，新建一个“工具”页面。先执行命令：1hexo new page &quot;tools&quot; 然后在主题配置文件中的menu添加相应的内容：12345678910menu: home: / categories: /categories archives: /archives tags: /tags books: /categories/books #hexo new page &quot;books&quot;要修改三个地方，去language下面，修改zh-hans中才菜单，添加中文 diary: /diary #如果是上面这种结构，则显示该文件夹下所有文章，这后面的英文，要是new page &quot;xx&quot;保持一致 nav: /nav #导航 别忘了添加图标和中文 tools: /tools about: /about 接着，添加对应的中文名字，在next-languages-zh-Hans文件中：123456789101112menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 books: 书单 diary: 札记 nav: 书签 tools: 工具 commonweal: 公益404 最后，还要设置相应的图标，主题配置文件中：12345678910111213menu_icons: enable: true #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: user categories: th tags: tags archives: archive books: book #参考fontawsomehttp://fontawesome.io/icons/网站图标，还要去修改language中zh-Hans.yml,添加中文说明 diary: leaf nav: bookmark #别忘了去添加相应中文 tools: paper-plane commonweal: heartbeat 图标链接： 不蒜子统计http://theme-next.iissnan.com/third-party-services.html#analytics-busuanzi 编辑 主题配置文件 中的busuanzi_count的配置项。 当enable: true时，代表开启全局开关。若site_uv、site_pv、page_pv的值均为false时，不蒜子仅作记录而不会在页面上显示。 分享服务http://theme-next.iissnan.com/third-party-services.html#share-system 主题配置文件中：JiaThis 分享服务1jiathis: true 给next主题添加打赏http://theme-next.iissnan.com/theme-settings.html#reward123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /path/to/wechat-reward-imagealipay: /path/to/alipay-reward-image 添加文章阅读统计 为NexT主题添加文章阅读量统计功能 设置RSShttps://github.com/hexojs/hexo-generator-feed安装扩展：1npm install hexo-generator-feed --save 然后在站点配置文件中设置：123456feed: type: atom path: atom.xml limit: 20 hub: content: 设置侧边栏头像旋转http://leeyom.top/2016/09/29/hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/ 主要是修改 Hexo 目录下 \themes\next\source\css\_common\components\sidebar\sidebar-author.styl文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ -webkit-animation: play 2s ease-out 1s 1; -moz-animation: play 2s ease-out 1s 1; animation: play 2s ease-out 1s 1; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 站点建立时间个时间将在站点的底部显示，例如© 2013 - 2015。 编辑 主题配置文件，新增字段 since。1since: 2015 SEO优化给你的hexo站点添加sitemap网站地图安装hexo的sitemap网站地图生成插件 123npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save在你的hexo站点的_config.yml添加下面的代码 hexo sitemap网站地图1234sitemap:path: sitemap.xmlbaidusitemap:path: baidusitemap.xml 配置成功后，hexo编译时会在hexo站点根目录生成sitemap.xml和baidusitemap.xml其中sitemap.xml适合提交给谷歌搜素引擎，baidusitemap.xml适合提交百度搜索引擎。其次，在robots.txt中添加下面的一段代码：12Sitemap: http://www.arao.me/sitemap.xmlSitemap: http://www.arao.me/baidusitemap.xml 参考： http://www.arao.me/2015/hexo-next-theme-optimize-seo/ 给next主题添加背景图片 给hexo个人博客 next主题添加背景图片 Materail主题安装 hexo-theme-material-github material文档 material作者个人blog 进入theme文件夹下,执行：1git clone https://github.com/viosey/hexo-theme-material.git 下载完成之后，修改文件夹名为：material，同时将主题配置文件_config.template.yml修改为：_config.yml设置站点配置文件中的语言：language: zh-CN，这个和Next主题的zh-Hans是有区别的。 然后测试：123hexo cleanhexo ghexo s 访问地址：http://localhost:4000/ 按照material文档文档，可以设置主题的背景等，按照说明文档一步一步设置即可。 dropdown-侧边栏邮箱https://material.viosey.com/intro/#dropdown下拉菜单这里，如果不去language设置dropdown对应的中文，那么，就会显示undefined。 设置独立页面 Material icons 主题文档-Pages 123456hexo new page &quot;about&quot; #新建关于我的页面，其实这条命令就是在根目录source文件夹下新建了一个about文件夹pages: About: #这里可以把它改为关于我 link: &quot;#about&quot; icon: person divider: false 作为一个单位。Name 是该独立页面的名称，请自行修改。link 的参数为相对路径，对应 hexo 目录下的 source 文件夹内的相应文件夹。icon 的参数为自定义的 Material 图标，可用图标可在 Material icons 查询。divider 设置成 true 后会在该条目底部增加一条分割线 PS:菜单显示中文,只需要将“About”设置为“关于我”，因为它的链接link设置对应的文件夹了，比Next主题添加稍微简单点，那个还需要去主题的language中添加对应的中文 创建友链 设置RSS 说明 插件github地址 123456789$ npm install hexo-generator-feed --save#You can configure this plugin in _config.yml.feed: type: atom path: atom.xml limit: 20 hub: content: Qrcode-设置二维码，手机扫描阅读1npm install hexo-helper-qrcode --save 用于在文章页中显示二维码，扫描二维码即可直接打开文章。qrcode: true topPost置顶文章使用该插件可以将指定文章置顶。如果您需要这个功能，请使用 npm install hexo-helper-post-top --save安装支持插件。之后在您需要置顶文章的 front-matter中，添加 top: true 即可置顶。 Hexo插入音乐/视频 通过 Hexo 插件插入音乐/视频 Maupassant主题-大道至简 Maupassant-github Maupassant-中文文档 命令12345678hexo help #查看帮助hexo init #初始化一个目录hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面，其实作用就是在根目录source目录下，添加一个about的文件夹hexo generate #生成网页, 可以在 public 目录查看整个网站的文件hexo server #本地预览, &apos;Ctrl+C&apos;关闭hexo deploy #部署.deploy目录hexo clean #清除缓存, 多台机器同步每次上传之前，删除同步文件夹下的.deploy_git文件夹。 参考文章 hexo的next主题个性化配置教程-推荐 SF-自己-Hexo+Github Page部署个人博客资源整理 解决用Hexo和GitHub搭建博客时hexo d命令报错问题 Hexo搭建静态博客 Hexo+nexT主题搭建个人博客 hexo博客进阶教程]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo之github\gitcafe多线路托管博客，DNS域名设置]]></title>
    <url>%2F2015%2F11%2F30%2Fhexo-gitcafe-github-dns-goddaddy-set%2F</url>
    <content type="text"><![CDATA[上一篇挖坑总结（1）中已经详细讲解了同时部署到gitcafe和github上的方法了，那么，接下来要讲解的就是DNS域名相关的问题： 在goddaddy上购买域名关于goddaddy购买域名及设置的流程，就不再说了，很简单，可以参考：Godaddy优惠码网站 设置github及gitcafegithub要在博客站点source文件夹，如：E:\KP\my_blog\source下新建CNAME文件，编辑加入：michaelxiang.megithub官方参考：Categories / GitHub Pages Basics gitcafe在gitcafe的page设置，添加域名:michaelxiang.megitcafe官方参考：gitcafe关于page说明 Dnspod域名解析设置github相关想要访问michaelxiang.me是通过github访问，我们在dnspod设置完CNAME就够了。 gitcafe相关在dnspod里设置，为了让国内ip访问michaelxiang.me是通过gitcafe，我们需要设置CNAME。 说明： 这里建议用设置CNAME的方式，为了防止github或者gitcafe主机迁移导致A记录的ip也需要更改才能访问的额弊病。 gitcafe的记录值，gitcafe.io，而不是用户名+gitcafe.io,这和github不一样，归功于gitcafe提供的域名绑定功能！ 主机记录是@,没用其他的，这样设置就OK了，因为我自己用的是裸域名。Hexo多Repo部署——使用Github和GitCafe同时托管博客 线路类型，gitcafe对应的是国内,github对应的是默认，这么设置的话，那么国内ip访问就是访问的gitcafe，国外ip就是github。 如下图，可以设置监控，当有问题时，切换解析。 测试1ping michaelxiang.me 我们将会看到，它的实际访问ip，就是gitcafe.io。懂点ping方面的知识也是不错的，也算是这次搭建hexo博客的收获之一。 经过比较，发现，gitcafe的博客访问速度确实要快一点。 听过ping可以发现如果是要增加A记录的话，ip地址该写多少。通过dnspod解析域名 已发送若是大于已接收的话，就代表发生了丢包的现象 通过ping+网址\ip 地址，可以查看主机运行情况 #参考 关于CNAME介绍参考dnspod官方参考]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo之github\gitcafe多线路托管博客deploy及SSH设置问题]]></title>
    <url>%2F2015%2F11%2F30%2Fhexo-gitcafe-github-deploy%2F</url>
    <content type="text"><![CDATA[github时常抽风，访问不了，速度和国内的gitcafe相比，也稍微慢一点。那么通过将博客文件部属同时部署到这两个网站，之后通过DNS域名等设置，国内访问gitcafe，国外访问github，这样就ok啦！ 检查SSH keys的设置github官方参考文档：generating ssh keys检查电脑上现有的SSH，简单点单来说，SSH就是和秘钥有关的文件，可以看这篇《理解git,github和SSH Keys》1cd ~/.ssh 咱们要是配置过，ssh一般都在C:\Users\xiang_000\.ssh这样的文件加下。如果检查到有这样的文件，咱们如果现在是在重新搭建的话，可以把这个备份到别处，防止有用，然后把它们删除，然后重新生成。 双SSH生成通过Git bash窗口，生成新的SSH 生成github的SSH1ssh-keygen -t rsa -C &quot;github的email“ 会看到很多需要确认的，咱们一路Enter到底。 github账户设置中添加SSH在C:\Users\xiang_000\.ssh文件夹下就有了github_rsa、github_ras.pub,用编辑器打开pub文件，将公钥添加到github accounting-&gt;add key 配置账户信息现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成自己的。 12git config --global user.name &quot;github账户名，不是昵称&quot;git config --global user.email &quot;github邮箱名&quot; 测试1ssh -T git@github.com 看到successfully就代表上述配置就没问题，可以正常连接到github啦！ 生成gitcafe的SSH官方的参考文档就很详细了，参考：如何同时使用多个公秘钥1ssh-keygen -t rsa -C &quot;YOUR_EMAIL@YOUREMAIL.COM&quot; -f ~/.ssh/gitcafe 这样生成的gitcafe的ssh在C:\Users\xiang_000\.ssh目录下就有别名，和github生成就有区分。然后步骤差不多，将gitcafe的pub添加到gitcafe中。 Github\Gitcafe双Deploy部属双部属参考文章：hexo博客搭建时遇到的问题在 SSH 用户配置文件 ~/.ssh/config 中指定对应服务所使用的公秘钥名称(config文件的作用就是告诉git程序在同步认证的时候该使用哪个密钥），如果没有 config 文件的话就新建一个，并输入以下内容：12345678Host github.comUser gitHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443Host gitcafe.com www.gitcafe.comIdentityFile ~/.ssh/gitcafe 注:新建config的两种方式： 新建txt文件,添加完内容之后，重命名，把txt格式名去掉。 touch config命令新建，再用编辑器打开 hexo站点deploy配置123456deploy:type: gitmessage: &quot;xxxxx&quot;repo:github: git@github.com:michael728/michael728.github.io.git,mastergitcafe: git@gitcafe.com:michael233/michael233.git,gitcafe-pages 注意：repo的格式要这么写，因为我们部属时，是利用的ssh方式，所以千万别写成:repo: https://github.com/michael728/michael728.github.io.git 部属，同步到gitcafe\github上12hexo cleanhexo d 关于之后的DNS域名等设置，看下一篇文章。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows上那些值得推荐的良心软件-整理]]></title>
    <url>%2F2015%2F11%2F28%2Ftools-list-win%2F</url>
    <content type="text"><![CDATA[Windows系统挺好用的，并不像有些程序员说的那么不堪，尽管我也一直想体验Mac，哈哈……言归正传，Win10的变化还是挺明显的，很多地方都进行了优化，个人觉得有一条技巧使用起来还是很方便的：不要管桌面有多乱，怎么方便怎么来！（强迫症患者无视……） 做法就是把常用的软件全部固定到“开始”屏幕，这样设置以后的好处就是：比如当你正在浏览器浏览网页时，想打开微信，就只要两步，按一下Win键+点击微信；如果将软件图标放在桌面的话，则需要三步，缩小你正在浏览的网页，然后切换到桌面，打开微信。很明显，你正在做的事情就被打乱了…… 工欲善其事，必先利其器！ 日常工具文件搜索 Listary 小众软件介绍，超级好用的文件搜索工具，按下快捷键，随时搜索 Everything 也是传说中的文档搜索神器！其他功能有待开发…… 聊天 TIM-QQ QQ最新推出的简洁办公版本，还不错 微信 视频播放 PotPlayer 厌烦了暴风一打开就是广告，发现了这款播放器，没广告！能力出色！ 射手播放器 没有广告，字幕匹配很方便！ QQ影音 没有广告，也很清爽 下载神器 FDM 最近体验过的最棒的下载工具了，开源免费，无广告，虽然IDM也很强大，但是IDM要钱呀，FDM一样用！2017-04-03 EagleGet 这样好的下载神器，竟然这么默默无闻，简直没有道理啊！用它来下载百度云上的资源速度也是杠杠赞！用来替代浏览器自带下载要好很多，速度快很多！缺陷是不支持BT/磁力链接…… 硕鼠 视频下载神器！为了下载PC上的网易公开课发现的工具，很多视频网站都能下载！ 维棠播放器 之前了解过的一个视频下载软件，没有体验过，据说厉害。 浏览器 Chrome 很占内存，但启动速度、标签、扩展同步等真是做的棒！一个账号，走遍天下~安利下自己总结的Chrome扩展 Chrome下载 由于某些原因，你可能无法下载扩展，这里可以帮你下载 crx4chrome FireFox 其实火狐也是不错的，它的同步是可以用的，不像chrome 需要架梯子~ 解压软件 Bandizip 清新简洁，功能很强大，最喜欢它可以设置双击直接解压，无需其他操作 7zip 著名解压软件，也是免费 笔记 印象笔记 很棒！裁剪、搜索、标签等细节功能做的很到位！简洁大气的风格，很喜欢。双十一入手了一年的VIP，hia~hia~ 有道笔记 网易的良心产品之一，推荐 pdf查看 福昕pdf阅读正版 Sumatra PDF 体积小，除了支持 PDF 阅读之外，epub 等电子书格式它也支持 电子书查看器 calibre Ebook-Reader 看图 FastStoneImageViewer 免费软件，好用到爆！没广告！功能齐全！不光能看图，还能修图！ 输入法 搜狗 搜狗输入，跨平台性确实很好，广告什么的其实可以通过设置去除的！ rime rime输入法，跨平台的良心输入法，也没有广告！ 截图 搜狗输入法 哈哈，没看错！就是它！安装截图扩展之后，快捷键就能截图，哪个电脑都ok，多方便！我的技巧总结 snipaste 国人开发的一款截图软件，挺简洁的 picpick 确实很棒的一个截图工具，很强大，界面也很舒服 sharex 一款功能非常强大的开源软件，需要学习使用，功能确实太多了 FastStone Capture 这款需要收费，但是可以很多资源找到免费的,比如这里 togif gif动态图制作软件 邮箱 Foxmail 除了接收邮件，还有RSS订阅功能！ 加密工具 Wise Folder Hider Free 隐私文件怎么保存？这个获奖无数的工具，免费版足够用啦！ 写作工具 typora 韩国的一款Markdown写作工具，免费的，简介好用！ 1checker 英文写作，语法校对工具 思维导图 Xmind 今天体验了一下思维导图，虽然Freemind是开源免费的，但是，这款付费的显然更胜一筹啊！颜控必备！ ProcessOn 强烈推荐，绘制思维导图、流程图等，真的很方便！看个栗子《大型网站技术架构》读书笔记 文件整理 Q-dir 有时候需要在文件夹之间移动文件，这时候，这个整理神器就能派上用场了！ 快速启动 MaxLauncer 最近发现的一款不错的软件，可以通过快捷键快速启动软件！ Wox 也是一个软件启动神器，值得体验！ 小众工具 Wgesture 用惯浏览器鼠标手势的同志，这个绝对是你们的福利！全局鼠标手势！！！ Ditto 剪贴板工具，效率必备，对于经常文字编辑的人员，那就是神器了！最近一直在使用！ 学术工具 NoteExpress 高校大多都购买了，既然有正版，为何还要千方百计去折腾外国的呢？挺好用~ 同步盘 百度云2016年这一年关了很多免费的网盘，貌似就百度网盘坚挺了，百度云也改名为百度网盘，百度云应该作为百度的云品牌发展了！果然免费的不会一直免费下去的！ OneDrive 买希捷的移动硬盘送的容量，就试试了，结果发现用来同步简直太爽了！！！而且，Windows基本都自带，其实体验挺好的！据说，淘宝可以买扩容量套餐微云腾讯的微云也不失为一种选择，尽管，最新的政策出来了，免费空间也降低了！ FileGee 卸载清理 RevoUninstaller卸载程序必备神器！体验了Iobit家的卸载产品之后，仍然回头来使用这款！有机会写篇文章来介绍一下。 Unlocker下载 当你重命名或删除一个文件/文件夹时,Windows 弹出对话框提示你“无法删除 xxx:它正在被其它用户/程序使用!”,怎么办? ccleaner 免费的系统清理软件 系统优化右键菜单管理 右键菜单-FileMenuTolls 这是一个神器，在右键菜单中方便提供了很多小功能，比如，文件校验功能，就能方便的验证系统镜像文件是否完整，有没有被修改。 屏保 fliqlo 数字时钟，屏幕保护，逼格满满 flux 视力保护，通过根据时间调节屏幕颜色，减少蓝光对视力的影响，效果有点类似iphone开启眼见屏幕保护色。 系统安全 火绒安全 最近发现的比较安静的安全软件，最喜欢它的窗口拦截功能，比如迅雷的那些弹窗，他都给拦截掉了！ 系统修复 PowerTool 查看系统进程等信息，安全修复！ Dism++ 知乎看到的，简洁的系统管理软件，集成了很多小工具，还可以系统备份 Dock 栏 RocketDock 可以在屏幕上添加Dock栏，将常用快捷方式添加到状态栏上！有点Mac效果的感觉 系统相关安装系统准备 MSDN镜像下载 干净的系统镜像！ 清华大学开源软件镜像站 可以下载到很多Linux镜像，速度很快！ easybcd 引导工具 easyuefi 引导工具 ultraiso 制作启动盘 双系统 Windows10+Ubuntu双系统安装[多图] windows10+ubuntu 16.04+双硬盘（SSD+HDD）分区（图文） Ubuntu 16.04与Win10双系统双硬盘安装图解 有这三篇文章，基本是够了，需要注意的点是：要知道你的是UEFI+GPT还是传统的MRB！ 系统检测 AIAD64 硬件检测工具，里边功能很丰富！ 硬盘性能检测-AS SSD Benchmark CrystalDiskMark UWP-CrystalDiskMark 5 资源软件资源 正版中国 filehippo 软件缘 大眼仔 精品绿色便携软件 软矿 殁漂遥 吾乐吧软件站 sourceforge softpedia 反斗软件 参考 Windows 10 上什么软件值得推荐？ Windows 平台有哪些值得推荐的常用软件？ 推荐-Gitbook-Windows绝赞应用 Windows 下的开发工具控制台 cmder 如果厌倦了Windows下控制台丑陋不方便的样子，可以试试这个,强烈安利！这是一篇比较好的介绍文章Win下必备神器之Cmder 编辑器 VScode 微软家的编辑器，最近都在使用，强烈推荐，写作一篇总结打造性感好用的VS Code编辑器 Sublime Text Notepad++ Atom IDE Pycharm 这么棒的软件，学生党免费！前提是要有学校邮箱~下载链接 附上一个我写的使用总结PyCharm/IDEA 使用技巧总结 Redo python调试很方便，界面有点类似R-studio、 PyScripter python开发 WebStorm 最后除了这些软件，还总结了一份利器清单，主要是网页在线版的工具： 利器]]></content>
      <categories>
        <category>ToolsDaily</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python多版本共存工具-Pyenv及Anaconda科学计算环境的配置]]></title>
    <url>%2F2015%2F11%2F26%2Fpython-pyenv-anaconda%2F</url>
    <content type="text"><![CDATA[为了安装Anaconda科学计算环境，控制好Python版本，今天上午总算折腾好了。 学习python有时希望在python2.7环境下，有时希望在python3.4环境下，该怎么办呢？ Anconda的包也不知道适合在什么环境下工作？ 解决多python环境下，python版本切换的工具–pyenv应运而生。同时，另外一个工具virtualenv则提供了一种功能， 就是将一个目录建立为一个虚拟的python环境， 这样的话， 用户可以建立多个虚拟环境， 每个环境里面的python版本可以是不同的， 也可以是相同的， 而且环境之间相互独立。下面简要介绍一下安装的过程： Unix系统下pyenv安装与使用:安装pyenv12345678$ git clone https://github.com/yyuu/pyenv.git ~/.pyenv #使用 git 把 pyenv 下载到家目录$ echo &apos;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&apos; &gt;&gt; ~/.bashrc #然后需要修改环境变量，使用 Bash Shell 的输入$ echo &apos;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&apos; &gt;&gt; ~/.bashrc$ echo &apos;eval &quot;$(pyenv init -)&quot;&apos; &gt;&gt; ~/.bashrc #最后添加 pyenv init$ exec $SHELL -l #输入命令重启 Shell,然后就可以重启pyenv 查看pyenv可安装的版本列表1$ pyenv install --list 該命令将列出pyenv可以安装的列表，单单列举几个咱们关心的python和anaconda把： 12345672.7.8 # Python 2最新版本3.4.1 # Python 3最新版本anaconda-2.4.0 # 支持Python 2.6和2.7anaconda3-2.0.1 # 支持Python 3.3和3.4 安装指定的python版本。1$ pyenv install 3.4.1 该命令会从github上下载python的源代码安装，但是，我这里主要是用来进行科学计算的环境安装，因此，最后选择安装anaconda-2.4.0（python2.7环境） 和 anaconda3-2.4.0（python3.4环境）。可以选择都安装，之后可以使用pyenv进行版本的切换。注： 这里利用pyenv命令安装的python版本都安装在~.pyenv/versions文件夹下，当然，如果你从图形界面进入Ubuntu的用户主目录下可能看不见.pyenv文件夹，这时候，你可以使用ls -a看到隐藏的文件夹。 使用pip安装的包完成之后，可能需要对数据库进行更新:1pyenv rehash 卸载指定的python版本1pyenv uninstall x.x.x python版本查看查看当前已经安装了的python版本：1pyenv versions 输出结果如下：1234*system (set by /home/michael/.pyenv/version)2.7.13.4.1anaconda-2.4.0 system是指系统的python版本；*表示当前环境所处于的python版本 python版本切换全局版本切换：1pyenv global anaconda-2.4.0 全局切换为anaconda科学计算环境，因为，我现在也不做其他python开发，所以，无需再安装其他环境了。查看现在的python版本： 12345michael@michael-ThinkCentre-XXXX:~$ pyenv versionssystem2.7.13.4.1* anaconda-2.4.0 (set by /home/michael/.pyenv/version) 有全局版本切换，当然也会有局部环境的切换：在test文件夹下希望切换到python3.4.1:1pyenv local python3.4.1 Anaconda科学计算包的使用：使用conda list查看anaconda安装自带的包：1234567891011michael@michael-ThinkCentre-XXXX:~/test$ conda list# packages in environment at /home/michael/.pyenv/versions/anaconda-2.4.0:#abstract-rendering 0.5.1 np110py27_0alabaster 0.7.6 py27_0anaconda 2.4.0 np110py27_0anaconda-client 1.1.0 py27_0argcomplete 1.0.0 py27_1astropy 1.0.5 np110py27_1babel 2.1.1 py27_0backports.ssl-match-hostname 3.4.0.2 &lt;pip&gt; 注： 使用conda list命令的环境时python版本切换到anaconda版本下，不然，这个命令无法来查询。 看上面列表就能知道，anaconda的环境下，也是能使用系统pip命令安装的包的！ 给anaconda安装包1conda install ×××× 如果需要指定包的版本。1[package-name]=x.x #指定包的版本 多个Python版本并存，尤其是2.x和3.x的并存。这个通过virtualenv可以做到。Anaconda也正是通过其实现的。下面用conda创建一个名叫python2的版本为python2.7的环境。 1conda create -n python2 python=2.7 这样就会在Anaconda安装目录下的envs目录下创建python2这个目录。向其中安装扩展可以： 直接用conda install并用-n指明安装到的环境，这里自然就是python2。像virtualenv那样，先activate，然后在虚拟环境中安装。注： 关于virtualenv的使用，还需了解，可以参考python生态 下面的操作，貌似会安装很多包，谨慎使用。 1conda create -n py34 python=3.4 anaconda 利用Pycharm的版本切换功能~推荐！很方便！可以选择安装anaconda 不同的版本，然后按照下面操作,切换版本。Windows/Linux下都有[Pycharm][1]。 打开pycharm，打开preference –&gt; project –&gt; project interpreter–&gt; Windows系统切换首先当然是安装你需要的两个不同版本的python，我安装的是2.7和3.4的，两个版本安装顺序无所谓，但是后面安装的会变成默认的（因为我是后安装的python 3.4，它就变成了默认的python）。 然后去python27 文件夹下面把python.exe改名python2.exe，然后就可以在命令行下通过python或者py来调用3.x，python2来调用2.x。 另外pip的话直接使用 pip2 或者 pip3 就可以了。 参考：pyenv Python多版本共存之pyenv yyuu/pyenv-github 用pyenv 和 virtualenv 搭建单机多版本python 虚拟开发环境 lixm/pybooklet-github 使用 pyenv 和 Miniconda 管理 Python 科学计算环境 Python 2.X 3.X 多版本共存 一篇文章入门Python生态系统 Anaconda DOWNLOAD ANACONDA NOW P]ython科学计算利器——Anaconda Python科学计算发行版—Anaconda Virtualenv(待续) https://virtualenv.pypa.io/en/latest/installation.html]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些离不开的 Chrome 扩展插件]]></title>
    <url>%2F2015%2F11%2F26%2Ftools-chrome-extentions%2F</url>
    <content type="text"><![CDATA[虽然Chrome浏览器是个吃内存的怪兽，但是，它却因为启动速度、调试功能等成为了程序猿的必备浏览器！今天有时间，整理一下自己最常用的一些Chrome扩展吧： 常用网页浏览非开发类扩展：Tampermonkey推荐指数：★★★★★最近发现的神器啊，哈哈，很喜欢，利用脚本比安装扩展少用内存啊！速度还快！用法也很简单–20151202更新用法简要记录下： Greasy Fork国内油猴脚本的下载地，常用的百度网盘助手,去除贴吧列表里面的广告，CSDN去广告自动展开文章等脚本都有 当找到脚本之后，点击安装即可，然后在相关网站，就会有效果了。例如，在百度网盘下载页面，就会有百度助手下载按钮出现。 在相应页面点击油猴扩展，可以查看脚本，可以禁用。也可以卸载安装过的脚本。 两个可以发现好用的脚本的网站： https://greasyfork.org/zh-CN https://openuserjs.org/ 下图是我目前在用的几个脚本： 解除B站区域限制解锁B站其他区域的视频 CSDN自动展开+去广告+净化剪贴板+免登陆 EX-百度云盘 MiniblogImgPop - 微博浮图 MoreMovieRatings 豆瓣查看电影时，会有烂番茄的评价 Yet Another Weibo Filter 看真正想看的微博 还你一个清爽的微博 百度网盘直接下载助手 直链加速版 破解VIP会员视频集合 观看 VIP 视频时，左侧会有可播放列表 OneTab推荐指数：★★★★★ Chrome是个吃内存的怪兽啊！有了这个神器，网页打开再多都不怕啦！必装！推荐！ Markdown Here推荐指数：★★★★★ 这个扩展简直是Markdown的福音啊！！！在写邮件、印象|为知笔记（命名不需要.md)在线版编辑文字时,遵循Markdown语法编辑文字，然后点击Markdown Here扩展就可以可以一键渲染！渲染效果可以在该扩展选项里进行设置，多个主题可以选择！没钱入手马克飞象的同志们，可以考虑用这个神器啊！！！从此，邮件也可以回复的有逼格啦! 新浪微博图床推荐指数：★★★★★ 简单好用的新浪微博图床,支持选择/拖拽/粘贴上传图片,并生成图片地址,HTML,UBB和Markdown等格式,支持浏览和删除历史记录。 扩展管理器推荐指数：★★★★★ 对于经常折腾扩展的同志们，就不用担心扩展安装多了，chrome就卡的问题！有了它，轻松管理扩展，暂时不用却又舍不得卸载的扩展，就可以左击一键禁用和启用，右击卸载。必装！这个插件是最新（20190303）发现的，比之前的 SimpleExtManager 好用点 右键搜推荐指数：★★★★ 看到扩展这么多设置选项，就知道它的功能是有多强大了！功能就是如它的扩展名一样，对于浏览网页时的图片，链接等，右键点击，提供很多扩展功能，例如： 对图片右击，可以选择去谷歌搜索相似图片|解析图片的网址|提取图片二维码 对页面右击，可以定制进入浏览器扩展程序菜单|查看内存|生成当前网址二维码更关键的是，它还支持自定义很多功能，例如，你可以设置对选中文字，进行在知乎里搜索！可以通过方法，自定义搜索引擎！必装神器！ 眼不见心不烦（新浪微博）推荐指数：★★★★★ Chrome就是满分评价，可见这扩展真是良心扩展啊！微博党的福音！在浏览器端，自己通过这个插件进行设置，可以将热门微博、会员推广等等内容窗口都给屏蔽了！还我们一个干净、舒服的微博环境！推荐！！！ LastPass: Free Password Manager推荐指数：★★★★★ LastPass,屡获殊荣的密码管理器,保存你的密码,让你安全访问任何计算机和移动设备。多平台同步，离不开的密码神器！安全可靠~ Chrono下载管理器推荐指数：★★★★ 这是个下载扩展，好用！之前在下载百度网盘文件时，点击下载，需要一堆操作，登录网盘，保存到网盘……为啥就不能直接下载呢？！直到我发现了它！点击下载就立马启动Chrome自带的下载器下载了！个人觉得离不开，必装！ 网页截图:注释&amp;批注推荐指数：★★★★ 在安装了一堆截图扩展之后，最后剩下了它，满足了截图所有的需求，截取可见网页，选择区域，整个网页，另外，还有对截图的标记。 印象笔记·剪藏推荐指数：★★★★★ 作为一名大象用户，这个扩展肯定是必装！这里必须稍微介绍一下它的使用： 收藏网页 截图 在百度，google搜索内容时，提供搜索笔记相关内容的功能，出现在搜索结果第一行 uBlock Origin推荐指数：★★★★★ 发现这一款效果也很好！ Save to Pocket推荐指数：★★★★ 看到感兴趣的先收藏着，然后走哪儿都能看，因为它提供了全平台的APP，方便管理。Pocket也是手机端我必装的APP之一。 Imagus推荐指数：★★★★ 图片放大镜的功能！在体验了360浏览器、猎豹浏览器之后，特地去找的扩展！微博党的利器！这个不管能鼠标悬停放大图片，同时，对链接等也有预览。提供很多功能选项进行设置。 crxMouse Chrome Gestures推荐指数：★★★★ 对于国产浏览器自带鼠标手势的功能，真觉得很方便！这款扩展也是必装啊！ 标签页Infinity新标签页推荐指数：★★★★ 功能强大的新建标签页扩展！做的界面很美，每日壁纸质量也很高！有同步笔记、代办事项等，同时，喜欢它的网页图标，提供了很多常用网站的图标，自定义书签时很好看~唯一的缺点，就是感觉启动比较慢~ Momentum推荐指数：★★★★ 现在在用的标签页扩展，挺简洁的，壁纸很美！ 惠惠购物助手推荐指数：★★★ 剁手党的神器！本来想给五星的，但是，双十一期间，竟然对淘宝不能查价了！减了两个★！还有，安装它之后，必须要进入扩展选项设置，不然这货会弹出广告！ 程序猿开发相关扩展：Vimium推荐指数：★★★★★ 12345shift+b # 搜索你书签中的链接，所以，保存书签的时候，设置点关键字吧x # 快速关闭标签shift+x # 快速恢复你之前关闭的标签gg # 回到页首G # 回到页尾 VIM党的利器吧，可惜，自己还未完全掌握…… API 测试工具 Restlet Client - REST API Testing 颜值比较高，另外，Postman 已经提供独立的软件了，推荐 Clear Cache推荐指数：★★★★★ 点击图标即可清除缓存、cookie等，开发必备！ JSON Viewer Awesome推荐指数：★★★★★ 看到同事用的，颜值超高的JSON文件渲染，比之前用的JSON Viewer颜值还要高，更方便！ Git这里列几个和 Git 相关的 octotree推荐指数：★★★★★ Web浏览Github项目时必备的插键，快速查看项目结构 sourcegraph推荐指数：★★★★★ sourcegraph配合 Github 使用，真是利器，有点 WebIDE 的感觉 Git History Browser Extension推荐指数：★★★★★ 官网Git History介绍只需要将 GitHub 仓库的 『github.com』网址替换为『github.githistory.xyz』，则可以动态显示文件的提交历史 Isometric Contributions推荐指数：★★★ 3D 展示你 Github 上的提交活动，酷炫的 WhatRuns推荐指数：★★★★★ 查看访问的网页主要采用了什么技术框架，之前有个类似的插键 wappalyzer，没这个全 Code Cola推荐指数：★★★★ Code Cola是一个可视化编辑在线页面css样式的chrome插件。 WEB前端助手(FeHelper)推荐指数：★★★★ FE助手：包括字符串编解码、图片base64编码、代码压缩、美化、JSON格式化、正则表达式、时间转换工具、二维码生成器、编码规范检测、页面性能检测、栅格检测、JS运行效率分析等 二维码(QR码)生成器推荐指数：★★★★ 前端开发调试，生成当前网页的二维码 XPath Helper爬虫好像使用到的一个插键，这里有个教程 XPath Helper：chrome爬虫网页解析工具 Chrome插件图文教程 Changelog20190303 去除了一些不用的插键 补充了工作后用到的一些有用的插键，比如 git 相关的 参考 Chrome插件英雄榜 介绍了一些比较少见的扩展，掘金上发的一篇文章]]></content>
      <categories>
        <category>ToolsDaily</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>扩展</tag>
        <tag>效率软件</tag>
      </tags>
  </entry>
</search>
